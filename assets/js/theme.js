(function(){var __webpack_modules__={42:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * hoverIntent v1.9.0 // 2017.09.01 // jQuery v1.7.0+\n * http://briancherne.github.io/jquery-hoverIntent/\n *\n * You may use hoverIntent under the terms of the MIT license. Basically that\n * means you are free to use hoverIntent as long as this header is left intact.\n * Copyright 2007-2017 Brian Cherne\n */\n!function (factory) {\n  "use strict";\n\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(669)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(function ($) {\n  "use strict";\n\n  var cX,\n    cY,\n    _cfg = {\n      interval: 100,\n      sensitivity: 6,\n      timeout: 0\n    },\n    INSTANCE_COUNT = 0,\n    track = function track(ev) {\n      cX = ev.pageX, cY = ev.pageY;\n    },\n    compare = function compare(ev, $el, s, cfg) {\n      if (Math.sqrt((s.pX - cX) * (s.pX - cX) + (s.pY - cY) * (s.pY - cY)) < cfg.sensitivity) return $el.off(s.event, track), delete s.timeoutId, s.isActive = !0, ev.pageX = cX, ev.pageY = cY, delete s.pX, delete s.pY, cfg.over.apply($el[0], [ev]);\n      s.pX = cX, s.pY = cY, s.timeoutId = setTimeout(function () {\n        compare(ev, $el, s, cfg);\n      }, cfg.interval);\n    },\n    delay = function delay(ev, $el, s, out) {\n      return delete $el.data("hoverIntent")[s.id], out.apply($el[0], [ev]);\n    };\n  $.fn.hoverIntent = function (handlerIn, handlerOut, selector) {\n    var instanceId = INSTANCE_COUNT++,\n      cfg = $.extend({}, _cfg);\n    $.isPlainObject(handlerIn) ? (cfg = $.extend(cfg, handlerIn), $.isFunction(cfg.out) || (cfg.out = cfg.over)) : cfg = $.isFunction(handlerOut) ? $.extend(cfg, {\n      over: handlerIn,\n      out: handlerOut,\n      selector: selector\n    }) : $.extend(cfg, {\n      over: handlerIn,\n      out: handlerIn,\n      selector: handlerOut\n    });\n    var handleHover = function handleHover(e) {\n      var ev = $.extend({}, e),\n        $el = $(this),\n        hoverIntentData = $el.data("hoverIntent");\n      hoverIntentData || $el.data("hoverIntent", hoverIntentData = {});\n      var state = hoverIntentData[instanceId];\n      state || (hoverIntentData[instanceId] = state = {\n        id: instanceId\n      }), state.timeoutId && (state.timeoutId = clearTimeout(state.timeoutId));\n      var mousemove = state.event = "mousemove.hoverIntent.hoverIntent" + instanceId;\n      if ("mouseenter" === e.type) {\n        if (state.isActive) return;\n        state.pX = ev.pageX, state.pY = ev.pageY, $el.off(mousemove, track).on(mousemove, track), state.timeoutId = setTimeout(function () {\n          compare(ev, $el, state, cfg);\n        }, cfg.interval);\n      } else {\n        if (!state.isActive) return;\n        $el.off(mousemove, track), state.timeoutId = setTimeout(function () {\n          delay(ev, $el, state, cfg.out);\n        }, cfg.timeout);\n      }\n    };\n    return this.on({\n      "mouseenter.hoverIntent": handleHover,\n      "mouseleave.hoverIntent": handleHover\n    }, cfg.selector);\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL2pzL2xpYi9qcXVlcnkuaG92ZXJJbnRlbnQubWluLmpzPzljY2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBob3ZlckludGVudCB2MS45LjAgLy8gMjAxNy4wOS4wMSAvLyBqUXVlcnkgdjEuNy4wK1xuICogaHR0cDovL2JyaWFuY2hlcm5lLmdpdGh1Yi5pby9qcXVlcnktaG92ZXJJbnRlbnQvXG4gKlxuICogWW91IG1heSB1c2UgaG92ZXJJbnRlbnQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZS4gQmFzaWNhbGx5IHRoYXRcbiAqIG1lYW5zIHlvdSBhcmUgZnJlZSB0byB1c2UgaG92ZXJJbnRlbnQgYXMgbG9uZyBhcyB0aGlzIGhlYWRlciBpcyBsZWZ0IGludGFjdC5cbiAqIENvcHlyaWdodCAyMDA3LTIwMTcgQnJpYW4gQ2hlcm5lXG4gKi9cbiFmdW5jdGlvbiAoZmFjdG9yeSkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtcImpxdWVyeVwiXSwgZmFjdG9yeSkgOiBqUXVlcnkgJiYgIWpRdWVyeS5mbi5ob3ZlckludGVudCAmJiBmYWN0b3J5KGpRdWVyeSk7XG59KGZ1bmN0aW9uICgkKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjWCxcbiAgICBjWSxcbiAgICBfY2ZnID0ge1xuICAgICAgaW50ZXJ2YWw6IDEwMCxcbiAgICAgIHNlbnNpdGl2aXR5OiA2LFxuICAgICAgdGltZW91dDogMFxuICAgIH0sXG4gICAgSU5TVEFOQ0VfQ09VTlQgPSAwLFxuICAgIHRyYWNrID0gZnVuY3Rpb24gdHJhY2soZXYpIHtcbiAgICAgIGNYID0gZXYucGFnZVgsIGNZID0gZXYucGFnZVk7XG4gICAgfSxcbiAgICBjb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShldiwgJGVsLCBzLCBjZmcpIHtcbiAgICAgIGlmIChNYXRoLnNxcnQoKHMucFggLSBjWCkgKiAocy5wWCAtIGNYKSArIChzLnBZIC0gY1kpICogKHMucFkgLSBjWSkpIDwgY2ZnLnNlbnNpdGl2aXR5KSByZXR1cm4gJGVsLm9mZihzLmV2ZW50LCB0cmFjayksIGRlbGV0ZSBzLnRpbWVvdXRJZCwgcy5pc0FjdGl2ZSA9ICEwLCBldi5wYWdlWCA9IGNYLCBldi5wYWdlWSA9IGNZLCBkZWxldGUgcy5wWCwgZGVsZXRlIHMucFksIGNmZy5vdmVyLmFwcGx5KCRlbFswXSwgW2V2XSk7XG4gICAgICBzLnBYID0gY1gsIHMucFkgPSBjWSwgcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcGFyZShldiwgJGVsLCBzLCBjZmcpO1xuICAgICAgfSwgY2ZnLmludGVydmFsKTtcbiAgICB9LFxuICAgIGRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoZXYsICRlbCwgcywgb3V0KSB7XG4gICAgICByZXR1cm4gZGVsZXRlICRlbC5kYXRhKFwiaG92ZXJJbnRlbnRcIilbcy5pZF0sIG91dC5hcHBseSgkZWxbMF0sIFtldl0pO1xuICAgIH07XG4gICQuZm4uaG92ZXJJbnRlbnQgPSBmdW5jdGlvbiAoaGFuZGxlckluLCBoYW5kbGVyT3V0LCBzZWxlY3Rvcikge1xuICAgIHZhciBpbnN0YW5jZUlkID0gSU5TVEFOQ0VfQ09VTlQrKyxcbiAgICAgIGNmZyA9ICQuZXh0ZW5kKHt9LCBfY2ZnKTtcbiAgICAkLmlzUGxhaW5PYmplY3QoaGFuZGxlckluKSA/IChjZmcgPSAkLmV4dGVuZChjZmcsIGhhbmRsZXJJbiksICQuaXNGdW5jdGlvbihjZmcub3V0KSB8fCAoY2ZnLm91dCA9IGNmZy5vdmVyKSkgOiBjZmcgPSAkLmlzRnVuY3Rpb24oaGFuZGxlck91dCkgPyAkLmV4dGVuZChjZmcsIHtcbiAgICAgIG92ZXI6IGhhbmRsZXJJbixcbiAgICAgIG91dDogaGFuZGxlck91dCxcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgIH0pIDogJC5leHRlbmQoY2ZnLCB7XG4gICAgICBvdmVyOiBoYW5kbGVySW4sXG4gICAgICBvdXQ6IGhhbmRsZXJJbixcbiAgICAgIHNlbGVjdG9yOiBoYW5kbGVyT3V0XG4gICAgfSk7XG4gICAgdmFyIGhhbmRsZUhvdmVyID0gZnVuY3Rpb24gaGFuZGxlSG92ZXIoZSkge1xuICAgICAgdmFyIGV2ID0gJC5leHRlbmQoe30sIGUpLFxuICAgICAgICAkZWwgPSAkKHRoaXMpLFxuICAgICAgICBob3ZlckludGVudERhdGEgPSAkZWwuZGF0YShcImhvdmVySW50ZW50XCIpO1xuICAgICAgaG92ZXJJbnRlbnREYXRhIHx8ICRlbC5kYXRhKFwiaG92ZXJJbnRlbnRcIiwgaG92ZXJJbnRlbnREYXRhID0ge30pO1xuICAgICAgdmFyIHN0YXRlID0gaG92ZXJJbnRlbnREYXRhW2luc3RhbmNlSWRdO1xuICAgICAgc3RhdGUgfHwgKGhvdmVySW50ZW50RGF0YVtpbnN0YW5jZUlkXSA9IHN0YXRlID0ge1xuICAgICAgICBpZDogaW5zdGFuY2VJZFxuICAgICAgfSksIHN0YXRlLnRpbWVvdXRJZCAmJiAoc3RhdGUudGltZW91dElkID0gY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRJZCkpO1xuICAgICAgdmFyIG1vdXNlbW92ZSA9IHN0YXRlLmV2ZW50ID0gXCJtb3VzZW1vdmUuaG92ZXJJbnRlbnQuaG92ZXJJbnRlbnRcIiArIGluc3RhbmNlSWQ7XG4gICAgICBpZiAoXCJtb3VzZWVudGVyXCIgPT09IGUudHlwZSkge1xuICAgICAgICBpZiAoc3RhdGUuaXNBY3RpdmUpIHJldHVybjtcbiAgICAgICAgc3RhdGUucFggPSBldi5wYWdlWCwgc3RhdGUucFkgPSBldi5wYWdlWSwgJGVsLm9mZihtb3VzZW1vdmUsIHRyYWNrKS5vbihtb3VzZW1vdmUsIHRyYWNrKSwgc3RhdGUudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcGFyZShldiwgJGVsLCBzdGF0ZSwgY2ZnKTtcbiAgICAgICAgfSwgY2ZnLmludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc3RhdGUuaXNBY3RpdmUpIHJldHVybjtcbiAgICAgICAgJGVsLm9mZihtb3VzZW1vdmUsIHRyYWNrKSwgc3RhdGUudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVsYXkoZXYsICRlbCwgc3RhdGUsIGNmZy5vdXQpO1xuICAgICAgICB9LCBjZmcudGltZW91dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5vbih7XG4gICAgICBcIm1vdXNlZW50ZXIuaG92ZXJJbnRlbnRcIjogaGFuZGxlSG92ZXIsXG4gICAgICBcIm1vdXNlbGVhdmUuaG92ZXJJbnRlbnRcIjogaGFuZGxlSG92ZXJcbiAgICB9LCBjZmcuc2VsZWN0b3IpO1xuICB9O1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///42\n')},784:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\n/*\n     _ _      _       _\n ___| (_) ___| | __  (_)___\n/ __| | |/ __| |/ /  | / __|\n\\__ \\ | | (__|   < _ | \\__ \\\n|___/_|_|\\___|_|\\_(_)/ |___/\n                   |__/\n\n Version: 1.9.0\n  Author: Ken Wheeler\n Website: http://kenwheeler.github.io\n    Docs: http://kenwheeler.github.io/slick\n    Repo: http://github.com/kenwheeler/slick\n  Issues: http://github.com/kenwheeler/slick/issues\n\n */\n(function (i) {\n  "use strict";\n\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(669)], __WEBPACK_AMD_DEFINE_FACTORY__ = (i),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n})(function (i) {\n  "use strict";\n\n  var e = window.Slick || {};\n  e = function () {\n    function e(e, o) {\n      var s,\n        n = this;\n      n.defaults = {\n        accessibility: !0,\n        adaptiveHeight: !1,\n        appendArrows: i(e),\n        appendDots: i(e),\n        arrows: !0,\n        asNavFor: null,\n        prevArrow: \'<button class="slick-prev" aria-label="Previous" type="button">Previous</button>\',\n        nextArrow: \'<button class="slick-next" aria-label="Next" type="button">Next</button>\',\n        autoplay: !1,\n        autoplaySpeed: 3e3,\n        centerMode: !1,\n        centerPadding: "50px",\n        cssEase: "ease",\n        customPaging: function customPaging(e, t) {\n          return i(\'<button type="button" />\').text(t + 1);\n        },\n        dots: !1,\n        dotsClass: "slick-dots",\n        draggable: !0,\n        easing: "linear",\n        edgeFriction: .35,\n        fade: !1,\n        focusOnSelect: !1,\n        focusOnChange: !1,\n        infinite: !0,\n        initialSlide: 0,\n        lazyLoad: "ondemand",\n        mobileFirst: !1,\n        pauseOnHover: !0,\n        pauseOnFocus: !0,\n        pauseOnDotsHover: !1,\n        respondTo: "window",\n        responsive: null,\n        rows: 1,\n        rtl: !1,\n        slide: "",\n        slidesPerRow: 1,\n        slidesToShow: 1,\n        slidesToScroll: 1,\n        speed: 500,\n        swipe: !0,\n        swipeToSlide: !1,\n        touchMove: !0,\n        touchThreshold: 5,\n        useCSS: !0,\n        useTransform: !0,\n        variableWidth: !1,\n        vertical: !1,\n        verticalSwiping: !1,\n        waitForAnimate: !0,\n        zIndex: 1e3\n      }, n.initials = {\n        animating: !1,\n        dragging: !1,\n        autoPlayTimer: null,\n        currentDirection: 0,\n        currentLeft: null,\n        currentSlide: 0,\n        direction: 1,\n        $dots: null,\n        listWidth: null,\n        listHeight: null,\n        loadIndex: 0,\n        $nextArrow: null,\n        $prevArrow: null,\n        scrolling: !1,\n        slideCount: null,\n        slideWidth: null,\n        $slideTrack: null,\n        $slides: null,\n        sliding: !1,\n        slideOffset: 0,\n        swipeLeft: null,\n        swiping: !1,\n        $list: null,\n        touchObject: {},\n        transformsEnabled: !1,\n        unslicked: !1\n      }, i.extend(n, n.initials), n.activeBreakpoint = null, n.animType = null, n.animProp = null, n.breakpoints = [], n.breakpointSettings = [], n.cssTransitions = !1, n.focussed = !1, n.interrupted = !1, n.hidden = "hidden", n.paused = !0, n.positionProp = null, n.respondTo = null, n.rowCount = 1, n.shouldClick = !0, n.$slider = i(e), n.$slidesCache = null, n.transformType = null, n.transitionType = null, n.visibilityChange = "visibilitychange", n.windowWidth = 0, n.windowTimer = null, s = i(e).data("slick") || {}, n.options = i.extend({}, n.defaults, o, s), n.currentSlide = n.options.initialSlide, n.originalSettings = n.options, "undefined" != typeof document.mozHidden ? (n.hidden = "mozHidden", n.visibilityChange = "mozvisibilitychange") : "undefined" != typeof document.webkitHidden && (n.hidden = "webkitHidden", n.visibilityChange = "webkitvisibilitychange"), n.autoPlay = i.proxy(n.autoPlay, n), n.autoPlayClear = i.proxy(n.autoPlayClear, n), n.autoPlayIterator = i.proxy(n.autoPlayIterator, n), n.changeSlide = i.proxy(n.changeSlide, n), n.clickHandler = i.proxy(n.clickHandler, n), n.selectHandler = i.proxy(n.selectHandler, n), n.setPosition = i.proxy(n.setPosition, n), n.swipeHandler = i.proxy(n.swipeHandler, n), n.dragHandler = i.proxy(n.dragHandler, n), n.keyHandler = i.proxy(n.keyHandler, n), n.instanceUid = t++, n.htmlExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*)$/, n.registerBreakpoints(), n.init(!0);\n    }\n    var t = 0;\n    return e;\n  }(), e.prototype.activateADA = function () {\n    var i = this;\n    i.$slideTrack.find(".slick-active").attr({\n      "aria-hidden": "false"\n    }).find("a, input, button, select").attr({\n      tabindex: "0"\n    });\n  }, e.prototype.addSlide = e.prototype.slickAdd = function (e, t, o) {\n    var s = this;\n    if ("boolean" == typeof t) o = t, t = null;else if (t < 0 || t >= s.slideCount) return !1;\n    s.unload(), "number" == typeof t ? 0 === t && 0 === s.$slides.length ? i(e).appendTo(s.$slideTrack) : o ? i(e).insertBefore(s.$slides.eq(t)) : i(e).insertAfter(s.$slides.eq(t)) : o === !0 ? i(e).prependTo(s.$slideTrack) : i(e).appendTo(s.$slideTrack), s.$slides = s.$slideTrack.children(this.options.slide), s.$slideTrack.children(this.options.slide).detach(), s.$slideTrack.append(s.$slides), s.$slides.each(function (e, t) {\n      i(t).attr("data-slick-index", e);\n    }), s.$slidesCache = s.$slides, s.reinit();\n  }, e.prototype.animateHeight = function () {\n    var i = this;\n    if (1 === i.options.slidesToShow && i.options.adaptiveHeight === !0 && i.options.vertical === !1) {\n      var e = i.$slides.eq(i.currentSlide).outerHeight(!0);\n      i.$list.animate({\n        height: e\n      }, i.options.speed);\n    }\n  }, e.prototype.animateSlide = function (e, t) {\n    var o = {},\n      s = this;\n    s.animateHeight(), s.options.rtl === !0 && s.options.vertical === !1 && (e = -e), s.transformsEnabled === !1 ? s.options.vertical === !1 ? s.$slideTrack.animate({\n      left: e\n    }, s.options.speed, s.options.easing, t) : s.$slideTrack.animate({\n      top: e\n    }, s.options.speed, s.options.easing, t) : s.cssTransitions === !1 ? (s.options.rtl === !0 && (s.currentLeft = -s.currentLeft), i({\n      animStart: s.currentLeft\n    }).animate({\n      animStart: e\n    }, {\n      duration: s.options.speed,\n      easing: s.options.easing,\n      step: function step(i) {\n        i = Math.ceil(i), s.options.vertical === !1 ? (o[s.animType] = "translate(" + i + "px, 0px)", s.$slideTrack.css(o)) : (o[s.animType] = "translate(0px," + i + "px)", s.$slideTrack.css(o));\n      },\n      complete: function complete() {\n        t && t.call();\n      }\n    })) : (s.applyTransition(), e = Math.ceil(e), s.options.vertical === !1 ? o[s.animType] = "translate3d(" + e + "px, 0px, 0px)" : o[s.animType] = "translate3d(0px," + e + "px, 0px)", s.$slideTrack.css(o), t && setTimeout(function () {\n      s.disableTransition(), t.call();\n    }, s.options.speed));\n  }, e.prototype.getNavTarget = function () {\n    var e = this,\n      t = e.options.asNavFor;\n    return t && null !== t && (t = i(t).not(e.$slider)), t;\n  }, e.prototype.asNavFor = function (e) {\n    var t = this,\n      o = t.getNavTarget();\n    null !== o && "object" == _typeof(o) && o.each(function () {\n      var t = i(this).slick("getSlick");\n      t.unslicked || t.slideHandler(e, !0);\n    });\n  }, e.prototype.applyTransition = function (i) {\n    var e = this,\n      t = {};\n    e.options.fade === !1 ? t[e.transitionType] = e.transformType + " " + e.options.speed + "ms " + e.options.cssEase : t[e.transitionType] = "opacity " + e.options.speed + "ms " + e.options.cssEase, e.options.fade === !1 ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t);\n  }, e.prototype.autoPlay = function () {\n    var i = this;\n    i.autoPlayClear(), i.slideCount > i.options.slidesToShow && (i.autoPlayTimer = setInterval(i.autoPlayIterator, i.options.autoplaySpeed));\n  }, e.prototype.autoPlayClear = function () {\n    var i = this;\n    i.autoPlayTimer && clearInterval(i.autoPlayTimer);\n  }, e.prototype.autoPlayIterator = function () {\n    var i = this,\n      e = i.currentSlide + i.options.slidesToScroll;\n    i.paused || i.interrupted || i.focussed || (i.options.infinite === !1 && (1 === i.direction && i.currentSlide + 1 === i.slideCount - 1 ? i.direction = 0 : 0 === i.direction && (e = i.currentSlide - i.options.slidesToScroll, i.currentSlide - 1 === 0 && (i.direction = 1))), i.slideHandler(e));\n  }, e.prototype.buildArrows = function () {\n    var e = this;\n    e.options.arrows === !0 && (e.$prevArrow = i(e.options.prevArrow).addClass("slick-arrow"), e.$nextArrow = i(e.options.nextArrow).addClass("slick-arrow"), e.slideCount > e.options.slidesToShow ? (e.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.prependTo(e.options.appendArrows), e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.appendTo(e.options.appendArrows), e.options.infinite !== !0 && e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : e.$prevArrow.add(e.$nextArrow).addClass("slick-hidden").attr({\n      "aria-disabled": "true",\n      tabindex: "-1"\n    }));\n  }, e.prototype.buildDots = function () {\n    var e,\n      t,\n      o = this;\n    if (o.options.dots === !0 && o.slideCount > o.options.slidesToShow) {\n      for (o.$slider.addClass("slick-dotted"), t = i("<ul />").addClass(o.options.dotsClass), e = 0; e <= o.getDotCount(); e += 1) t.append(i("<li />").append(o.options.customPaging.call(this, o, e)));\n      o.$dots = t.appendTo(o.options.appendDots), o.$dots.find("li").first().addClass("slick-active");\n    }\n  }, e.prototype.buildOut = function () {\n    var e = this;\n    e.$slides = e.$slider.children(e.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), e.slideCount = e.$slides.length, e.$slides.each(function (e, t) {\n      i(t).attr("data-slick-index", e).data("originalStyling", i(t).attr("style") || "");\n    }), e.$slider.addClass("slick-slider"), e.$slideTrack = 0 === e.slideCount ? i(\'<div class="slick-track"/>\').appendTo(e.$slider) : e.$slides.wrapAll(\'<div class="slick-track"/>\').parent(), e.$list = e.$slideTrack.wrap(\'<div class="slick-list"/>\').parent(), e.$slideTrack.css("opacity", 0), e.options.centerMode !== !0 && e.options.swipeToSlide !== !0 || (e.options.slidesToScroll = 1), i("img[data-lazy]", e.$slider).not("[src]").addClass("slick-loading"), e.setupInfinite(), e.buildArrows(), e.buildDots(), e.updateDots(), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), e.options.draggable === !0 && e.$list.addClass("draggable");\n  }, e.prototype.buildRows = function () {\n    var i,\n      e,\n      t,\n      o,\n      s,\n      n,\n      r,\n      l = this;\n    if (o = document.createDocumentFragment(), n = l.$slider.children(), l.options.rows > 0) {\n      for (r = l.options.slidesPerRow * l.options.rows, s = Math.ceil(n.length / r), i = 0; i < s; i++) {\n        var d = document.createElement("div");\n        for (e = 0; e < l.options.rows; e++) {\n          var a = document.createElement("div");\n          for (t = 0; t < l.options.slidesPerRow; t++) {\n            var c = i * r + (e * l.options.slidesPerRow + t);\n            n.get(c) && a.appendChild(n.get(c));\n          }\n          d.appendChild(a);\n        }\n        o.appendChild(d);\n      }\n      l.$slider.empty().append(o), l.$slider.children().children().children().css({\n        width: 100 / l.options.slidesPerRow + "%",\n        display: "inline-block"\n      });\n    }\n  }, e.prototype.checkResponsive = function (e, t) {\n    var o,\n      s,\n      n,\n      r = this,\n      l = !1,\n      d = r.$slider.width(),\n      a = window.innerWidth || i(window).width();\n    if ("window" === r.respondTo ? n = a : "slider" === r.respondTo ? n = d : "min" === r.respondTo && (n = Math.min(a, d)), r.options.responsive && r.options.responsive.length && null !== r.options.responsive) {\n      s = null;\n      for (o in r.breakpoints) r.breakpoints.hasOwnProperty(o) && (r.originalSettings.mobileFirst === !1 ? n < r.breakpoints[o] && (s = r.breakpoints[o]) : n > r.breakpoints[o] && (s = r.breakpoints[o]));\n      null !== s ? null !== r.activeBreakpoint ? (s !== r.activeBreakpoint || t) && (r.activeBreakpoint = s, "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]), e === !0 && (r.currentSlide = r.options.initialSlide), r.refresh(e)), l = s) : (r.activeBreakpoint = s, "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]), e === !0 && (r.currentSlide = r.options.initialSlide), r.refresh(e)), l = s) : null !== r.activeBreakpoint && (r.activeBreakpoint = null, r.options = r.originalSettings, e === !0 && (r.currentSlide = r.options.initialSlide), r.refresh(e), l = s), e || l === !1 || r.$slider.trigger("breakpoint", [r, l]);\n    }\n  }, e.prototype.changeSlide = function (e, t) {\n    var o,\n      s,\n      n,\n      r = this,\n      l = i(e.currentTarget);\n    switch (l.is("a") && e.preventDefault(), l.is("li") || (l = l.closest("li")), n = r.slideCount % r.options.slidesToScroll !== 0, o = n ? 0 : (r.slideCount - r.currentSlide) % r.options.slidesToScroll, e.data.message) {\n      case "previous":\n        s = 0 === o ? r.options.slidesToScroll : r.options.slidesToShow - o, r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide - s, !1, t);\n        break;\n      case "next":\n        s = 0 === o ? r.options.slidesToScroll : o, r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide + s, !1, t);\n        break;\n      case "index":\n        var d = 0 === e.data.index ? 0 : e.data.index || l.index() * r.options.slidesToScroll;\n        r.slideHandler(r.checkNavigable(d), !1, t), l.children().trigger("focus");\n        break;\n      default:\n        return;\n    }\n  }, e.prototype.checkNavigable = function (i) {\n    var e,\n      t,\n      o = this;\n    if (e = o.getNavigableIndexes(), t = 0, i > e[e.length - 1]) i = e[e.length - 1];else for (var s in e) {\n      if (i < e[s]) {\n        i = t;\n        break;\n      }\n      t = e[s];\n    }\n    return i;\n  }, e.prototype.cleanUpEvents = function () {\n    var e = this;\n    e.options.dots && null !== e.$dots && (i("li", e.$dots).off("click.slick", e.changeSlide).off("mouseenter.slick", i.proxy(e.interrupt, e, !0)).off("mouseleave.slick", i.proxy(e.interrupt, e, !1)), e.options.accessibility === !0 && e.$dots.off("keydown.slick", e.keyHandler)), e.$slider.off("focus.slick blur.slick"), e.options.arrows === !0 && e.slideCount > e.options.slidesToShow && (e.$prevArrow && e.$prevArrow.off("click.slick", e.changeSlide), e.$nextArrow && e.$nextArrow.off("click.slick", e.changeSlide), e.options.accessibility === !0 && (e.$prevArrow && e.$prevArrow.off("keydown.slick", e.keyHandler), e.$nextArrow && e.$nextArrow.off("keydown.slick", e.keyHandler))), e.$list.off("touchstart.slick mousedown.slick", e.swipeHandler), e.$list.off("touchmove.slick mousemove.slick", e.swipeHandler), e.$list.off("touchend.slick mouseup.slick", e.swipeHandler), e.$list.off("touchcancel.slick mouseleave.slick", e.swipeHandler), e.$list.off("click.slick", e.clickHandler), i(document).off(e.visibilityChange, e.visibility), e.cleanUpSlideEvents(), e.options.accessibility === !0 && e.$list.off("keydown.slick", e.keyHandler), e.options.focusOnSelect === !0 && i(e.$slideTrack).children().off("click.slick", e.selectHandler), i(window).off("orientationchange.slick.slick-" + e.instanceUid, e.orientationChange), i(window).off("resize.slick.slick-" + e.instanceUid, e.resize), i("[draggable!=true]", e.$slideTrack).off("dragstart", e.preventDefault), i(window).off("load.slick.slick-" + e.instanceUid, e.setPosition);\n  }, e.prototype.cleanUpSlideEvents = function () {\n    var e = this;\n    e.$list.off("mouseenter.slick", i.proxy(e.interrupt, e, !0)), e.$list.off("mouseleave.slick", i.proxy(e.interrupt, e, !1));\n  }, e.prototype.cleanUpRows = function () {\n    var i,\n      e = this;\n    e.options.rows > 0 && (i = e.$slides.children().children(), i.removeAttr("style"), e.$slider.empty().append(i));\n  }, e.prototype.clickHandler = function (i) {\n    var e = this;\n    e.shouldClick === !1 && (i.stopImmediatePropagation(), i.stopPropagation(), i.preventDefault());\n  }, e.prototype.destroy = function (e) {\n    var t = this;\n    t.autoPlayClear(), t.touchObject = {}, t.cleanUpEvents(), i(".slick-cloned", t.$slider).detach(), t.$dots && t.$dots.remove(), t.$prevArrow && t.$prevArrow.length && (t.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.remove()), t.$nextArrow && t.$nextArrow.length && (t.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.remove()), t.$slides && (t.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {\n      i(this).attr("style", i(this).data("originalStyling"));\n    }), t.$slideTrack.children(this.options.slide).detach(), t.$slideTrack.detach(), t.$list.detach(), t.$slider.append(t.$slides)), t.cleanUpRows(), t.$slider.removeClass("slick-slider"), t.$slider.removeClass("slick-initialized"), t.$slider.removeClass("slick-dotted"), t.unslicked = !0, e || t.$slider.trigger("destroy", [t]);\n  }, e.prototype.disableTransition = function (i) {\n    var e = this,\n      t = {};\n    t[e.transitionType] = "", e.options.fade === !1 ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t);\n  }, e.prototype.fadeSlide = function (i, e) {\n    var t = this;\n    t.cssTransitions === !1 ? (t.$slides.eq(i).css({\n      zIndex: t.options.zIndex\n    }), t.$slides.eq(i).animate({\n      opacity: 1\n    }, t.options.speed, t.options.easing, e)) : (t.applyTransition(i), t.$slides.eq(i).css({\n      opacity: 1,\n      zIndex: t.options.zIndex\n    }), e && setTimeout(function () {\n      t.disableTransition(i), e.call();\n    }, t.options.speed));\n  }, e.prototype.fadeSlideOut = function (i) {\n    var e = this;\n    e.cssTransitions === !1 ? e.$slides.eq(i).animate({\n      opacity: 0,\n      zIndex: e.options.zIndex - 2\n    }, e.options.speed, e.options.easing) : (e.applyTransition(i), e.$slides.eq(i).css({\n      opacity: 0,\n      zIndex: e.options.zIndex - 2\n    }));\n  }, e.prototype.filterSlides = e.prototype.slickFilter = function (i) {\n    var e = this;\n    null !== i && (e.$slidesCache = e.$slides, e.unload(), e.$slideTrack.children(this.options.slide).detach(), e.$slidesCache.filter(i).appendTo(e.$slideTrack), e.reinit());\n  }, e.prototype.focusHandler = function () {\n    var e = this;\n    e.$slider.off("focus.slick blur.slick").on("focus.slick", "*", function (t) {\n      var o = i(this);\n      setTimeout(function () {\n        e.options.pauseOnFocus && o.is(":focus") && (e.focussed = !0, e.autoPlay());\n      }, 0);\n    }).on("blur.slick", "*", function (t) {\n      i(this);\n      e.options.pauseOnFocus && (e.focussed = !1, e.autoPlay());\n    });\n  }, e.prototype.getCurrent = e.prototype.slickCurrentSlide = function () {\n    var i = this;\n    return i.currentSlide;\n  }, e.prototype.getDotCount = function () {\n    var i = this,\n      e = 0,\n      t = 0,\n      o = 0;\n    if (i.options.infinite === !0) {\n      if (i.slideCount <= i.options.slidesToShow) ++o;else for (; e < i.slideCount;) ++o, e = t + i.options.slidesToScroll, t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;\n    } else if (i.options.centerMode === !0) o = i.slideCount;else if (i.options.asNavFor) for (; e < i.slideCount;) ++o, e = t + i.options.slidesToScroll, t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;else o = 1 + Math.ceil((i.slideCount - i.options.slidesToShow) / i.options.slidesToScroll);\n    return o - 1;\n  }, e.prototype.getLeft = function (i) {\n    var e,\n      t,\n      o,\n      s,\n      n = this,\n      r = 0;\n    return n.slideOffset = 0, t = n.$slides.first().outerHeight(!0), n.options.infinite === !0 ? (n.slideCount > n.options.slidesToShow && (n.slideOffset = n.slideWidth * n.options.slidesToShow * -1, s = -1, n.options.vertical === !0 && n.options.centerMode === !0 && (2 === n.options.slidesToShow ? s = -1.5 : 1 === n.options.slidesToShow && (s = -2)), r = t * n.options.slidesToShow * s), n.slideCount % n.options.slidesToScroll !== 0 && i + n.options.slidesToScroll > n.slideCount && n.slideCount > n.options.slidesToShow && (i > n.slideCount ? (n.slideOffset = (n.options.slidesToShow - (i - n.slideCount)) * n.slideWidth * -1, r = (n.options.slidesToShow - (i - n.slideCount)) * t * -1) : (n.slideOffset = n.slideCount % n.options.slidesToScroll * n.slideWidth * -1, r = n.slideCount % n.options.slidesToScroll * t * -1))) : i + n.options.slidesToShow > n.slideCount && (n.slideOffset = (i + n.options.slidesToShow - n.slideCount) * n.slideWidth, r = (i + n.options.slidesToShow - n.slideCount) * t), n.slideCount <= n.options.slidesToShow && (n.slideOffset = 0, r = 0), n.options.centerMode === !0 && n.slideCount <= n.options.slidesToShow ? n.slideOffset = n.slideWidth * Math.floor(n.options.slidesToShow) / 2 - n.slideWidth * n.slideCount / 2 : n.options.centerMode === !0 && n.options.infinite === !0 ? n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2) - n.slideWidth : n.options.centerMode === !0 && (n.slideOffset = 0, n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2)), e = n.options.vertical === !1 ? i * n.slideWidth * -1 + n.slideOffset : i * t * -1 + r, n.options.variableWidth === !0 && (o = n.slideCount <= n.options.slidesToShow || n.options.infinite === !1 ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow), e = n.options.rtl === !0 ? o[0] ? (n.$slideTrack.width() - o[0].offsetLeft - o.width()) * -1 : 0 : o[0] ? o[0].offsetLeft * -1 : 0, n.options.centerMode === !0 && (o = n.slideCount <= n.options.slidesToShow || n.options.infinite === !1 ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow + 1), e = n.options.rtl === !0 ? o[0] ? (n.$slideTrack.width() - o[0].offsetLeft - o.width()) * -1 : 0 : o[0] ? o[0].offsetLeft * -1 : 0, e += (n.$list.width() - o.outerWidth()) / 2)), e;\n  }, e.prototype.getOption = e.prototype.slickGetOption = function (i) {\n    var e = this;\n    return e.options[i];\n  }, e.prototype.getNavigableIndexes = function () {\n    var i,\n      e = this,\n      t = 0,\n      o = 0,\n      s = [];\n    for (e.options.infinite === !1 ? i = e.slideCount : (t = e.options.slidesToScroll * -1, o = e.options.slidesToScroll * -1, i = 2 * e.slideCount); t < i;) s.push(t), t = o + e.options.slidesToScroll, o += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;\n    return s;\n  }, e.prototype.getSlick = function () {\n    return this;\n  }, e.prototype.getSlideCount = function () {\n    var e,\n      t,\n      o,\n      s,\n      n = this;\n    return s = n.options.centerMode === !0 ? Math.floor(n.$list.width() / 2) : 0, o = n.swipeLeft * -1 + s, n.options.swipeToSlide === !0 ? (n.$slideTrack.find(".slick-slide").each(function (e, s) {\n      var r, l, d;\n      if (r = i(s).outerWidth(), l = s.offsetLeft, n.options.centerMode !== !0 && (l += r / 2), d = l + r, o < d) return t = s, !1;\n    }), e = Math.abs(i(t).attr("data-slick-index") - n.currentSlide) || 1) : n.options.slidesToScroll;\n  }, e.prototype.goTo = e.prototype.slickGoTo = function (i, e) {\n    var t = this;\n    t.changeSlide({\n      data: {\n        message: "index",\n        index: parseInt(i)\n      }\n    }, e);\n  }, e.prototype.init = function (e) {\n    var t = this;\n    i(t.$slider).hasClass("slick-initialized") || (i(t.$slider).addClass("slick-initialized"), t.buildRows(), t.buildOut(), t.setProps(), t.startLoad(), t.loadSlider(), t.initializeEvents(), t.updateArrows(), t.updateDots(), t.checkResponsive(!0), t.focusHandler()), e && t.$slider.trigger("init", [t]), t.options.accessibility === !0 && t.initADA(), t.options.autoplay && (t.paused = !1, t.autoPlay());\n  }, e.prototype.initADA = function () {\n    var e = this,\n      t = Math.ceil(e.slideCount / e.options.slidesToShow),\n      o = e.getNavigableIndexes().filter(function (i) {\n        return i >= 0 && i < e.slideCount;\n      });\n    e.$slides.add(e.$slideTrack.find(".slick-cloned")).attr({\n      "aria-hidden": "true",\n      tabindex: "-1"\n    }).find("a, input, button, select").attr({\n      tabindex: "-1"\n    }), null !== e.$dots && (e.$slides.not(e.$slideTrack.find(".slick-cloned")).each(function (t) {\n      var s = o.indexOf(t);\n      if (i(this).attr({\n        role: "tabpanel",\n        id: "slick-slide" + e.instanceUid + t,\n        tabindex: -1\n      }), s !== -1) {\n        var n = "slick-slide-control" + e.instanceUid + s;\n        i("#" + n).length && i(this).attr({\n          "aria-describedby": n\n        });\n      }\n    }), e.$dots.attr("role", "tablist").find("li").each(function (s) {\n      var n = o[s];\n      i(this).attr({\n        role: "presentation"\n      }), i(this).find("button").first().attr({\n        role: "tab",\n        id: "slick-slide-control" + e.instanceUid + s,\n        "aria-controls": "slick-slide" + e.instanceUid + n,\n        "aria-label": s + 1 + " of " + t,\n        "aria-selected": null,\n        tabindex: "-1"\n      });\n    }).eq(e.currentSlide).find("button").attr({\n      "aria-selected": "true",\n      tabindex: "0"\n    }).end());\n    for (var s = e.currentSlide, n = s + e.options.slidesToShow; s < n; s++) e.options.focusOnChange ? e.$slides.eq(s).attr({\n      tabindex: "0"\n    }) : e.$slides.eq(s).removeAttr("tabindex");\n    e.activateADA();\n  }, e.prototype.initArrowEvents = function () {\n    var i = this;\n    i.options.arrows === !0 && i.slideCount > i.options.slidesToShow && (i.$prevArrow.off("click.slick").on("click.slick", {\n      message: "previous"\n    }, i.changeSlide), i.$nextArrow.off("click.slick").on("click.slick", {\n      message: "next"\n    }, i.changeSlide), i.options.accessibility === !0 && (i.$prevArrow.on("keydown.slick", i.keyHandler), i.$nextArrow.on("keydown.slick", i.keyHandler)));\n  }, e.prototype.initDotEvents = function () {\n    var e = this;\n    e.options.dots === !0 && e.slideCount > e.options.slidesToShow && (i("li", e.$dots).on("click.slick", {\n      message: "index"\n    }, e.changeSlide), e.options.accessibility === !0 && e.$dots.on("keydown.slick", e.keyHandler)), e.options.dots === !0 && e.options.pauseOnDotsHover === !0 && e.slideCount > e.options.slidesToShow && i("li", e.$dots).on("mouseenter.slick", i.proxy(e.interrupt, e, !0)).on("mouseleave.slick", i.proxy(e.interrupt, e, !1));\n  }, e.prototype.initSlideEvents = function () {\n    var e = this;\n    e.options.pauseOnHover && (e.$list.on("mouseenter.slick", i.proxy(e.interrupt, e, !0)), e.$list.on("mouseleave.slick", i.proxy(e.interrupt, e, !1)));\n  }, e.prototype.initializeEvents = function () {\n    var e = this;\n    e.initArrowEvents(), e.initDotEvents(), e.initSlideEvents(), e.$list.on("touchstart.slick mousedown.slick", {\n      action: "start"\n    }, e.swipeHandler), e.$list.on("touchmove.slick mousemove.slick", {\n      action: "move"\n    }, e.swipeHandler), e.$list.on("touchend.slick mouseup.slick", {\n      action: "end"\n    }, e.swipeHandler), e.$list.on("touchcancel.slick mouseleave.slick", {\n      action: "end"\n    }, e.swipeHandler), e.$list.on("click.slick", e.clickHandler), i(document).on(e.visibilityChange, i.proxy(e.visibility, e)), e.options.accessibility === !0 && e.$list.on("keydown.slick", e.keyHandler), e.options.focusOnSelect === !0 && i(e.$slideTrack).children().on("click.slick", e.selectHandler), i(window).on("orientationchange.slick.slick-" + e.instanceUid, i.proxy(e.orientationChange, e)), i(window).on("resize.slick.slick-" + e.instanceUid, i.proxy(e.resize, e)), i("[draggable!=true]", e.$slideTrack).on("dragstart", e.preventDefault), i(window).on("load.slick.slick-" + e.instanceUid, e.setPosition), i(e.setPosition);\n  }, e.prototype.initUI = function () {\n    var i = this;\n    i.options.arrows === !0 && i.slideCount > i.options.slidesToShow && (i.$prevArrow.show(), i.$nextArrow.show()), i.options.dots === !0 && i.slideCount > i.options.slidesToShow && i.$dots.show();\n  }, e.prototype.keyHandler = function (i) {\n    var e = this;\n    i.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === i.keyCode && e.options.accessibility === !0 ? e.changeSlide({\n      data: {\n        message: e.options.rtl === !0 ? "next" : "previous"\n      }\n    }) : 39 === i.keyCode && e.options.accessibility === !0 && e.changeSlide({\n      data: {\n        message: e.options.rtl === !0 ? "previous" : "next"\n      }\n    }));\n  }, e.prototype.lazyLoad = function () {\n    function e(e) {\n      i("img[data-lazy]", e).each(function () {\n        var e = i(this),\n          t = i(this).attr("data-lazy"),\n          o = i(this).attr("data-srcset"),\n          s = i(this).attr("data-sizes") || r.$slider.attr("data-sizes"),\n          n = document.createElement("img");\n        n.onload = function () {\n          e.animate({\n            opacity: 0\n          }, 100, function () {\n            o && (e.attr("srcset", o), s && e.attr("sizes", s)), e.attr("src", t).animate({\n              opacity: 1\n            }, 200, function () {\n              e.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading");\n            }), r.$slider.trigger("lazyLoaded", [r, e, t]);\n          });\n        }, n.onerror = function () {\n          e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), r.$slider.trigger("lazyLoadError", [r, e, t]);\n        }, n.src = t;\n      });\n    }\n    var t,\n      o,\n      s,\n      n,\n      r = this;\n    if (r.options.centerMode === !0 ? r.options.infinite === !0 ? (s = r.currentSlide + (r.options.slidesToShow / 2 + 1), n = s + r.options.slidesToShow + 2) : (s = Math.max(0, r.currentSlide - (r.options.slidesToShow / 2 + 1)), n = 2 + (r.options.slidesToShow / 2 + 1) + r.currentSlide) : (s = r.options.infinite ? r.options.slidesToShow + r.currentSlide : r.currentSlide, n = Math.ceil(s + r.options.slidesToShow), r.options.fade === !0 && (s > 0 && s--, n <= r.slideCount && n++)), t = r.$slider.find(".slick-slide").slice(s, n), "anticipated" === r.options.lazyLoad) for (var l = s - 1, d = n, a = r.$slider.find(".slick-slide"), c = 0; c < r.options.slidesToScroll; c++) l < 0 && (l = r.slideCount - 1), t = t.add(a.eq(l)), t = t.add(a.eq(d)), l--, d++;\n    e(t), r.slideCount <= r.options.slidesToShow ? (o = r.$slider.find(".slick-slide"), e(o)) : r.currentSlide >= r.slideCount - r.options.slidesToShow ? (o = r.$slider.find(".slick-cloned").slice(0, r.options.slidesToShow), e(o)) : 0 === r.currentSlide && (o = r.$slider.find(".slick-cloned").slice(r.options.slidesToShow * -1), e(o));\n  }, e.prototype.loadSlider = function () {\n    var i = this;\n    i.setPosition(), i.$slideTrack.css({\n      opacity: 1\n    }), i.$slider.removeClass("slick-loading"), i.initUI(), "progressive" === i.options.lazyLoad && i.progressiveLazyLoad();\n  }, e.prototype.next = e.prototype.slickNext = function () {\n    var i = this;\n    i.changeSlide({\n      data: {\n        message: "next"\n      }\n    });\n  }, e.prototype.orientationChange = function () {\n    var i = this;\n    i.checkResponsive(), i.setPosition();\n  }, e.prototype.pause = e.prototype.slickPause = function () {\n    var i = this;\n    i.autoPlayClear(), i.paused = !0;\n  }, e.prototype.play = e.prototype.slickPlay = function () {\n    var i = this;\n    i.autoPlay(), i.options.autoplay = !0, i.paused = !1, i.focussed = !1, i.interrupted = !1;\n  }, e.prototype.postSlide = function (e) {\n    var t = this;\n    if (!t.unslicked && (t.$slider.trigger("afterChange", [t, e]), t.animating = !1, t.slideCount > t.options.slidesToShow && t.setPosition(), t.swipeLeft = null, t.options.autoplay && t.autoPlay(), t.options.accessibility === !0 && (t.initADA(), t.options.focusOnChange))) {\n      var o = i(t.$slides.get(t.currentSlide));\n      o.attr("tabindex", 0).focus();\n    }\n  }, e.prototype.prev = e.prototype.slickPrev = function () {\n    var i = this;\n    i.changeSlide({\n      data: {\n        message: "previous"\n      }\n    });\n  }, e.prototype.preventDefault = function (i) {\n    i.preventDefault();\n  }, e.prototype.progressiveLazyLoad = function (e) {\n    e = e || 1;\n    var t,\n      o,\n      s,\n      n,\n      r,\n      l = this,\n      d = i("img[data-lazy]", l.$slider);\n    d.length ? (t = d.first(), o = t.attr("data-lazy"), s = t.attr("data-srcset"), n = t.attr("data-sizes") || l.$slider.attr("data-sizes"), r = document.createElement("img"), r.onload = function () {\n      s && (t.attr("srcset", s), n && t.attr("sizes", n)), t.attr("src", o).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"), l.options.adaptiveHeight === !0 && l.setPosition(), l.$slider.trigger("lazyLoaded", [l, t, o]), l.progressiveLazyLoad();\n    }, r.onerror = function () {\n      e < 3 ? setTimeout(function () {\n        l.progressiveLazyLoad(e + 1);\n      }, 500) : (t.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), l.$slider.trigger("lazyLoadError", [l, t, o]), l.progressiveLazyLoad());\n    }, r.src = o) : l.$slider.trigger("allImagesLoaded", [l]);\n  }, e.prototype.refresh = function (e) {\n    var t,\n      o,\n      s = this;\n    o = s.slideCount - s.options.slidesToShow, !s.options.infinite && s.currentSlide > o && (s.currentSlide = o), s.slideCount <= s.options.slidesToShow && (s.currentSlide = 0), t = s.currentSlide, s.destroy(!0), i.extend(s, s.initials, {\n      currentSlide: t\n    }), s.init(), e || s.changeSlide({\n      data: {\n        message: "index",\n        index: t\n      }\n    }, !1);\n  }, e.prototype.registerBreakpoints = function () {\n    var e,\n      t,\n      o,\n      s = this,\n      n = s.options.responsive || null;\n    if ("array" === i.type(n) && n.length) {\n      s.respondTo = s.options.respondTo || "window";\n      for (e in n) if (o = s.breakpoints.length - 1, n.hasOwnProperty(e)) {\n        for (t = n[e].breakpoint; o >= 0;) s.breakpoints[o] && s.breakpoints[o] === t && s.breakpoints.splice(o, 1), o--;\n        s.breakpoints.push(t), s.breakpointSettings[t] = n[e].settings;\n      }\n      s.breakpoints.sort(function (i, e) {\n        return s.options.mobileFirst ? i - e : e - i;\n      });\n    }\n  }, e.prototype.reinit = function () {\n    var e = this;\n    e.$slides = e.$slideTrack.children(e.options.slide).addClass("slick-slide"), e.slideCount = e.$slides.length, e.currentSlide >= e.slideCount && 0 !== e.currentSlide && (e.currentSlide = e.currentSlide - e.options.slidesToScroll), e.slideCount <= e.options.slidesToShow && (e.currentSlide = 0), e.registerBreakpoints(), e.setProps(), e.setupInfinite(), e.buildArrows(), e.updateArrows(), e.initArrowEvents(), e.buildDots(), e.updateDots(), e.initDotEvents(), e.cleanUpSlideEvents(), e.initSlideEvents(), e.checkResponsive(!1, !0), e.options.focusOnSelect === !0 && i(e.$slideTrack).children().on("click.slick", e.selectHandler), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), e.setPosition(), e.focusHandler(), e.paused = !e.options.autoplay, e.autoPlay(), e.$slider.trigger("reInit", [e]);\n  }, e.prototype.resize = function () {\n    var e = this;\n    i(window).width() !== e.windowWidth && (clearTimeout(e.windowDelay), e.windowDelay = window.setTimeout(function () {\n      e.windowWidth = i(window).width(), e.checkResponsive(), e.unslicked || e.setPosition();\n    }, 50));\n  }, e.prototype.removeSlide = e.prototype.slickRemove = function (i, e, t) {\n    var o = this;\n    return "boolean" == typeof i ? (e = i, i = e === !0 ? 0 : o.slideCount - 1) : i = e === !0 ? --i : i, !(o.slideCount < 1 || i < 0 || i > o.slideCount - 1) && (o.unload(), t === !0 ? o.$slideTrack.children().remove() : o.$slideTrack.children(this.options.slide).eq(i).remove(), o.$slides = o.$slideTrack.children(this.options.slide), o.$slideTrack.children(this.options.slide).detach(), o.$slideTrack.append(o.$slides), o.$slidesCache = o.$slides, void o.reinit());\n  }, e.prototype.setCSS = function (i) {\n    var e,\n      t,\n      o = this,\n      s = {};\n    o.options.rtl === !0 && (i = -i), e = "left" == o.positionProp ? Math.ceil(i) + "px" : "0px", t = "top" == o.positionProp ? Math.ceil(i) + "px" : "0px", s[o.positionProp] = i, o.transformsEnabled === !1 ? o.$slideTrack.css(s) : (s = {}, o.cssTransitions === !1 ? (s[o.animType] = "translate(" + e + ", " + t + ")", o.$slideTrack.css(s)) : (s[o.animType] = "translate3d(" + e + ", " + t + ", 0px)", o.$slideTrack.css(s)));\n  }, e.prototype.setDimensions = function () {\n    var i = this;\n    i.options.vertical === !1 ? i.options.centerMode === !0 && i.$list.css({\n      padding: "0px " + i.options.centerPadding\n    }) : (i.$list.height(i.$slides.first().outerHeight(!0) * i.options.slidesToShow), i.options.centerMode === !0 && i.$list.css({\n      padding: i.options.centerPadding + " 0px"\n    })), i.listWidth = i.$list.width(), i.listHeight = i.$list.height(), i.options.vertical === !1 && i.options.variableWidth === !1 ? (i.slideWidth = Math.ceil(i.listWidth / i.options.slidesToShow), i.$slideTrack.width(Math.ceil(i.slideWidth * i.$slideTrack.children(".slick-slide").length))) : i.options.variableWidth === !0 ? i.$slideTrack.width(5e3 * i.slideCount) : (i.slideWidth = Math.ceil(i.listWidth), i.$slideTrack.height(Math.ceil(i.$slides.first().outerHeight(!0) * i.$slideTrack.children(".slick-slide").length)));\n    var e = i.$slides.first().outerWidth(!0) - i.$slides.first().width();\n    i.options.variableWidth === !1 && i.$slideTrack.children(".slick-slide").width(i.slideWidth - e);\n  }, e.prototype.setFade = function () {\n    var e,\n      t = this;\n    t.$slides.each(function (o, s) {\n      e = t.slideWidth * o * -1, t.options.rtl === !0 ? i(s).css({\n        position: "relative",\n        right: e,\n        top: 0,\n        zIndex: t.options.zIndex - 2,\n        opacity: 0\n      }) : i(s).css({\n        position: "relative",\n        left: e,\n        top: 0,\n        zIndex: t.options.zIndex - 2,\n        opacity: 0\n      });\n    }), t.$slides.eq(t.currentSlide).css({\n      zIndex: t.options.zIndex - 1,\n      opacity: 1\n    });\n  }, e.prototype.setHeight = function () {\n    var i = this;\n    if (1 === i.options.slidesToShow && i.options.adaptiveHeight === !0 && i.options.vertical === !1) {\n      var e = i.$slides.eq(i.currentSlide).outerHeight(!0);\n      i.$list.css("height", e);\n    }\n  }, e.prototype.setOption = e.prototype.slickSetOption = function () {\n    var e,\n      t,\n      o,\n      s,\n      n,\n      r = this,\n      l = !1;\n    if ("object" === i.type(arguments[0]) ? (o = arguments[0], l = arguments[1], n = "multiple") : "string" === i.type(arguments[0]) && (o = arguments[0], s = arguments[1], l = arguments[2], "responsive" === arguments[0] && "array" === i.type(arguments[1]) ? n = "responsive" : "undefined" != typeof arguments[1] && (n = "single")), "single" === n) r.options[o] = s;else if ("multiple" === n) i.each(o, function (i, e) {\n      r.options[i] = e;\n    });else if ("responsive" === n) for (t in s) if ("array" !== i.type(r.options.responsive)) r.options.responsive = [s[t]];else {\n      for (e = r.options.responsive.length - 1; e >= 0;) r.options.responsive[e].breakpoint === s[t].breakpoint && r.options.responsive.splice(e, 1), e--;\n      r.options.responsive.push(s[t]);\n    }\n    l && (r.unload(), r.reinit());\n  }, e.prototype.setPosition = function () {\n    var i = this;\n    i.setDimensions(), i.setHeight(), i.options.fade === !1 ? i.setCSS(i.getLeft(i.currentSlide)) : i.setFade(), i.$slider.trigger("setPosition", [i]);\n  }, e.prototype.setProps = function () {\n    var i = this,\n      e = document.body.style;\n    i.positionProp = i.options.vertical === !0 ? "top" : "left", "top" === i.positionProp ? i.$slider.addClass("slick-vertical") : i.$slider.removeClass("slick-vertical"), void 0 === e.WebkitTransition && void 0 === e.MozTransition && void 0 === e.msTransition || i.options.useCSS === !0 && (i.cssTransitions = !0), i.options.fade && ("number" == typeof i.options.zIndex ? i.options.zIndex < 3 && (i.options.zIndex = 3) : i.options.zIndex = i.defaults.zIndex), void 0 !== e.OTransform && (i.animType = "OTransform", i.transformType = "-o-transform", i.transitionType = "OTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)), void 0 !== e.MozTransform && (i.animType = "MozTransform", i.transformType = "-moz-transform", i.transitionType = "MozTransition", void 0 === e.perspectiveProperty && void 0 === e.MozPerspective && (i.animType = !1)), void 0 !== e.webkitTransform && (i.animType = "webkitTransform", i.transformType = "-webkit-transform", i.transitionType = "webkitTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)), void 0 !== e.msTransform && (i.animType = "msTransform", i.transformType = "-ms-transform", i.transitionType = "msTransition", void 0 === e.msTransform && (i.animType = !1)), void 0 !== e.transform && i.animType !== !1 && (i.animType = "transform", i.transformType = "transform", i.transitionType = "transition"), i.transformsEnabled = i.options.useTransform && null !== i.animType && i.animType !== !1;\n  }, e.prototype.setSlideClasses = function (i) {\n    var e,\n      t,\n      o,\n      s,\n      n = this;\n    if (t = n.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), n.$slides.eq(i).addClass("slick-current"), n.options.centerMode === !0) {\n      var r = n.options.slidesToShow % 2 === 0 ? 1 : 0;\n      e = Math.floor(n.options.slidesToShow / 2), n.options.infinite === !0 && (i >= e && i <= n.slideCount - 1 - e ? n.$slides.slice(i - e + r, i + e + 1).addClass("slick-active").attr("aria-hidden", "false") : (o = n.options.slidesToShow + i, t.slice(o - e + 1 + r, o + e + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === i ? t.eq(t.length - 1 - n.options.slidesToShow).addClass("slick-center") : i === n.slideCount - 1 && t.eq(n.options.slidesToShow).addClass("slick-center")), n.$slides.eq(i).addClass("slick-center");\n    } else i >= 0 && i <= n.slideCount - n.options.slidesToShow ? n.$slides.slice(i, i + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : t.length <= n.options.slidesToShow ? t.addClass("slick-active").attr("aria-hidden", "false") : (s = n.slideCount % n.options.slidesToShow, o = n.options.infinite === !0 ? n.options.slidesToShow + i : i, n.options.slidesToShow == n.options.slidesToScroll && n.slideCount - i < n.options.slidesToShow ? t.slice(o - (n.options.slidesToShow - s), o + s).addClass("slick-active").attr("aria-hidden", "false") : t.slice(o, o + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));\n    "ondemand" !== n.options.lazyLoad && "anticipated" !== n.options.lazyLoad || n.lazyLoad();\n  }, e.prototype.setupInfinite = function () {\n    var e,\n      t,\n      o,\n      s = this;\n    if (s.options.fade === !0 && (s.options.centerMode = !1), s.options.infinite === !0 && s.options.fade === !1 && (t = null, s.slideCount > s.options.slidesToShow)) {\n      for (o = s.options.centerMode === !0 ? s.options.slidesToShow + 1 : s.options.slidesToShow, e = s.slideCount; e > s.slideCount - o; e -= 1) t = e - 1, i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t - s.slideCount).prependTo(s.$slideTrack).addClass("slick-cloned");\n      for (e = 0; e < o + s.slideCount; e += 1) t = e, i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t + s.slideCount).appendTo(s.$slideTrack).addClass("slick-cloned");\n      s.$slideTrack.find(".slick-cloned").find("[id]").each(function () {\n        i(this).attr("id", "");\n      });\n    }\n  }, e.prototype.interrupt = function (i) {\n    var e = this;\n    i || e.autoPlay(), e.interrupted = i;\n  }, e.prototype.selectHandler = function (e) {\n    var t = this,\n      o = i(e.target).is(".slick-slide") ? i(e.target) : i(e.target).parents(".slick-slide"),\n      s = parseInt(o.attr("data-slick-index"));\n    return s || (s = 0), t.slideCount <= t.options.slidesToShow ? void t.slideHandler(s, !1, !0) : void t.slideHandler(s);\n  }, e.prototype.slideHandler = function (i, e, t) {\n    var o,\n      s,\n      n,\n      r,\n      l,\n      d = null,\n      a = this;\n    if (e = e || !1, !(a.animating === !0 && a.options.waitForAnimate === !0 || a.options.fade === !0 && a.currentSlide === i)) return e === !1 && a.asNavFor(i), o = i, d = a.getLeft(o), r = a.getLeft(a.currentSlide), a.currentLeft = null === a.swipeLeft ? r : a.swipeLeft, a.options.infinite === !1 && a.options.centerMode === !1 && (i < 0 || i > a.getDotCount() * a.options.slidesToScroll) ? void (a.options.fade === !1 && (o = a.currentSlide, t !== !0 && a.slideCount > a.options.slidesToShow ? a.animateSlide(r, function () {\n      a.postSlide(o);\n    }) : a.postSlide(o))) : a.options.infinite === !1 && a.options.centerMode === !0 && (i < 0 || i > a.slideCount - a.options.slidesToScroll) ? void (a.options.fade === !1 && (o = a.currentSlide, t !== !0 && a.slideCount > a.options.slidesToShow ? a.animateSlide(r, function () {\n      a.postSlide(o);\n    }) : a.postSlide(o))) : (a.options.autoplay && clearInterval(a.autoPlayTimer), s = o < 0 ? a.slideCount % a.options.slidesToScroll !== 0 ? a.slideCount - a.slideCount % a.options.slidesToScroll : a.slideCount + o : o >= a.slideCount ? a.slideCount % a.options.slidesToScroll !== 0 ? 0 : o - a.slideCount : o, a.animating = !0, a.$slider.trigger("beforeChange", [a, a.currentSlide, s]), n = a.currentSlide, a.currentSlide = s, a.setSlideClasses(a.currentSlide), a.options.asNavFor && (l = a.getNavTarget(), l = l.slick("getSlick"), l.slideCount <= l.options.slidesToShow && l.setSlideClasses(a.currentSlide)), a.updateDots(), a.updateArrows(), a.options.fade === !0 ? (t !== !0 ? (a.fadeSlideOut(n), a.fadeSlide(s, function () {\n      a.postSlide(s);\n    })) : a.postSlide(s), void a.animateHeight()) : void (t !== !0 && a.slideCount > a.options.slidesToShow ? a.animateSlide(d, function () {\n      a.postSlide(s);\n    }) : a.postSlide(s)));\n  }, e.prototype.startLoad = function () {\n    var i = this;\n    i.options.arrows === !0 && i.slideCount > i.options.slidesToShow && (i.$prevArrow.hide(), i.$nextArrow.hide()), i.options.dots === !0 && i.slideCount > i.options.slidesToShow && i.$dots.hide(), i.$slider.addClass("slick-loading");\n  }, e.prototype.swipeDirection = function () {\n    var i,\n      e,\n      t,\n      o,\n      s = this;\n    return i = s.touchObject.startX - s.touchObject.curX, e = s.touchObject.startY - s.touchObject.curY, t = Math.atan2(e, i), o = Math.round(180 * t / Math.PI), o < 0 && (o = 360 - Math.abs(o)), o <= 45 && o >= 0 ? s.options.rtl === !1 ? "left" : "right" : o <= 360 && o >= 315 ? s.options.rtl === !1 ? "left" : "right" : o >= 135 && o <= 225 ? s.options.rtl === !1 ? "right" : "left" : s.options.verticalSwiping === !0 ? o >= 35 && o <= 135 ? "down" : "up" : "vertical";\n  }, e.prototype.swipeEnd = function (i) {\n    var e,\n      t,\n      o = this;\n    if (o.dragging = !1, o.swiping = !1, o.scrolling) return o.scrolling = !1, !1;\n    if (o.interrupted = !1, o.shouldClick = !(o.touchObject.swipeLength > 10), void 0 === o.touchObject.curX) return !1;\n    if (o.touchObject.edgeHit === !0 && o.$slider.trigger("edge", [o, o.swipeDirection()]), o.touchObject.swipeLength >= o.touchObject.minSwipe) {\n      switch (t = o.swipeDirection()) {\n        case "left":\n        case "down":\n          e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide + o.getSlideCount()) : o.currentSlide + o.getSlideCount(), o.currentDirection = 0;\n          break;\n        case "right":\n        case "up":\n          e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide - o.getSlideCount()) : o.currentSlide - o.getSlideCount(), o.currentDirection = 1;\n      }\n      "vertical" != t && (o.slideHandler(e), o.touchObject = {}, o.$slider.trigger("swipe", [o, t]));\n    } else o.touchObject.startX !== o.touchObject.curX && (o.slideHandler(o.currentSlide), o.touchObject = {});\n  }, e.prototype.swipeHandler = function (i) {\n    var e = this;\n    if (!(e.options.swipe === !1 || "ontouchend" in document && e.options.swipe === !1 || e.options.draggable === !1 && i.type.indexOf("mouse") !== -1)) switch (e.touchObject.fingerCount = i.originalEvent && void 0 !== i.originalEvent.touches ? i.originalEvent.touches.length : 1, e.touchObject.minSwipe = e.listWidth / e.options.touchThreshold, e.options.verticalSwiping === !0 && (e.touchObject.minSwipe = e.listHeight / e.options.touchThreshold), i.data.action) {\n      case "start":\n        e.swipeStart(i);\n        break;\n      case "move":\n        e.swipeMove(i);\n        break;\n      case "end":\n        e.swipeEnd(i);\n    }\n  }, e.prototype.swipeMove = function (i) {\n    var e,\n      t,\n      o,\n      s,\n      n,\n      r,\n      l = this;\n    return n = void 0 !== i.originalEvent ? i.originalEvent.touches : null, !(!l.dragging || l.scrolling || n && 1 !== n.length) && (e = l.getLeft(l.currentSlide), l.touchObject.curX = void 0 !== n ? n[0].pageX : i.clientX, l.touchObject.curY = void 0 !== n ? n[0].pageY : i.clientY, l.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(l.touchObject.curX - l.touchObject.startX, 2))), r = Math.round(Math.sqrt(Math.pow(l.touchObject.curY - l.touchObject.startY, 2))), !l.options.verticalSwiping && !l.swiping && r > 4 ? (l.scrolling = !0, !1) : (l.options.verticalSwiping === !0 && (l.touchObject.swipeLength = r), t = l.swipeDirection(), void 0 !== i.originalEvent && l.touchObject.swipeLength > 4 && (l.swiping = !0, i.preventDefault()), s = (l.options.rtl === !1 ? 1 : -1) * (l.touchObject.curX > l.touchObject.startX ? 1 : -1), l.options.verticalSwiping === !0 && (s = l.touchObject.curY > l.touchObject.startY ? 1 : -1), o = l.touchObject.swipeLength, l.touchObject.edgeHit = !1, l.options.infinite === !1 && (0 === l.currentSlide && "right" === t || l.currentSlide >= l.getDotCount() && "left" === t) && (o = l.touchObject.swipeLength * l.options.edgeFriction, l.touchObject.edgeHit = !0), l.options.vertical === !1 ? l.swipeLeft = e + o * s : l.swipeLeft = e + o * (l.$list.height() / l.listWidth) * s, l.options.verticalSwiping === !0 && (l.swipeLeft = e + o * s), l.options.fade !== !0 && l.options.touchMove !== !1 && (l.animating === !0 ? (l.swipeLeft = null, !1) : void l.setCSS(l.swipeLeft))));\n  }, e.prototype.swipeStart = function (i) {\n    var e,\n      t = this;\n    return t.interrupted = !0, 1 !== t.touchObject.fingerCount || t.slideCount <= t.options.slidesToShow ? (t.touchObject = {}, !1) : (void 0 !== i.originalEvent && void 0 !== i.originalEvent.touches && (e = i.originalEvent.touches[0]), t.touchObject.startX = t.touchObject.curX = void 0 !== e ? e.pageX : i.clientX, t.touchObject.startY = t.touchObject.curY = void 0 !== e ? e.pageY : i.clientY, void (t.dragging = !0));\n  }, e.prototype.unfilterSlides = e.prototype.slickUnfilter = function () {\n    var i = this;\n    null !== i.$slidesCache && (i.unload(), i.$slideTrack.children(this.options.slide).detach(), i.$slidesCache.appendTo(i.$slideTrack), i.reinit());\n  }, e.prototype.unload = function () {\n    var e = this;\n    i(".slick-cloned", e.$slider).remove(), e.$dots && e.$dots.remove(), e.$prevArrow && e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.remove(), e.$nextArrow && e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.remove(), e.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "");\n  }, e.prototype.unslick = function (i) {\n    var e = this;\n    e.$slider.trigger("unslick", [e, i]), e.destroy();\n  }, e.prototype.updateArrows = function () {\n    var i,\n      e = this;\n    i = Math.floor(e.options.slidesToShow / 2), e.options.arrows === !0 && e.slideCount > e.options.slidesToShow && !e.options.infinite && (e.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), e.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === e.currentSlide ? (e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), e.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : e.currentSlide >= e.slideCount - e.options.slidesToShow && e.options.centerMode === !1 ? (e.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), e.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : e.currentSlide >= e.slideCount - 1 && e.options.centerMode === !0 && (e.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), e.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")));\n  }, e.prototype.updateDots = function () {\n    var i = this;\n    null !== i.$dots && (i.$dots.find("li").removeClass("slick-active").end(), i.$dots.find("li").eq(Math.floor(i.currentSlide / i.options.slidesToScroll)).addClass("slick-active"));\n  }, e.prototype.visibility = function () {\n    var i = this;\n    i.options.autoplay && (document[i.hidden] ? i.interrupted = !0 : i.interrupted = !1);\n  }, i.fn.slick = function () {\n    var i,\n      t,\n      o = this,\n      s = arguments[0],\n      n = Array.prototype.slice.call(arguments, 1),\n      r = o.length;\n    for (i = 0; i < r; i++) if ("object" == _typeof(s) || "undefined" == typeof s ? o[i].slick = new e(o[i], s) : t = o[i].slick[s].apply(o[i].slick, n), "undefined" != typeof t) return t;\n    return o;\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVzdGFyb2NrZXQtZGV2LXRvb2xzLy4vanMvbGliL3NsaWNrLm1pbi5qcz84NDU0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbi8qXG4gICAgIF8gXyAgICAgIF8gICAgICAgX1xuIF9fX3wgKF8pIF9fX3wgfCBfXyAgKF8pX19fXG4vIF9ffCB8IHwvIF9ffCB8LyAvICB8IC8gX198XG5cXF9fIFxcIHwgfCAoX198ICAgPCBfIHwgXFxfXyBcXFxufF9fXy9ffF98XFxfX198X3xcXF8oXykvIHxfX18vXG4gICAgICAgICAgICAgICAgICAgfF9fL1xuXG4gVmVyc2lvbjogMS45LjBcbiAgQXV0aG9yOiBLZW4gV2hlZWxlclxuIFdlYnNpdGU6IGh0dHA6Ly9rZW53aGVlbGVyLmdpdGh1Yi5pb1xuICAgIERvY3M6IGh0dHA6Ly9rZW53aGVlbGVyLmdpdGh1Yi5pby9zbGlja1xuICAgIFJlcG86IGh0dHA6Ly9naXRodWIuY29tL2tlbndoZWVsZXIvc2xpY2tcbiAgSXNzdWVzOiBodHRwOi8vZ2l0aHViLmNvbS9rZW53aGVlbGVyL3NsaWNrL2lzc3Vlc1xuXG4gKi9cbihmdW5jdGlvbiAoaSkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtcImpxdWVyeVwiXSwgaSkgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBleHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgPSBpKHJlcXVpcmUoXCJqcXVlcnlcIikpIDogaShqUXVlcnkpO1xufSkoZnVuY3Rpb24gKGkpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGUgPSB3aW5kb3cuU2xpY2sgfHwge307XG4gIGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZShlLCBvKSB7XG4gICAgICB2YXIgcyxcbiAgICAgICAgbiA9IHRoaXM7XG4gICAgICBuLmRlZmF1bHRzID0ge1xuICAgICAgICBhY2Nlc3NpYmlsaXR5OiAhMCxcbiAgICAgICAgYWRhcHRpdmVIZWlnaHQ6ICExLFxuICAgICAgICBhcHBlbmRBcnJvd3M6IGkoZSksXG4gICAgICAgIGFwcGVuZERvdHM6IGkoZSksXG4gICAgICAgIGFycm93czogITAsXG4gICAgICAgIGFzTmF2Rm9yOiBudWxsLFxuICAgICAgICBwcmV2QXJyb3c6ICc8YnV0dG9uIGNsYXNzPVwic2xpY2stcHJldlwiIGFyaWEtbGFiZWw9XCJQcmV2aW91c1wiIHR5cGU9XCJidXR0b25cIj5QcmV2aW91czwvYnV0dG9uPicsXG4gICAgICAgIG5leHRBcnJvdzogJzxidXR0b24gY2xhc3M9XCJzbGljay1uZXh0XCIgYXJpYS1sYWJlbD1cIk5leHRcIiB0eXBlPVwiYnV0dG9uXCI+TmV4dDwvYnV0dG9uPicsXG4gICAgICAgIGF1dG9wbGF5OiAhMSxcbiAgICAgICAgYXV0b3BsYXlTcGVlZDogM2UzLFxuICAgICAgICBjZW50ZXJNb2RlOiAhMSxcbiAgICAgICAgY2VudGVyUGFkZGluZzogXCI1MHB4XCIsXG4gICAgICAgIGNzc0Vhc2U6IFwiZWFzZVwiLFxuICAgICAgICBjdXN0b21QYWdpbmc6IGZ1bmN0aW9uIGN1c3RvbVBhZ2luZyhlLCB0KSB7XG4gICAgICAgICAgcmV0dXJuIGkoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIC8+JykudGV4dCh0ICsgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvdHM6ICExLFxuICAgICAgICBkb3RzQ2xhc3M6IFwic2xpY2stZG90c1wiLFxuICAgICAgICBkcmFnZ2FibGU6ICEwLFxuICAgICAgICBlYXNpbmc6IFwibGluZWFyXCIsXG4gICAgICAgIGVkZ2VGcmljdGlvbjogLjM1LFxuICAgICAgICBmYWRlOiAhMSxcbiAgICAgICAgZm9jdXNPblNlbGVjdDogITEsXG4gICAgICAgIGZvY3VzT25DaGFuZ2U6ICExLFxuICAgICAgICBpbmZpbml0ZTogITAsXG4gICAgICAgIGluaXRpYWxTbGlkZTogMCxcbiAgICAgICAgbGF6eUxvYWQ6IFwib25kZW1hbmRcIixcbiAgICAgICAgbW9iaWxlRmlyc3Q6ICExLFxuICAgICAgICBwYXVzZU9uSG92ZXI6ICEwLFxuICAgICAgICBwYXVzZU9uRm9jdXM6ICEwLFxuICAgICAgICBwYXVzZU9uRG90c0hvdmVyOiAhMSxcbiAgICAgICAgcmVzcG9uZFRvOiBcIndpbmRvd1wiLFxuICAgICAgICByZXNwb25zaXZlOiBudWxsLFxuICAgICAgICByb3dzOiAxLFxuICAgICAgICBydGw6ICExLFxuICAgICAgICBzbGlkZTogXCJcIixcbiAgICAgICAgc2xpZGVzUGVyUm93OiAxLFxuICAgICAgICBzbGlkZXNUb1Nob3c6IDEsXG4gICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgICAgICBzcGVlZDogNTAwLFxuICAgICAgICBzd2lwZTogITAsXG4gICAgICAgIHN3aXBlVG9TbGlkZTogITEsXG4gICAgICAgIHRvdWNoTW92ZTogITAsXG4gICAgICAgIHRvdWNoVGhyZXNob2xkOiA1LFxuICAgICAgICB1c2VDU1M6ICEwLFxuICAgICAgICB1c2VUcmFuc2Zvcm06ICEwLFxuICAgICAgICB2YXJpYWJsZVdpZHRoOiAhMSxcbiAgICAgICAgdmVydGljYWw6ICExLFxuICAgICAgICB2ZXJ0aWNhbFN3aXBpbmc6ICExLFxuICAgICAgICB3YWl0Rm9yQW5pbWF0ZTogITAsXG4gICAgICAgIHpJbmRleDogMWUzXG4gICAgICB9LCBuLmluaXRpYWxzID0ge1xuICAgICAgICBhbmltYXRpbmc6ICExLFxuICAgICAgICBkcmFnZ2luZzogITEsXG4gICAgICAgIGF1dG9QbGF5VGltZXI6IG51bGwsXG4gICAgICAgIGN1cnJlbnREaXJlY3Rpb246IDAsXG4gICAgICAgIGN1cnJlbnRMZWZ0OiBudWxsLFxuICAgICAgICBjdXJyZW50U2xpZGU6IDAsXG4gICAgICAgIGRpcmVjdGlvbjogMSxcbiAgICAgICAgJGRvdHM6IG51bGwsXG4gICAgICAgIGxpc3RXaWR0aDogbnVsbCxcbiAgICAgICAgbGlzdEhlaWdodDogbnVsbCxcbiAgICAgICAgbG9hZEluZGV4OiAwLFxuICAgICAgICAkbmV4dEFycm93OiBudWxsLFxuICAgICAgICAkcHJldkFycm93OiBudWxsLFxuICAgICAgICBzY3JvbGxpbmc6ICExLFxuICAgICAgICBzbGlkZUNvdW50OiBudWxsLFxuICAgICAgICBzbGlkZVdpZHRoOiBudWxsLFxuICAgICAgICAkc2xpZGVUcmFjazogbnVsbCxcbiAgICAgICAgJHNsaWRlczogbnVsbCxcbiAgICAgICAgc2xpZGluZzogITEsXG4gICAgICAgIHNsaWRlT2Zmc2V0OiAwLFxuICAgICAgICBzd2lwZUxlZnQ6IG51bGwsXG4gICAgICAgIHN3aXBpbmc6ICExLFxuICAgICAgICAkbGlzdDogbnVsbCxcbiAgICAgICAgdG91Y2hPYmplY3Q6IHt9LFxuICAgICAgICB0cmFuc2Zvcm1zRW5hYmxlZDogITEsXG4gICAgICAgIHVuc2xpY2tlZDogITFcbiAgICAgIH0sIGkuZXh0ZW5kKG4sIG4uaW5pdGlhbHMpLCBuLmFjdGl2ZUJyZWFrcG9pbnQgPSBudWxsLCBuLmFuaW1UeXBlID0gbnVsbCwgbi5hbmltUHJvcCA9IG51bGwsIG4uYnJlYWtwb2ludHMgPSBbXSwgbi5icmVha3BvaW50U2V0dGluZ3MgPSBbXSwgbi5jc3NUcmFuc2l0aW9ucyA9ICExLCBuLmZvY3Vzc2VkID0gITEsIG4uaW50ZXJydXB0ZWQgPSAhMSwgbi5oaWRkZW4gPSBcImhpZGRlblwiLCBuLnBhdXNlZCA9ICEwLCBuLnBvc2l0aW9uUHJvcCA9IG51bGwsIG4ucmVzcG9uZFRvID0gbnVsbCwgbi5yb3dDb3VudCA9IDEsIG4uc2hvdWxkQ2xpY2sgPSAhMCwgbi4kc2xpZGVyID0gaShlKSwgbi4kc2xpZGVzQ2FjaGUgPSBudWxsLCBuLnRyYW5zZm9ybVR5cGUgPSBudWxsLCBuLnRyYW5zaXRpb25UeXBlID0gbnVsbCwgbi52aXNpYmlsaXR5Q2hhbmdlID0gXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG4ud2luZG93V2lkdGggPSAwLCBuLndpbmRvd1RpbWVyID0gbnVsbCwgcyA9IGkoZSkuZGF0YShcInNsaWNrXCIpIHx8IHt9LCBuLm9wdGlvbnMgPSBpLmV4dGVuZCh7fSwgbi5kZWZhdWx0cywgbywgcyksIG4uY3VycmVudFNsaWRlID0gbi5vcHRpb25zLmluaXRpYWxTbGlkZSwgbi5vcmlnaW5hbFNldHRpbmdzID0gbi5vcHRpb25zLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudC5tb3pIaWRkZW4gPyAobi5oaWRkZW4gPSBcIm1vekhpZGRlblwiLCBuLnZpc2liaWxpdHlDaGFuZ2UgPSBcIm1venZpc2liaWxpdHljaGFuZ2VcIikgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4gJiYgKG4uaGlkZGVuID0gXCJ3ZWJraXRIaWRkZW5cIiwgbi52aXNpYmlsaXR5Q2hhbmdlID0gXCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCIpLCBuLmF1dG9QbGF5ID0gaS5wcm94eShuLmF1dG9QbGF5LCBuKSwgbi5hdXRvUGxheUNsZWFyID0gaS5wcm94eShuLmF1dG9QbGF5Q2xlYXIsIG4pLCBuLmF1dG9QbGF5SXRlcmF0b3IgPSBpLnByb3h5KG4uYXV0b1BsYXlJdGVyYXRvciwgbiksIG4uY2hhbmdlU2xpZGUgPSBpLnByb3h5KG4uY2hhbmdlU2xpZGUsIG4pLCBuLmNsaWNrSGFuZGxlciA9IGkucHJveHkobi5jbGlja0hhbmRsZXIsIG4pLCBuLnNlbGVjdEhhbmRsZXIgPSBpLnByb3h5KG4uc2VsZWN0SGFuZGxlciwgbiksIG4uc2V0UG9zaXRpb24gPSBpLnByb3h5KG4uc2V0UG9zaXRpb24sIG4pLCBuLnN3aXBlSGFuZGxlciA9IGkucHJveHkobi5zd2lwZUhhbmRsZXIsIG4pLCBuLmRyYWdIYW5kbGVyID0gaS5wcm94eShuLmRyYWdIYW5kbGVyLCBuKSwgbi5rZXlIYW5kbGVyID0gaS5wcm94eShuLmtleUhhbmRsZXIsIG4pLCBuLmluc3RhbmNlVWlkID0gdCsrLCBuLmh0bWxFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qKSQvLCBuLnJlZ2lzdGVyQnJlYWtwb2ludHMoKSwgbi5pbml0KCEwKTtcbiAgICB9XG4gICAgdmFyIHQgPSAwO1xuICAgIHJldHVybiBlO1xuICB9KCksIGUucHJvdG90eXBlLmFjdGl2YXRlQURBID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcztcbiAgICBpLiRzbGlkZVRyYWNrLmZpbmQoXCIuc2xpY2stYWN0aXZlXCIpLmF0dHIoe1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCJcbiAgICB9KS5maW5kKFwiYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0XCIpLmF0dHIoe1xuICAgICAgdGFiaW5kZXg6IFwiMFwiXG4gICAgfSk7XG4gIH0sIGUucHJvdG90eXBlLmFkZFNsaWRlID0gZS5wcm90b3R5cGUuc2xpY2tBZGQgPSBmdW5jdGlvbiAoZSwgdCwgbykge1xuICAgIHZhciBzID0gdGhpcztcbiAgICBpZiAoXCJib29sZWFuXCIgPT0gdHlwZW9mIHQpIG8gPSB0LCB0ID0gbnVsbDtlbHNlIGlmICh0IDwgMCB8fCB0ID49IHMuc2xpZGVDb3VudCkgcmV0dXJuICExO1xuICAgIHMudW5sb2FkKCksIFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgPyAwID09PSB0ICYmIDAgPT09IHMuJHNsaWRlcy5sZW5ndGggPyBpKGUpLmFwcGVuZFRvKHMuJHNsaWRlVHJhY2spIDogbyA/IGkoZSkuaW5zZXJ0QmVmb3JlKHMuJHNsaWRlcy5lcSh0KSkgOiBpKGUpLmluc2VydEFmdGVyKHMuJHNsaWRlcy5lcSh0KSkgOiBvID09PSAhMCA/IGkoZSkucHJlcGVuZFRvKHMuJHNsaWRlVHJhY2spIDogaShlKS5hcHBlbmRUbyhzLiRzbGlkZVRyYWNrKSwgcy4kc2xpZGVzID0gcy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLCBzLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksIHMuJHNsaWRlVHJhY2suYXBwZW5kKHMuJHNsaWRlcyksIHMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICBpKHQpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIsIGUpO1xuICAgIH0pLCBzLiRzbGlkZXNDYWNoZSA9IHMuJHNsaWRlcywgcy5yZWluaXQoKTtcbiAgfSwgZS5wcm90b3R5cGUuYW5pbWF0ZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXM7XG4gICAgaWYgKDEgPT09IGkub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiYgaS5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0ID09PSAhMCAmJiBpLm9wdGlvbnMudmVydGljYWwgPT09ICExKSB7XG4gICAgICB2YXIgZSA9IGkuJHNsaWRlcy5lcShpLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQoITApO1xuICAgICAgaS4kbGlzdC5hbmltYXRlKHtcbiAgICAgICAgaGVpZ2h0OiBlXG4gICAgICB9LCBpLm9wdGlvbnMuc3BlZWQpO1xuICAgIH1cbiAgfSwgZS5wcm90b3R5cGUuYW5pbWF0ZVNsaWRlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICB2YXIgbyA9IHt9LFxuICAgICAgcyA9IHRoaXM7XG4gICAgcy5hbmltYXRlSGVpZ2h0KCksIHMub3B0aW9ucy5ydGwgPT09ICEwICYmIHMub3B0aW9ucy52ZXJ0aWNhbCA9PT0gITEgJiYgKGUgPSAtZSksIHMudHJhbnNmb3Jtc0VuYWJsZWQgPT09ICExID8gcy5vcHRpb25zLnZlcnRpY2FsID09PSAhMSA/IHMuJHNsaWRlVHJhY2suYW5pbWF0ZSh7XG4gICAgICBsZWZ0OiBlXG4gICAgfSwgcy5vcHRpb25zLnNwZWVkLCBzLm9wdGlvbnMuZWFzaW5nLCB0KSA6IHMuJHNsaWRlVHJhY2suYW5pbWF0ZSh7XG4gICAgICB0b3A6IGVcbiAgICB9LCBzLm9wdGlvbnMuc3BlZWQsIHMub3B0aW9ucy5lYXNpbmcsIHQpIDogcy5jc3NUcmFuc2l0aW9ucyA9PT0gITEgPyAocy5vcHRpb25zLnJ0bCA9PT0gITAgJiYgKHMuY3VycmVudExlZnQgPSAtcy5jdXJyZW50TGVmdCksIGkoe1xuICAgICAgYW5pbVN0YXJ0OiBzLmN1cnJlbnRMZWZ0XG4gICAgfSkuYW5pbWF0ZSh7XG4gICAgICBhbmltU3RhcnQ6IGVcbiAgICB9LCB7XG4gICAgICBkdXJhdGlvbjogcy5vcHRpb25zLnNwZWVkLFxuICAgICAgZWFzaW5nOiBzLm9wdGlvbnMuZWFzaW5nLFxuICAgICAgc3RlcDogZnVuY3Rpb24gc3RlcChpKSB7XG4gICAgICAgIGkgPSBNYXRoLmNlaWwoaSksIHMub3B0aW9ucy52ZXJ0aWNhbCA9PT0gITEgPyAob1tzLmFuaW1UeXBlXSA9IFwidHJhbnNsYXRlKFwiICsgaSArIFwicHgsIDBweClcIiwgcy4kc2xpZGVUcmFjay5jc3MobykpIDogKG9bcy5hbmltVHlwZV0gPSBcInRyYW5zbGF0ZSgwcHgsXCIgKyBpICsgXCJweClcIiwgcy4kc2xpZGVUcmFjay5jc3MobykpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgdCAmJiB0LmNhbGwoKTtcbiAgICAgIH1cbiAgICB9KSkgOiAocy5hcHBseVRyYW5zaXRpb24oKSwgZSA9IE1hdGguY2VpbChlKSwgcy5vcHRpb25zLnZlcnRpY2FsID09PSAhMSA/IG9bcy5hbmltVHlwZV0gPSBcInRyYW5zbGF0ZTNkKFwiICsgZSArIFwicHgsIDBweCwgMHB4KVwiIDogb1tzLmFuaW1UeXBlXSA9IFwidHJhbnNsYXRlM2QoMHB4LFwiICsgZSArIFwicHgsIDBweClcIiwgcy4kc2xpZGVUcmFjay5jc3MobyksIHQgJiYgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzLmRpc2FibGVUcmFuc2l0aW9uKCksIHQuY2FsbCgpO1xuICAgIH0sIHMub3B0aW9ucy5zcGVlZCkpO1xuICB9LCBlLnByb3RvdHlwZS5nZXROYXZUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSB0aGlzLFxuICAgICAgdCA9IGUub3B0aW9ucy5hc05hdkZvcjtcbiAgICByZXR1cm4gdCAmJiBudWxsICE9PSB0ICYmICh0ID0gaSh0KS5ub3QoZS4kc2xpZGVyKSksIHQ7XG4gIH0sIGUucHJvdG90eXBlLmFzTmF2Rm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdCA9IHRoaXMsXG4gICAgICBvID0gdC5nZXROYXZUYXJnZXQoKTtcbiAgICBudWxsICE9PSBvICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZihvKSAmJiBvLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBpKHRoaXMpLnNsaWNrKFwiZ2V0U2xpY2tcIik7XG4gICAgICB0LnVuc2xpY2tlZCB8fCB0LnNsaWRlSGFuZGxlcihlLCAhMCk7XG4gICAgfSk7XG4gIH0sIGUucHJvdG90eXBlLmFwcGx5VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIGUgPSB0aGlzLFxuICAgICAgdCA9IHt9O1xuICAgIGUub3B0aW9ucy5mYWRlID09PSAhMSA/IHRbZS50cmFuc2l0aW9uVHlwZV0gPSBlLnRyYW5zZm9ybVR5cGUgKyBcIiBcIiArIGUub3B0aW9ucy5zcGVlZCArIFwibXMgXCIgKyBlLm9wdGlvbnMuY3NzRWFzZSA6IHRbZS50cmFuc2l0aW9uVHlwZV0gPSBcIm9wYWNpdHkgXCIgKyBlLm9wdGlvbnMuc3BlZWQgKyBcIm1zIFwiICsgZS5vcHRpb25zLmNzc0Vhc2UsIGUub3B0aW9ucy5mYWRlID09PSAhMSA/IGUuJHNsaWRlVHJhY2suY3NzKHQpIDogZS4kc2xpZGVzLmVxKGkpLmNzcyh0KTtcbiAgfSwgZS5wcm90b3R5cGUuYXV0b1BsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzO1xuICAgIGkuYXV0b1BsYXlDbGVhcigpLCBpLnNsaWRlQ291bnQgPiBpLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIChpLmF1dG9QbGF5VGltZXIgPSBzZXRJbnRlcnZhbChpLmF1dG9QbGF5SXRlcmF0b3IsIGkub3B0aW9ucy5hdXRvcGxheVNwZWVkKSk7XG4gIH0sIGUucHJvdG90eXBlLmF1dG9QbGF5Q2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzO1xuICAgIGkuYXV0b1BsYXlUaW1lciAmJiBjbGVhckludGVydmFsKGkuYXV0b1BsYXlUaW1lcik7XG4gIH0sIGUucHJvdG90eXBlLmF1dG9QbGF5SXRlcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzLFxuICAgICAgZSA9IGkuY3VycmVudFNsaWRlICsgaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgIGkucGF1c2VkIHx8IGkuaW50ZXJydXB0ZWQgfHwgaS5mb2N1c3NlZCB8fCAoaS5vcHRpb25zLmluZmluaXRlID09PSAhMSAmJiAoMSA9PT0gaS5kaXJlY3Rpb24gJiYgaS5jdXJyZW50U2xpZGUgKyAxID09PSBpLnNsaWRlQ291bnQgLSAxID8gaS5kaXJlY3Rpb24gPSAwIDogMCA9PT0gaS5kaXJlY3Rpb24gJiYgKGUgPSBpLmN1cnJlbnRTbGlkZSAtIGkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCwgaS5jdXJyZW50U2xpZGUgLSAxID09PSAwICYmIChpLmRpcmVjdGlvbiA9IDEpKSksIGkuc2xpZGVIYW5kbGVyKGUpKTtcbiAgfSwgZS5wcm90b3R5cGUuYnVpbGRBcnJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIGUub3B0aW9ucy5hcnJvd3MgPT09ICEwICYmIChlLiRwcmV2QXJyb3cgPSBpKGUub3B0aW9ucy5wcmV2QXJyb3cpLmFkZENsYXNzKFwic2xpY2stYXJyb3dcIiksIGUuJG5leHRBcnJvdyA9IGkoZS5vcHRpb25zLm5leHRBcnJvdykuYWRkQ2xhc3MoXCJzbGljay1hcnJvd1wiKSwgZS5zbGlkZUNvdW50ID4gZS5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IChlLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1oaWRkZW5cIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuIHRhYmluZGV4XCIpLCBlLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoXCJzbGljay1oaWRkZW5cIikucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuIHRhYmluZGV4XCIpLCBlLmh0bWxFeHByLnRlc3QoZS5vcHRpb25zLnByZXZBcnJvdykgJiYgZS4kcHJldkFycm93LnByZXBlbmRUbyhlLm9wdGlvbnMuYXBwZW5kQXJyb3dzKSwgZS5odG1sRXhwci50ZXN0KGUub3B0aW9ucy5uZXh0QXJyb3cpICYmIGUuJG5leHRBcnJvdy5hcHBlbmRUbyhlLm9wdGlvbnMuYXBwZW5kQXJyb3dzKSwgZS5vcHRpb25zLmluZmluaXRlICE9PSAhMCAmJiBlLiRwcmV2QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIikpIDogZS4kcHJldkFycm93LmFkZChlLiRuZXh0QXJyb3cpLmFkZENsYXNzKFwic2xpY2staGlkZGVuXCIpLmF0dHIoe1xuICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IFwidHJ1ZVwiLFxuICAgICAgdGFiaW5kZXg6IFwiLTFcIlxuICAgIH0pKTtcbiAgfSwgZS5wcm90b3R5cGUuYnVpbGREb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlLFxuICAgICAgdCxcbiAgICAgIG8gPSB0aGlzO1xuICAgIGlmIChvLm9wdGlvbnMuZG90cyA9PT0gITAgJiYgby5zbGlkZUNvdW50ID4gby5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgZm9yIChvLiRzbGlkZXIuYWRkQ2xhc3MoXCJzbGljay1kb3R0ZWRcIiksIHQgPSBpKFwiPHVsIC8+XCIpLmFkZENsYXNzKG8ub3B0aW9ucy5kb3RzQ2xhc3MpLCBlID0gMDsgZSA8PSBvLmdldERvdENvdW50KCk7IGUgKz0gMSkgdC5hcHBlbmQoaShcIjxsaSAvPlwiKS5hcHBlbmQoby5vcHRpb25zLmN1c3RvbVBhZ2luZy5jYWxsKHRoaXMsIG8sIGUpKSk7XG4gICAgICBvLiRkb3RzID0gdC5hcHBlbmRUbyhvLm9wdGlvbnMuYXBwZW5kRG90cyksIG8uJGRvdHMuZmluZChcImxpXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIik7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5idWlsZE91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IHRoaXM7XG4gICAgZS4kc2xpZGVzID0gZS4kc2xpZGVyLmNoaWxkcmVuKGUub3B0aW9ucy5zbGlkZSArIFwiOm5vdCguc2xpY2stY2xvbmVkKVwiKS5hZGRDbGFzcyhcInNsaWNrLXNsaWRlXCIpLCBlLnNsaWRlQ291bnQgPSBlLiRzbGlkZXMubGVuZ3RoLCBlLiRzbGlkZXMuZWFjaChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgaSh0KS5hdHRyKFwiZGF0YS1zbGljay1pbmRleFwiLCBlKS5kYXRhKFwib3JpZ2luYWxTdHlsaW5nXCIsIGkodCkuYXR0cihcInN0eWxlXCIpIHx8IFwiXCIpO1xuICAgIH0pLCBlLiRzbGlkZXIuYWRkQ2xhc3MoXCJzbGljay1zbGlkZXJcIiksIGUuJHNsaWRlVHJhY2sgPSAwID09PSBlLnNsaWRlQ291bnQgPyBpKCc8ZGl2IGNsYXNzPVwic2xpY2stdHJhY2tcIi8+JykuYXBwZW5kVG8oZS4kc2xpZGVyKSA6IGUuJHNsaWRlcy53cmFwQWxsKCc8ZGl2IGNsYXNzPVwic2xpY2stdHJhY2tcIi8+JykucGFyZW50KCksIGUuJGxpc3QgPSBlLiRzbGlkZVRyYWNrLndyYXAoJzxkaXYgY2xhc3M9XCJzbGljay1saXN0XCIvPicpLnBhcmVudCgpLCBlLiRzbGlkZVRyYWNrLmNzcyhcIm9wYWNpdHlcIiwgMCksIGUub3B0aW9ucy5jZW50ZXJNb2RlICE9PSAhMCAmJiBlLm9wdGlvbnMuc3dpcGVUb1NsaWRlICE9PSAhMCB8fCAoZS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsID0gMSksIGkoXCJpbWdbZGF0YS1sYXp5XVwiLCBlLiRzbGlkZXIpLm5vdChcIltzcmNdXCIpLmFkZENsYXNzKFwic2xpY2stbG9hZGluZ1wiKSwgZS5zZXR1cEluZmluaXRlKCksIGUuYnVpbGRBcnJvd3MoKSwgZS5idWlsZERvdHMoKSwgZS51cGRhdGVEb3RzKCksIGUuc2V0U2xpZGVDbGFzc2VzKFwibnVtYmVyXCIgPT0gdHlwZW9mIGUuY3VycmVudFNsaWRlID8gZS5jdXJyZW50U2xpZGUgOiAwKSwgZS5vcHRpb25zLmRyYWdnYWJsZSA9PT0gITAgJiYgZS4kbGlzdC5hZGRDbGFzcyhcImRyYWdnYWJsZVwiKTtcbiAgfSwgZS5wcm90b3R5cGUuYnVpbGRSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLFxuICAgICAgZSxcbiAgICAgIHQsXG4gICAgICBvLFxuICAgICAgcyxcbiAgICAgIG4sXG4gICAgICByLFxuICAgICAgbCA9IHRoaXM7XG4gICAgaWYgKG8gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIG4gPSBsLiRzbGlkZXIuY2hpbGRyZW4oKSwgbC5vcHRpb25zLnJvd3MgPiAwKSB7XG4gICAgICBmb3IgKHIgPSBsLm9wdGlvbnMuc2xpZGVzUGVyUm93ICogbC5vcHRpb25zLnJvd3MsIHMgPSBNYXRoLmNlaWwobi5sZW5ndGggLyByKSwgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdmFyIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgbC5vcHRpb25zLnJvd3M7IGUrKykge1xuICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICBmb3IgKHQgPSAwOyB0IDwgbC5vcHRpb25zLnNsaWRlc1BlclJvdzsgdCsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGkgKiByICsgKGUgKiBsLm9wdGlvbnMuc2xpZGVzUGVyUm93ICsgdCk7XG4gICAgICAgICAgICBuLmdldChjKSAmJiBhLmFwcGVuZENoaWxkKG4uZ2V0KGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZC5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgfVxuICAgICAgICBvLmFwcGVuZENoaWxkKGQpO1xuICAgICAgfVxuICAgICAgbC4kc2xpZGVyLmVtcHR5KCkuYXBwZW5kKG8pLCBsLiRzbGlkZXIuY2hpbGRyZW4oKS5jaGlsZHJlbigpLmNoaWxkcmVuKCkuY3NzKHtcbiAgICAgICAgd2lkdGg6IDEwMCAvIGwub3B0aW9ucy5zbGlkZXNQZXJSb3cgKyBcIiVcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgfSk7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5jaGVja1Jlc3BvbnNpdmUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgIHZhciBvLFxuICAgICAgcyxcbiAgICAgIG4sXG4gICAgICByID0gdGhpcyxcbiAgICAgIGwgPSAhMSxcbiAgICAgIGQgPSByLiRzbGlkZXIud2lkdGgoKSxcbiAgICAgIGEgPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBpKHdpbmRvdykud2lkdGgoKTtcbiAgICBpZiAoXCJ3aW5kb3dcIiA9PT0gci5yZXNwb25kVG8gPyBuID0gYSA6IFwic2xpZGVyXCIgPT09IHIucmVzcG9uZFRvID8gbiA9IGQgOiBcIm1pblwiID09PSByLnJlc3BvbmRUbyAmJiAobiA9IE1hdGgubWluKGEsIGQpKSwgci5vcHRpb25zLnJlc3BvbnNpdmUgJiYgci5vcHRpb25zLnJlc3BvbnNpdmUubGVuZ3RoICYmIG51bGwgIT09IHIub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICBzID0gbnVsbDtcbiAgICAgIGZvciAobyBpbiByLmJyZWFrcG9pbnRzKSByLmJyZWFrcG9pbnRzLmhhc093blByb3BlcnR5KG8pICYmIChyLm9yaWdpbmFsU2V0dGluZ3MubW9iaWxlRmlyc3QgPT09ICExID8gbiA8IHIuYnJlYWtwb2ludHNbb10gJiYgKHMgPSByLmJyZWFrcG9pbnRzW29dKSA6IG4gPiByLmJyZWFrcG9pbnRzW29dICYmIChzID0gci5icmVha3BvaW50c1tvXSkpO1xuICAgICAgbnVsbCAhPT0gcyA/IG51bGwgIT09IHIuYWN0aXZlQnJlYWtwb2ludCA/IChzICE9PSByLmFjdGl2ZUJyZWFrcG9pbnQgfHwgdCkgJiYgKHIuYWN0aXZlQnJlYWtwb2ludCA9IHMsIFwidW5zbGlja1wiID09PSByLmJyZWFrcG9pbnRTZXR0aW5nc1tzXSA/IHIudW5zbGljayhzKSA6IChyLm9wdGlvbnMgPSBpLmV4dGVuZCh7fSwgci5vcmlnaW5hbFNldHRpbmdzLCByLmJyZWFrcG9pbnRTZXR0aW5nc1tzXSksIGUgPT09ICEwICYmIChyLmN1cnJlbnRTbGlkZSA9IHIub3B0aW9ucy5pbml0aWFsU2xpZGUpLCByLnJlZnJlc2goZSkpLCBsID0gcykgOiAoci5hY3RpdmVCcmVha3BvaW50ID0gcywgXCJ1bnNsaWNrXCIgPT09IHIuYnJlYWtwb2ludFNldHRpbmdzW3NdID8gci51bnNsaWNrKHMpIDogKHIub3B0aW9ucyA9IGkuZXh0ZW5kKHt9LCByLm9yaWdpbmFsU2V0dGluZ3MsIHIuYnJlYWtwb2ludFNldHRpbmdzW3NdKSwgZSA9PT0gITAgJiYgKHIuY3VycmVudFNsaWRlID0gci5vcHRpb25zLmluaXRpYWxTbGlkZSksIHIucmVmcmVzaChlKSksIGwgPSBzKSA6IG51bGwgIT09IHIuYWN0aXZlQnJlYWtwb2ludCAmJiAoci5hY3RpdmVCcmVha3BvaW50ID0gbnVsbCwgci5vcHRpb25zID0gci5vcmlnaW5hbFNldHRpbmdzLCBlID09PSAhMCAmJiAoci5jdXJyZW50U2xpZGUgPSByLm9wdGlvbnMuaW5pdGlhbFNsaWRlKSwgci5yZWZyZXNoKGUpLCBsID0gcyksIGUgfHwgbCA9PT0gITEgfHwgci4kc2xpZGVyLnRyaWdnZXIoXCJicmVha3BvaW50XCIsIFtyLCBsXSk7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5jaGFuZ2VTbGlkZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgdmFyIG8sXG4gICAgICBzLFxuICAgICAgbixcbiAgICAgIHIgPSB0aGlzLFxuICAgICAgbCA9IGkoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICBzd2l0Y2ggKGwuaXMoXCJhXCIpICYmIGUucHJldmVudERlZmF1bHQoKSwgbC5pcyhcImxpXCIpIHx8IChsID0gbC5jbG9zZXN0KFwibGlcIikpLCBuID0gci5zbGlkZUNvdW50ICUgci5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwLCBvID0gbiA/IDAgOiAoci5zbGlkZUNvdW50IC0gci5jdXJyZW50U2xpZGUpICUgci5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLCBlLmRhdGEubWVzc2FnZSkge1xuICAgICAgY2FzZSBcInByZXZpb3VzXCI6XG4gICAgICAgIHMgPSAwID09PSBvID8gci5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogci5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIG8sIHIuc2xpZGVDb3VudCA+IHIub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiYgci5zbGlkZUhhbmRsZXIoci5jdXJyZW50U2xpZGUgLSBzLCAhMSwgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm5leHRcIjpcbiAgICAgICAgcyA9IDAgPT09IG8gPyByLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBvLCByLnNsaWRlQ291bnQgPiByLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIHIuc2xpZGVIYW5kbGVyKHIuY3VycmVudFNsaWRlICsgcywgITEsIHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICB2YXIgZCA9IDAgPT09IGUuZGF0YS5pbmRleCA/IDAgOiBlLmRhdGEuaW5kZXggfHwgbC5pbmRleCgpICogci5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICByLnNsaWRlSGFuZGxlcihyLmNoZWNrTmF2aWdhYmxlKGQpLCAhMSwgdCksIGwuY2hpbGRyZW4oKS50cmlnZ2VyKFwiZm9jdXNcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSwgZS5wcm90b3R5cGUuY2hlY2tOYXZpZ2FibGUgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBlLFxuICAgICAgdCxcbiAgICAgIG8gPSB0aGlzO1xuICAgIGlmIChlID0gby5nZXROYXZpZ2FibGVJbmRleGVzKCksIHQgPSAwLCBpID4gZVtlLmxlbmd0aCAtIDFdKSBpID0gZVtlLmxlbmd0aCAtIDFdO2Vsc2UgZm9yICh2YXIgcyBpbiBlKSB7XG4gICAgICBpZiAoaSA8IGVbc10pIHtcbiAgICAgICAgaSA9IHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdCA9IGVbc107XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9LCBlLnByb3RvdHlwZS5jbGVhblVwRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gdGhpcztcbiAgICBlLm9wdGlvbnMuZG90cyAmJiBudWxsICE9PSBlLiRkb3RzICYmIChpKFwibGlcIiwgZS4kZG90cykub2ZmKFwiY2xpY2suc2xpY2tcIiwgZS5jaGFuZ2VTbGlkZSkub2ZmKFwibW91c2VlbnRlci5zbGlja1wiLCBpLnByb3h5KGUuaW50ZXJydXB0LCBlLCAhMCkpLm9mZihcIm1vdXNlbGVhdmUuc2xpY2tcIiwgaS5wcm94eShlLmludGVycnVwdCwgZSwgITEpKSwgZS5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09ICEwICYmIGUuJGRvdHMub2ZmKFwia2V5ZG93bi5zbGlja1wiLCBlLmtleUhhbmRsZXIpKSwgZS4kc2xpZGVyLm9mZihcImZvY3VzLnNsaWNrIGJsdXIuc2xpY2tcIiksIGUub3B0aW9ucy5hcnJvd3MgPT09ICEwICYmIGUuc2xpZGVDb3VudCA+IGUub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiYgKGUuJHByZXZBcnJvdyAmJiBlLiRwcmV2QXJyb3cub2ZmKFwiY2xpY2suc2xpY2tcIiwgZS5jaGFuZ2VTbGlkZSksIGUuJG5leHRBcnJvdyAmJiBlLiRuZXh0QXJyb3cub2ZmKFwiY2xpY2suc2xpY2tcIiwgZS5jaGFuZ2VTbGlkZSksIGUub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSAhMCAmJiAoZS4kcHJldkFycm93ICYmIGUuJHByZXZBcnJvdy5vZmYoXCJrZXlkb3duLnNsaWNrXCIsIGUua2V5SGFuZGxlciksIGUuJG5leHRBcnJvdyAmJiBlLiRuZXh0QXJyb3cub2ZmKFwia2V5ZG93bi5zbGlja1wiLCBlLmtleUhhbmRsZXIpKSksIGUuJGxpc3Qub2ZmKFwidG91Y2hzdGFydC5zbGljayBtb3VzZWRvd24uc2xpY2tcIiwgZS5zd2lwZUhhbmRsZXIpLCBlLiRsaXN0Lm9mZihcInRvdWNobW92ZS5zbGljayBtb3VzZW1vdmUuc2xpY2tcIiwgZS5zd2lwZUhhbmRsZXIpLCBlLiRsaXN0Lm9mZihcInRvdWNoZW5kLnNsaWNrIG1vdXNldXAuc2xpY2tcIiwgZS5zd2lwZUhhbmRsZXIpLCBlLiRsaXN0Lm9mZihcInRvdWNoY2FuY2VsLnNsaWNrIG1vdXNlbGVhdmUuc2xpY2tcIiwgZS5zd2lwZUhhbmRsZXIpLCBlLiRsaXN0Lm9mZihcImNsaWNrLnNsaWNrXCIsIGUuY2xpY2tIYW5kbGVyKSwgaShkb2N1bWVudCkub2ZmKGUudmlzaWJpbGl0eUNoYW5nZSwgZS52aXNpYmlsaXR5KSwgZS5jbGVhblVwU2xpZGVFdmVudHMoKSwgZS5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09ICEwICYmIGUuJGxpc3Qub2ZmKFwia2V5ZG93bi5zbGlja1wiLCBlLmtleUhhbmRsZXIpLCBlLm9wdGlvbnMuZm9jdXNPblNlbGVjdCA9PT0gITAgJiYgaShlLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9mZihcImNsaWNrLnNsaWNrXCIsIGUuc2VsZWN0SGFuZGxlciksIGkod2luZG93KS5vZmYoXCJvcmllbnRhdGlvbmNoYW5nZS5zbGljay5zbGljay1cIiArIGUuaW5zdGFuY2VVaWQsIGUub3JpZW50YXRpb25DaGFuZ2UpLCBpKHdpbmRvdykub2ZmKFwicmVzaXplLnNsaWNrLnNsaWNrLVwiICsgZS5pbnN0YW5jZVVpZCwgZS5yZXNpemUpLCBpKFwiW2RyYWdnYWJsZSE9dHJ1ZV1cIiwgZS4kc2xpZGVUcmFjaykub2ZmKFwiZHJhZ3N0YXJ0XCIsIGUucHJldmVudERlZmF1bHQpLCBpKHdpbmRvdykub2ZmKFwibG9hZC5zbGljay5zbGljay1cIiArIGUuaW5zdGFuY2VVaWQsIGUuc2V0UG9zaXRpb24pO1xuICB9LCBlLnByb3RvdHlwZS5jbGVhblVwU2xpZGVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIGUuJGxpc3Qub2ZmKFwibW91c2VlbnRlci5zbGlja1wiLCBpLnByb3h5KGUuaW50ZXJydXB0LCBlLCAhMCkpLCBlLiRsaXN0Lm9mZihcIm1vdXNlbGVhdmUuc2xpY2tcIiwgaS5wcm94eShlLmludGVycnVwdCwgZSwgITEpKTtcbiAgfSwgZS5wcm90b3R5cGUuY2xlYW5VcFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksXG4gICAgICBlID0gdGhpcztcbiAgICBlLm9wdGlvbnMucm93cyA+IDAgJiYgKGkgPSBlLiRzbGlkZXMuY2hpbGRyZW4oKS5jaGlsZHJlbigpLCBpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKSwgZS4kc2xpZGVyLmVtcHR5KCkuYXBwZW5kKGkpKTtcbiAgfSwgZS5wcm90b3R5cGUuY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgZSA9IHRoaXM7XG4gICAgZS5zaG91bGRDbGljayA9PT0gITEgJiYgKGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIGkuc3RvcFByb3BhZ2F0aW9uKCksIGkucHJldmVudERlZmF1bHQoKSk7XG4gIH0sIGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB0ID0gdGhpcztcbiAgICB0LmF1dG9QbGF5Q2xlYXIoKSwgdC50b3VjaE9iamVjdCA9IHt9LCB0LmNsZWFuVXBFdmVudHMoKSwgaShcIi5zbGljay1jbG9uZWRcIiwgdC4kc2xpZGVyKS5kZXRhY2goKSwgdC4kZG90cyAmJiB0LiRkb3RzLnJlbW92ZSgpLCB0LiRwcmV2QXJyb3cgJiYgdC4kcHJldkFycm93Lmxlbmd0aCAmJiAodC4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4XCIpLmNzcyhcImRpc3BsYXlcIiwgXCJcIiksIHQuaHRtbEV4cHIudGVzdCh0Lm9wdGlvbnMucHJldkFycm93KSAmJiB0LiRwcmV2QXJyb3cucmVtb3ZlKCkpLCB0LiRuZXh0QXJyb3cgJiYgdC4kbmV4dEFycm93Lmxlbmd0aCAmJiAodC4kbmV4dEFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuXCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4XCIpLmNzcyhcImRpc3BsYXlcIiwgXCJcIiksIHQuaHRtbEV4cHIudGVzdCh0Lm9wdGlvbnMubmV4dEFycm93KSAmJiB0LiRuZXh0QXJyb3cucmVtb3ZlKCkpLCB0LiRzbGlkZXMgJiYgKHQuJHNsaWRlcy5yZW1vdmVDbGFzcyhcInNsaWNrLXNsaWRlIHNsaWNrLWFjdGl2ZSBzbGljay1jZW50ZXIgc2xpY2stdmlzaWJsZSBzbGljay1jdXJyZW50XCIpLnJlbW92ZUF0dHIoXCJhcmlhLWhpZGRlblwiKS5yZW1vdmVBdHRyKFwiZGF0YS1zbGljay1pbmRleFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGkodGhpcykuYXR0cihcInN0eWxlXCIsIGkodGhpcykuZGF0YShcIm9yaWdpbmFsU3R5bGluZ1wiKSk7XG4gICAgfSksIHQuJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKSwgdC4kc2xpZGVUcmFjay5kZXRhY2goKSwgdC4kbGlzdC5kZXRhY2goKSwgdC4kc2xpZGVyLmFwcGVuZCh0LiRzbGlkZXMpKSwgdC5jbGVhblVwUm93cygpLCB0LiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1zbGlkZXJcIiksIHQuJHNsaWRlci5yZW1vdmVDbGFzcyhcInNsaWNrLWluaXRpYWxpemVkXCIpLCB0LiRzbGlkZXIucmVtb3ZlQ2xhc3MoXCJzbGljay1kb3R0ZWRcIiksIHQudW5zbGlja2VkID0gITAsIGUgfHwgdC4kc2xpZGVyLnRyaWdnZXIoXCJkZXN0cm95XCIsIFt0XSk7XG4gIH0sIGUucHJvdG90eXBlLmRpc2FibGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgZSA9IHRoaXMsXG4gICAgICB0ID0ge307XG4gICAgdFtlLnRyYW5zaXRpb25UeXBlXSA9IFwiXCIsIGUub3B0aW9ucy5mYWRlID09PSAhMSA/IGUuJHNsaWRlVHJhY2suY3NzKHQpIDogZS4kc2xpZGVzLmVxKGkpLmNzcyh0KTtcbiAgfSwgZS5wcm90b3R5cGUuZmFkZVNsaWRlID0gZnVuY3Rpb24gKGksIGUpIHtcbiAgICB2YXIgdCA9IHRoaXM7XG4gICAgdC5jc3NUcmFuc2l0aW9ucyA9PT0gITEgPyAodC4kc2xpZGVzLmVxKGkpLmNzcyh7XG4gICAgICB6SW5kZXg6IHQub3B0aW9ucy56SW5kZXhcbiAgICB9KSwgdC4kc2xpZGVzLmVxKGkpLmFuaW1hdGUoe1xuICAgICAgb3BhY2l0eTogMVxuICAgIH0sIHQub3B0aW9ucy5zcGVlZCwgdC5vcHRpb25zLmVhc2luZywgZSkpIDogKHQuYXBwbHlUcmFuc2l0aW9uKGkpLCB0LiRzbGlkZXMuZXEoaSkuY3NzKHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB6SW5kZXg6IHQub3B0aW9ucy56SW5kZXhcbiAgICB9KSwgZSAmJiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHQuZGlzYWJsZVRyYW5zaXRpb24oaSksIGUuY2FsbCgpO1xuICAgIH0sIHQub3B0aW9ucy5zcGVlZCkpO1xuICB9LCBlLnByb3RvdHlwZS5mYWRlU2xpZGVPdXQgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBlID0gdGhpcztcbiAgICBlLmNzc1RyYW5zaXRpb25zID09PSAhMSA/IGUuJHNsaWRlcy5lcShpKS5hbmltYXRlKHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB6SW5kZXg6IGUub3B0aW9ucy56SW5kZXggLSAyXG4gICAgfSwgZS5vcHRpb25zLnNwZWVkLCBlLm9wdGlvbnMuZWFzaW5nKSA6IChlLmFwcGx5VHJhbnNpdGlvbihpKSwgZS4kc2xpZGVzLmVxKGkpLmNzcyh7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgekluZGV4OiBlLm9wdGlvbnMuekluZGV4IC0gMlxuICAgIH0pKTtcbiAgfSwgZS5wcm90b3R5cGUuZmlsdGVyU2xpZGVzID0gZS5wcm90b3R5cGUuc2xpY2tGaWx0ZXIgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBlID0gdGhpcztcbiAgICBudWxsICE9PSBpICYmIChlLiRzbGlkZXNDYWNoZSA9IGUuJHNsaWRlcywgZS51bmxvYWQoKSwgZS4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLCBlLiRzbGlkZXNDYWNoZS5maWx0ZXIoaSkuYXBwZW5kVG8oZS4kc2xpZGVUcmFjayksIGUucmVpbml0KCkpO1xuICB9LCBlLnByb3RvdHlwZS5mb2N1c0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIGUuJHNsaWRlci5vZmYoXCJmb2N1cy5zbGljayBibHVyLnNsaWNrXCIpLm9uKFwiZm9jdXMuc2xpY2tcIiwgXCIqXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgbyA9IGkodGhpcyk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZS5vcHRpb25zLnBhdXNlT25Gb2N1cyAmJiBvLmlzKFwiOmZvY3VzXCIpICYmIChlLmZvY3Vzc2VkID0gITAsIGUuYXV0b1BsYXkoKSk7XG4gICAgICB9LCAwKTtcbiAgICB9KS5vbihcImJsdXIuc2xpY2tcIiwgXCIqXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICBpKHRoaXMpO1xuICAgICAgZS5vcHRpb25zLnBhdXNlT25Gb2N1cyAmJiAoZS5mb2N1c3NlZCA9ICExLCBlLmF1dG9QbGF5KCkpO1xuICAgIH0pO1xuICB9LCBlLnByb3RvdHlwZS5nZXRDdXJyZW50ID0gZS5wcm90b3R5cGUuc2xpY2tDdXJyZW50U2xpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzO1xuICAgIHJldHVybiBpLmN1cnJlbnRTbGlkZTtcbiAgfSwgZS5wcm90b3R5cGUuZ2V0RG90Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzLFxuICAgICAgZSA9IDAsXG4gICAgICB0ID0gMCxcbiAgICAgIG8gPSAwO1xuICAgIGlmIChpLm9wdGlvbnMuaW5maW5pdGUgPT09ICEwKSB7XG4gICAgICBpZiAoaS5zbGlkZUNvdW50IDw9IGkub3B0aW9ucy5zbGlkZXNUb1Nob3cpICsrbztlbHNlIGZvciAoOyBlIDwgaS5zbGlkZUNvdW50OykgKytvLCBlID0gdCArIGkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCwgdCArPSBpLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPD0gaS5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IGkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IGkub3B0aW9ucy5zbGlkZXNUb1Nob3c7XG4gICAgfSBlbHNlIGlmIChpLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gITApIG8gPSBpLnNsaWRlQ291bnQ7ZWxzZSBpZiAoaS5vcHRpb25zLmFzTmF2Rm9yKSBmb3IgKDsgZSA8IGkuc2xpZGVDb3VudDspICsrbywgZSA9IHQgKyBpLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwsIHQgKz0gaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDw9IGkub3B0aW9ucy5zbGlkZXNUb1Nob3cgPyBpLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgOiBpLm9wdGlvbnMuc2xpZGVzVG9TaG93O2Vsc2UgbyA9IDEgKyBNYXRoLmNlaWwoKGkuc2xpZGVDb3VudCAtIGkub3B0aW9ucy5zbGlkZXNUb1Nob3cpIC8gaS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKTtcbiAgICByZXR1cm4gbyAtIDE7XG4gIH0sIGUucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBlLFxuICAgICAgdCxcbiAgICAgIG8sXG4gICAgICBzLFxuICAgICAgbiA9IHRoaXMsXG4gICAgICByID0gMDtcbiAgICByZXR1cm4gbi5zbGlkZU9mZnNldCA9IDAsIHQgPSBuLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCghMCksIG4ub3B0aW9ucy5pbmZpbml0ZSA9PT0gITAgPyAobi5zbGlkZUNvdW50ID4gbi5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJiAobi5zbGlkZU9mZnNldCA9IG4uc2xpZGVXaWR0aCAqIG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKiAtMSwgcyA9IC0xLCBuLm9wdGlvbnMudmVydGljYWwgPT09ICEwICYmIG4ub3B0aW9ucy5jZW50ZXJNb2RlID09PSAhMCAmJiAoMiA9PT0gbi5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IHMgPSAtMS41IDogMSA9PT0gbi5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJiAocyA9IC0yKSksIHIgPSB0ICogbi5vcHRpb25zLnNsaWRlc1RvU2hvdyAqIHMpLCBuLnNsaWRlQ291bnQgJSBuLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgIT09IDAgJiYgaSArIG4ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA+IG4uc2xpZGVDb3VudCAmJiBuLnNsaWRlQ291bnQgPiBuLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIChpID4gbi5zbGlkZUNvdW50ID8gKG4uc2xpZGVPZmZzZXQgPSAobi5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIChpIC0gbi5zbGlkZUNvdW50KSkgKiBuLnNsaWRlV2lkdGggKiAtMSwgciA9IChuLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gKGkgLSBuLnNsaWRlQ291bnQpKSAqIHQgKiAtMSkgOiAobi5zbGlkZU9mZnNldCA9IG4uc2xpZGVDb3VudCAlIG4ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAqIG4uc2xpZGVXaWR0aCAqIC0xLCByID0gbi5zbGlkZUNvdW50ICUgbi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICogdCAqIC0xKSkpIDogaSArIG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPiBuLnNsaWRlQ291bnQgJiYgKG4uc2xpZGVPZmZzZXQgPSAoaSArIG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLSBuLnNsaWRlQ291bnQpICogbi5zbGlkZVdpZHRoLCByID0gKGkgKyBuLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gbi5zbGlkZUNvdW50KSAqIHQpLCBuLnNsaWRlQ291bnQgPD0gbi5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJiAobi5zbGlkZU9mZnNldCA9IDAsIHIgPSAwKSwgbi5vcHRpb25zLmNlbnRlck1vZGUgPT09ICEwICYmIG4uc2xpZGVDb3VudCA8PSBuLm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gbi5zbGlkZU9mZnNldCA9IG4uc2xpZGVXaWR0aCAqIE1hdGguZmxvb3Iobi5vcHRpb25zLnNsaWRlc1RvU2hvdykgLyAyIC0gbi5zbGlkZVdpZHRoICogbi5zbGlkZUNvdW50IC8gMiA6IG4ub3B0aW9ucy5jZW50ZXJNb2RlID09PSAhMCAmJiBuLm9wdGlvbnMuaW5maW5pdGUgPT09ICEwID8gbi5zbGlkZU9mZnNldCArPSBuLnNsaWRlV2lkdGggKiBNYXRoLmZsb29yKG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKSAtIG4uc2xpZGVXaWR0aCA6IG4ub3B0aW9ucy5jZW50ZXJNb2RlID09PSAhMCAmJiAobi5zbGlkZU9mZnNldCA9IDAsIG4uc2xpZGVPZmZzZXQgKz0gbi5zbGlkZVdpZHRoICogTWF0aC5mbG9vcihuLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMikpLCBlID0gbi5vcHRpb25zLnZlcnRpY2FsID09PSAhMSA/IGkgKiBuLnNsaWRlV2lkdGggKiAtMSArIG4uc2xpZGVPZmZzZXQgOiBpICogdCAqIC0xICsgciwgbi5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09ICEwICYmIChvID0gbi5zbGlkZUNvdW50IDw9IG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cgfHwgbi5vcHRpb25zLmluZmluaXRlID09PSAhMSA/IG4uJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikuZXEoaSkgOiBuLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmVxKGkgKyBuLm9wdGlvbnMuc2xpZGVzVG9TaG93KSwgZSA9IG4ub3B0aW9ucy5ydGwgPT09ICEwID8gb1swXSA/IChuLiRzbGlkZVRyYWNrLndpZHRoKCkgLSBvWzBdLm9mZnNldExlZnQgLSBvLndpZHRoKCkpICogLTEgOiAwIDogb1swXSA/IG9bMF0ub2Zmc2V0TGVmdCAqIC0xIDogMCwgbi5vcHRpb25zLmNlbnRlck1vZGUgPT09ICEwICYmIChvID0gbi5zbGlkZUNvdW50IDw9IG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cgfHwgbi5vcHRpb25zLmluZmluaXRlID09PSAhMSA/IG4uJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikuZXEoaSkgOiBuLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmVxKGkgKyBuLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgMSksIGUgPSBuLm9wdGlvbnMucnRsID09PSAhMCA/IG9bMF0gPyAobi4kc2xpZGVUcmFjay53aWR0aCgpIC0gb1swXS5vZmZzZXRMZWZ0IC0gby53aWR0aCgpKSAqIC0xIDogMCA6IG9bMF0gPyBvWzBdLm9mZnNldExlZnQgKiAtMSA6IDAsIGUgKz0gKG4uJGxpc3Qud2lkdGgoKSAtIG8ub3V0ZXJXaWR0aCgpKSAvIDIpKSwgZTtcbiAgfSwgZS5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZS5wcm90b3R5cGUuc2xpY2tHZXRPcHRpb24gPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBlID0gdGhpcztcbiAgICByZXR1cm4gZS5vcHRpb25zW2ldO1xuICB9LCBlLnByb3RvdHlwZS5nZXROYXZpZ2FibGVJbmRleGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLFxuICAgICAgZSA9IHRoaXMsXG4gICAgICB0ID0gMCxcbiAgICAgIG8gPSAwLFxuICAgICAgcyA9IFtdO1xuICAgIGZvciAoZS5vcHRpb25zLmluZmluaXRlID09PSAhMSA/IGkgPSBlLnNsaWRlQ291bnQgOiAodCA9IGUub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAqIC0xLCBvID0gZS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICogLTEsIGkgPSAyICogZS5zbGlkZUNvdW50KTsgdCA8IGk7KSBzLnB1c2godCksIHQgPSBvICsgZS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsLCBvICs9IGUub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA8PSBlLm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gZS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogZS5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICByZXR1cm4gcztcbiAgfSwgZS5wcm90b3R5cGUuZ2V0U2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIGUucHJvdG90eXBlLmdldFNsaWRlQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUsXG4gICAgICB0LFxuICAgICAgbyxcbiAgICAgIHMsXG4gICAgICBuID0gdGhpcztcbiAgICByZXR1cm4gcyA9IG4ub3B0aW9ucy5jZW50ZXJNb2RlID09PSAhMCA/IE1hdGguZmxvb3Iobi4kbGlzdC53aWR0aCgpIC8gMikgOiAwLCBvID0gbi5zd2lwZUxlZnQgKiAtMSArIHMsIG4ub3B0aW9ucy5zd2lwZVRvU2xpZGUgPT09ICEwID8gKG4uJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1zbGlkZVwiKS5lYWNoKGZ1bmN0aW9uIChlLCBzKSB7XG4gICAgICB2YXIgciwgbCwgZDtcbiAgICAgIGlmIChyID0gaShzKS5vdXRlcldpZHRoKCksIGwgPSBzLm9mZnNldExlZnQsIG4ub3B0aW9ucy5jZW50ZXJNb2RlICE9PSAhMCAmJiAobCArPSByIC8gMiksIGQgPSBsICsgciwgbyA8IGQpIHJldHVybiB0ID0gcywgITE7XG4gICAgfSksIGUgPSBNYXRoLmFicyhpKHQpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIpIC0gbi5jdXJyZW50U2xpZGUpIHx8IDEpIDogbi5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICB9LCBlLnByb3RvdHlwZS5nb1RvID0gZS5wcm90b3R5cGUuc2xpY2tHb1RvID0gZnVuY3Rpb24gKGksIGUpIHtcbiAgICB2YXIgdCA9IHRoaXM7XG4gICAgdC5jaGFuZ2VTbGlkZSh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lc3NhZ2U6IFwiaW5kZXhcIixcbiAgICAgICAgaW5kZXg6IHBhcnNlSW50KGkpXG4gICAgICB9XG4gICAgfSwgZSk7XG4gIH0sIGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB0ID0gdGhpcztcbiAgICBpKHQuJHNsaWRlcikuaGFzQ2xhc3MoXCJzbGljay1pbml0aWFsaXplZFwiKSB8fCAoaSh0LiRzbGlkZXIpLmFkZENsYXNzKFwic2xpY2staW5pdGlhbGl6ZWRcIiksIHQuYnVpbGRSb3dzKCksIHQuYnVpbGRPdXQoKSwgdC5zZXRQcm9wcygpLCB0LnN0YXJ0TG9hZCgpLCB0LmxvYWRTbGlkZXIoKSwgdC5pbml0aWFsaXplRXZlbnRzKCksIHQudXBkYXRlQXJyb3dzKCksIHQudXBkYXRlRG90cygpLCB0LmNoZWNrUmVzcG9uc2l2ZSghMCksIHQuZm9jdXNIYW5kbGVyKCkpLCBlICYmIHQuJHNsaWRlci50cmlnZ2VyKFwiaW5pdFwiLCBbdF0pLCB0Lm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gITAgJiYgdC5pbml0QURBKCksIHQub3B0aW9ucy5hdXRvcGxheSAmJiAodC5wYXVzZWQgPSAhMSwgdC5hdXRvUGxheSgpKTtcbiAgfSwgZS5wcm90b3R5cGUuaW5pdEFEQSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IHRoaXMsXG4gICAgICB0ID0gTWF0aC5jZWlsKGUuc2xpZGVDb3VudCAvIGUub3B0aW9ucy5zbGlkZXNUb1Nob3cpLFxuICAgICAgbyA9IGUuZ2V0TmF2aWdhYmxlSW5kZXhlcygpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaSA+PSAwICYmIGkgPCBlLnNsaWRlQ291bnQ7XG4gICAgICB9KTtcbiAgICBlLiRzbGlkZXMuYWRkKGUuJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1jbG9uZWRcIikpLmF0dHIoe1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICAgIHRhYmluZGV4OiBcIi0xXCJcbiAgICB9KS5maW5kKFwiYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0XCIpLmF0dHIoe1xuICAgICAgdGFiaW5kZXg6IFwiLTFcIlxuICAgIH0pLCBudWxsICE9PSBlLiRkb3RzICYmIChlLiRzbGlkZXMubm90KGUuJHNsaWRlVHJhY2suZmluZChcIi5zbGljay1jbG9uZWRcIikpLmVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBzID0gby5pbmRleE9mKHQpO1xuICAgICAgaWYgKGkodGhpcykuYXR0cih7XG4gICAgICAgIHJvbGU6IFwidGFicGFuZWxcIixcbiAgICAgICAgaWQ6IFwic2xpY2stc2xpZGVcIiArIGUuaW5zdGFuY2VVaWQgKyB0LFxuICAgICAgICB0YWJpbmRleDogLTFcbiAgICAgIH0pLCBzICE9PSAtMSkge1xuICAgICAgICB2YXIgbiA9IFwic2xpY2stc2xpZGUtY29udHJvbFwiICsgZS5pbnN0YW5jZVVpZCArIHM7XG4gICAgICAgIGkoXCIjXCIgKyBuKS5sZW5ndGggJiYgaSh0aGlzKS5hdHRyKHtcbiAgICAgICAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSwgZS4kZG90cy5hdHRyKFwicm9sZVwiLCBcInRhYmxpc3RcIikuZmluZChcImxpXCIpLmVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgIHZhciBuID0gb1tzXTtcbiAgICAgIGkodGhpcykuYXR0cih7XG4gICAgICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCJcbiAgICAgIH0pLCBpKHRoaXMpLmZpbmQoXCJidXR0b25cIikuZmlyc3QoKS5hdHRyKHtcbiAgICAgICAgcm9sZTogXCJ0YWJcIixcbiAgICAgICAgaWQ6IFwic2xpY2stc2xpZGUtY29udHJvbFwiICsgZS5pbnN0YW5jZVVpZCArIHMsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBcInNsaWNrLXNsaWRlXCIgKyBlLmluc3RhbmNlVWlkICsgbixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHMgKyAxICsgXCIgb2YgXCIgKyB0LFxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogbnVsbCxcbiAgICAgICAgdGFiaW5kZXg6IFwiLTFcIlxuICAgICAgfSk7XG4gICAgfSkuZXEoZS5jdXJyZW50U2xpZGUpLmZpbmQoXCJidXR0b25cIikuYXR0cih7XG4gICAgICBcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCIsXG4gICAgICB0YWJpbmRleDogXCIwXCJcbiAgICB9KS5lbmQoKSk7XG4gICAgZm9yICh2YXIgcyA9IGUuY3VycmVudFNsaWRlLCBuID0gcyArIGUub3B0aW9ucy5zbGlkZXNUb1Nob3c7IHMgPCBuOyBzKyspIGUub3B0aW9ucy5mb2N1c09uQ2hhbmdlID8gZS4kc2xpZGVzLmVxKHMpLmF0dHIoe1xuICAgICAgdGFiaW5kZXg6IFwiMFwiXG4gICAgfSkgOiBlLiRzbGlkZXMuZXEocykucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpO1xuICAgIGUuYWN0aXZhdGVBREEoKTtcbiAgfSwgZS5wcm90b3R5cGUuaW5pdEFycm93RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcztcbiAgICBpLm9wdGlvbnMuYXJyb3dzID09PSAhMCAmJiBpLnNsaWRlQ291bnQgPiBpLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIChpLiRwcmV2QXJyb3cub2ZmKFwiY2xpY2suc2xpY2tcIikub24oXCJjbGljay5zbGlja1wiLCB7XG4gICAgICBtZXNzYWdlOiBcInByZXZpb3VzXCJcbiAgICB9LCBpLmNoYW5nZVNsaWRlKSwgaS4kbmV4dEFycm93Lm9mZihcImNsaWNrLnNsaWNrXCIpLm9uKFwiY2xpY2suc2xpY2tcIiwge1xuICAgICAgbWVzc2FnZTogXCJuZXh0XCJcbiAgICB9LCBpLmNoYW5nZVNsaWRlKSwgaS5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09ICEwICYmIChpLiRwcmV2QXJyb3cub24oXCJrZXlkb3duLnNsaWNrXCIsIGkua2V5SGFuZGxlciksIGkuJG5leHRBcnJvdy5vbihcImtleWRvd24uc2xpY2tcIiwgaS5rZXlIYW5kbGVyKSkpO1xuICB9LCBlLnByb3RvdHlwZS5pbml0RG90RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gdGhpcztcbiAgICBlLm9wdGlvbnMuZG90cyA9PT0gITAgJiYgZS5zbGlkZUNvdW50ID4gZS5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJiAoaShcImxpXCIsIGUuJGRvdHMpLm9uKFwiY2xpY2suc2xpY2tcIiwge1xuICAgICAgbWVzc2FnZTogXCJpbmRleFwiXG4gICAgfSwgZS5jaGFuZ2VTbGlkZSksIGUub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSAhMCAmJiBlLiRkb3RzLm9uKFwia2V5ZG93bi5zbGlja1wiLCBlLmtleUhhbmRsZXIpKSwgZS5vcHRpb25zLmRvdHMgPT09ICEwICYmIGUub3B0aW9ucy5wYXVzZU9uRG90c0hvdmVyID09PSAhMCAmJiBlLnNsaWRlQ291bnQgPiBlLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIGkoXCJsaVwiLCBlLiRkb3RzKS5vbihcIm1vdXNlZW50ZXIuc2xpY2tcIiwgaS5wcm94eShlLmludGVycnVwdCwgZSwgITApKS5vbihcIm1vdXNlbGVhdmUuc2xpY2tcIiwgaS5wcm94eShlLmludGVycnVwdCwgZSwgITEpKTtcbiAgfSwgZS5wcm90b3R5cGUuaW5pdFNsaWRlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gdGhpcztcbiAgICBlLm9wdGlvbnMucGF1c2VPbkhvdmVyICYmIChlLiRsaXN0Lm9uKFwibW91c2VlbnRlci5zbGlja1wiLCBpLnByb3h5KGUuaW50ZXJydXB0LCBlLCAhMCkpLCBlLiRsaXN0Lm9uKFwibW91c2VsZWF2ZS5zbGlja1wiLCBpLnByb3h5KGUuaW50ZXJydXB0LCBlLCAhMSkpKTtcbiAgfSwgZS5wcm90b3R5cGUuaW5pdGlhbGl6ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IHRoaXM7XG4gICAgZS5pbml0QXJyb3dFdmVudHMoKSwgZS5pbml0RG90RXZlbnRzKCksIGUuaW5pdFNsaWRlRXZlbnRzKCksIGUuJGxpc3Qub24oXCJ0b3VjaHN0YXJ0LnNsaWNrIG1vdXNlZG93bi5zbGlja1wiLCB7XG4gICAgICBhY3Rpb246IFwic3RhcnRcIlxuICAgIH0sIGUuc3dpcGVIYW5kbGVyKSwgZS4kbGlzdC5vbihcInRvdWNobW92ZS5zbGljayBtb3VzZW1vdmUuc2xpY2tcIiwge1xuICAgICAgYWN0aW9uOiBcIm1vdmVcIlxuICAgIH0sIGUuc3dpcGVIYW5kbGVyKSwgZS4kbGlzdC5vbihcInRvdWNoZW5kLnNsaWNrIG1vdXNldXAuc2xpY2tcIiwge1xuICAgICAgYWN0aW9uOiBcImVuZFwiXG4gICAgfSwgZS5zd2lwZUhhbmRsZXIpLCBlLiRsaXN0Lm9uKFwidG91Y2hjYW5jZWwuc2xpY2sgbW91c2VsZWF2ZS5zbGlja1wiLCB7XG4gICAgICBhY3Rpb246IFwiZW5kXCJcbiAgICB9LCBlLnN3aXBlSGFuZGxlciksIGUuJGxpc3Qub24oXCJjbGljay5zbGlja1wiLCBlLmNsaWNrSGFuZGxlciksIGkoZG9jdW1lbnQpLm9uKGUudmlzaWJpbGl0eUNoYW5nZSwgaS5wcm94eShlLnZpc2liaWxpdHksIGUpKSwgZS5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09ICEwICYmIGUuJGxpc3Qub24oXCJrZXlkb3duLnNsaWNrXCIsIGUua2V5SGFuZGxlciksIGUub3B0aW9ucy5mb2N1c09uU2VsZWN0ID09PSAhMCAmJiBpKGUuJHNsaWRlVHJhY2spLmNoaWxkcmVuKCkub24oXCJjbGljay5zbGlja1wiLCBlLnNlbGVjdEhhbmRsZXIpLCBpKHdpbmRvdykub24oXCJvcmllbnRhdGlvbmNoYW5nZS5zbGljay5zbGljay1cIiArIGUuaW5zdGFuY2VVaWQsIGkucHJveHkoZS5vcmllbnRhdGlvbkNoYW5nZSwgZSkpLCBpKHdpbmRvdykub24oXCJyZXNpemUuc2xpY2suc2xpY2stXCIgKyBlLmluc3RhbmNlVWlkLCBpLnByb3h5KGUucmVzaXplLCBlKSksIGkoXCJbZHJhZ2dhYmxlIT10cnVlXVwiLCBlLiRzbGlkZVRyYWNrKS5vbihcImRyYWdzdGFydFwiLCBlLnByZXZlbnREZWZhdWx0KSwgaSh3aW5kb3cpLm9uKFwibG9hZC5zbGljay5zbGljay1cIiArIGUuaW5zdGFuY2VVaWQsIGUuc2V0UG9zaXRpb24pLCBpKGUuc2V0UG9zaXRpb24pO1xuICB9LCBlLnByb3RvdHlwZS5pbml0VUkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzO1xuICAgIGkub3B0aW9ucy5hcnJvd3MgPT09ICEwICYmIGkuc2xpZGVDb3VudCA+IGkub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiYgKGkuJHByZXZBcnJvdy5zaG93KCksIGkuJG5leHRBcnJvdy5zaG93KCkpLCBpLm9wdGlvbnMuZG90cyA9PT0gITAgJiYgaS5zbGlkZUNvdW50ID4gaS5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJiBpLiRkb3RzLnNob3coKTtcbiAgfSwgZS5wcm90b3R5cGUua2V5SGFuZGxlciA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIGkudGFyZ2V0LnRhZ05hbWUubWF0Y2goXCJURVhUQVJFQXxJTlBVVHxTRUxFQ1RcIikgfHwgKDM3ID09PSBpLmtleUNvZGUgJiYgZS5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09ICEwID8gZS5jaGFuZ2VTbGlkZSh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lc3NhZ2U6IGUub3B0aW9ucy5ydGwgPT09ICEwID8gXCJuZXh0XCIgOiBcInByZXZpb3VzXCJcbiAgICAgIH1cbiAgICB9KSA6IDM5ID09PSBpLmtleUNvZGUgJiYgZS5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09ICEwICYmIGUuY2hhbmdlU2xpZGUoe1xuICAgICAgZGF0YToge1xuICAgICAgICBtZXNzYWdlOiBlLm9wdGlvbnMucnRsID09PSAhMCA/IFwicHJldmlvdXNcIiA6IFwibmV4dFwiXG4gICAgICB9XG4gICAgfSkpO1xuICB9LCBlLnByb3RvdHlwZS5sYXp5TG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgIGkoXCJpbWdbZGF0YS1sYXp5XVwiLCBlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSBpKHRoaXMpLFxuICAgICAgICAgIHQgPSBpKHRoaXMpLmF0dHIoXCJkYXRhLWxhenlcIiksXG4gICAgICAgICAgbyA9IGkodGhpcykuYXR0cihcImRhdGEtc3Jjc2V0XCIpLFxuICAgICAgICAgIHMgPSBpKHRoaXMpLmF0dHIoXCJkYXRhLXNpemVzXCIpIHx8IHIuJHNsaWRlci5hdHRyKFwiZGF0YS1zaXplc1wiKSxcbiAgICAgICAgICBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgbi5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZS5hbmltYXRlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LCAxMDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG8gJiYgKGUuYXR0cihcInNyY3NldFwiLCBvKSwgcyAmJiBlLmF0dHIoXCJzaXplc1wiLCBzKSksIGUuYXR0cihcInNyY1wiLCB0KS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSwgMjAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGUucmVtb3ZlQXR0cihcImRhdGEtbGF6eSBkYXRhLXNyY3NldCBkYXRhLXNpemVzXCIpLnJlbW92ZUNsYXNzKFwic2xpY2stbG9hZGluZ1wiKTtcbiAgICAgICAgICAgIH0pLCByLiRzbGlkZXIudHJpZ2dlcihcImxhenlMb2FkZWRcIiwgW3IsIGUsIHRdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUucmVtb3ZlQXR0cihcImRhdGEtbGF6eVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWxvYWRpbmdcIikuYWRkQ2xhc3MoXCJzbGljay1sYXp5bG9hZC1lcnJvclwiKSwgci4kc2xpZGVyLnRyaWdnZXIoXCJsYXp5TG9hZEVycm9yXCIsIFtyLCBlLCB0XSk7XG4gICAgICAgIH0sIG4uc3JjID0gdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdCxcbiAgICAgIG8sXG4gICAgICBzLFxuICAgICAgbixcbiAgICAgIHIgPSB0aGlzO1xuICAgIGlmIChyLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gITAgPyByLm9wdGlvbnMuaW5maW5pdGUgPT09ICEwID8gKHMgPSByLmN1cnJlbnRTbGlkZSArIChyLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMiArIDEpLCBuID0gcyArIHIub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyAyKSA6IChzID0gTWF0aC5tYXgoMCwgci5jdXJyZW50U2xpZGUgLSAoci5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIgKyAxKSksIG4gPSAyICsgKHIub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyICsgMSkgKyByLmN1cnJlbnRTbGlkZSkgOiAocyA9IHIub3B0aW9ucy5pbmZpbml0ZSA/IHIub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyByLmN1cnJlbnRTbGlkZSA6IHIuY3VycmVudFNsaWRlLCBuID0gTWF0aC5jZWlsKHMgKyByLm9wdGlvbnMuc2xpZGVzVG9TaG93KSwgci5vcHRpb25zLmZhZGUgPT09ICEwICYmIChzID4gMCAmJiBzLS0sIG4gPD0gci5zbGlkZUNvdW50ICYmIG4rKykpLCB0ID0gci4kc2xpZGVyLmZpbmQoXCIuc2xpY2stc2xpZGVcIikuc2xpY2UocywgbiksIFwiYW50aWNpcGF0ZWRcIiA9PT0gci5vcHRpb25zLmxhenlMb2FkKSBmb3IgKHZhciBsID0gcyAtIDEsIGQgPSBuLCBhID0gci4kc2xpZGVyLmZpbmQoXCIuc2xpY2stc2xpZGVcIiksIGMgPSAwOyBjIDwgci5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsOyBjKyspIGwgPCAwICYmIChsID0gci5zbGlkZUNvdW50IC0gMSksIHQgPSB0LmFkZChhLmVxKGwpKSwgdCA9IHQuYWRkKGEuZXEoZCkpLCBsLS0sIGQrKztcbiAgICBlKHQpLCByLnNsaWRlQ291bnQgPD0gci5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IChvID0gci4kc2xpZGVyLmZpbmQoXCIuc2xpY2stc2xpZGVcIiksIGUobykpIDogci5jdXJyZW50U2xpZGUgPj0gci5zbGlkZUNvdW50IC0gci5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IChvID0gci4kc2xpZGVyLmZpbmQoXCIuc2xpY2stY2xvbmVkXCIpLnNsaWNlKDAsIHIub3B0aW9ucy5zbGlkZXNUb1Nob3cpLCBlKG8pKSA6IDAgPT09IHIuY3VycmVudFNsaWRlICYmIChvID0gci4kc2xpZGVyLmZpbmQoXCIuc2xpY2stY2xvbmVkXCIpLnNsaWNlKHIub3B0aW9ucy5zbGlkZXNUb1Nob3cgKiAtMSksIGUobykpO1xuICB9LCBlLnByb3RvdHlwZS5sb2FkU2xpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcztcbiAgICBpLnNldFBvc2l0aW9uKCksIGkuJHNsaWRlVHJhY2suY3NzKHtcbiAgICAgIG9wYWNpdHk6IDFcbiAgICB9KSwgaS4kc2xpZGVyLnJlbW92ZUNsYXNzKFwic2xpY2stbG9hZGluZ1wiKSwgaS5pbml0VUkoKSwgXCJwcm9ncmVzc2l2ZVwiID09PSBpLm9wdGlvbnMubGF6eUxvYWQgJiYgaS5wcm9ncmVzc2l2ZUxhenlMb2FkKCk7XG4gIH0sIGUucHJvdG90eXBlLm5leHQgPSBlLnByb3RvdHlwZS5zbGlja05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzO1xuICAgIGkuY2hhbmdlU2xpZGUoe1xuICAgICAgZGF0YToge1xuICAgICAgICBtZXNzYWdlOiBcIm5leHRcIlxuICAgICAgfVxuICAgIH0pO1xuICB9LCBlLnByb3RvdHlwZS5vcmllbnRhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXM7XG4gICAgaS5jaGVja1Jlc3BvbnNpdmUoKSwgaS5zZXRQb3NpdGlvbigpO1xuICB9LCBlLnByb3RvdHlwZS5wYXVzZSA9IGUucHJvdG90eXBlLnNsaWNrUGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzO1xuICAgIGkuYXV0b1BsYXlDbGVhcigpLCBpLnBhdXNlZCA9ICEwO1xuICB9LCBlLnByb3RvdHlwZS5wbGF5ID0gZS5wcm90b3R5cGUuc2xpY2tQbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcztcbiAgICBpLmF1dG9QbGF5KCksIGkub3B0aW9ucy5hdXRvcGxheSA9ICEwLCBpLnBhdXNlZCA9ICExLCBpLmZvY3Vzc2VkID0gITEsIGkuaW50ZXJydXB0ZWQgPSAhMTtcbiAgfSwgZS5wcm90b3R5cGUucG9zdFNsaWRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdCA9IHRoaXM7XG4gICAgaWYgKCF0LnVuc2xpY2tlZCAmJiAodC4kc2xpZGVyLnRyaWdnZXIoXCJhZnRlckNoYW5nZVwiLCBbdCwgZV0pLCB0LmFuaW1hdGluZyA9ICExLCB0LnNsaWRlQ291bnQgPiB0Lm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIHQuc2V0UG9zaXRpb24oKSwgdC5zd2lwZUxlZnQgPSBudWxsLCB0Lm9wdGlvbnMuYXV0b3BsYXkgJiYgdC5hdXRvUGxheSgpLCB0Lm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gITAgJiYgKHQuaW5pdEFEQSgpLCB0Lm9wdGlvbnMuZm9jdXNPbkNoYW5nZSkpKSB7XG4gICAgICB2YXIgbyA9IGkodC4kc2xpZGVzLmdldCh0LmN1cnJlbnRTbGlkZSkpO1xuICAgICAgby5hdHRyKFwidGFiaW5kZXhcIiwgMCkuZm9jdXMoKTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLnByZXYgPSBlLnByb3RvdHlwZS5zbGlja1ByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzO1xuICAgIGkuY2hhbmdlU2xpZGUoe1xuICAgICAgZGF0YToge1xuICAgICAgICBtZXNzYWdlOiBcInByZXZpb3VzXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZS5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoaSkge1xuICAgIGkucHJldmVudERlZmF1bHQoKTtcbiAgfSwgZS5wcm90b3R5cGUucHJvZ3Jlc3NpdmVMYXp5TG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSA9IGUgfHwgMTtcbiAgICB2YXIgdCxcbiAgICAgIG8sXG4gICAgICBzLFxuICAgICAgbixcbiAgICAgIHIsXG4gICAgICBsID0gdGhpcyxcbiAgICAgIGQgPSBpKFwiaW1nW2RhdGEtbGF6eV1cIiwgbC4kc2xpZGVyKTtcbiAgICBkLmxlbmd0aCA/ICh0ID0gZC5maXJzdCgpLCBvID0gdC5hdHRyKFwiZGF0YS1sYXp5XCIpLCBzID0gdC5hdHRyKFwiZGF0YS1zcmNzZXRcIiksIG4gPSB0LmF0dHIoXCJkYXRhLXNpemVzXCIpIHx8IGwuJHNsaWRlci5hdHRyKFwiZGF0YS1zaXplc1wiKSwgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiksIHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcyAmJiAodC5hdHRyKFwic3Jjc2V0XCIsIHMpLCBuICYmIHQuYXR0cihcInNpemVzXCIsIG4pKSwgdC5hdHRyKFwic3JjXCIsIG8pLnJlbW92ZUF0dHIoXCJkYXRhLWxhenkgZGF0YS1zcmNzZXQgZGF0YS1zaXplc1wiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWxvYWRpbmdcIiksIGwub3B0aW9ucy5hZGFwdGl2ZUhlaWdodCA9PT0gITAgJiYgbC5zZXRQb3NpdGlvbigpLCBsLiRzbGlkZXIudHJpZ2dlcihcImxhenlMb2FkZWRcIiwgW2wsIHQsIG9dKSwgbC5wcm9ncmVzc2l2ZUxhenlMb2FkKCk7XG4gICAgfSwgci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgZSA8IDMgPyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbC5wcm9ncmVzc2l2ZUxhenlMb2FkKGUgKyAxKTtcbiAgICAgIH0sIDUwMCkgOiAodC5yZW1vdmVBdHRyKFwiZGF0YS1sYXp5XCIpLnJlbW92ZUNsYXNzKFwic2xpY2stbG9hZGluZ1wiKS5hZGRDbGFzcyhcInNsaWNrLWxhenlsb2FkLWVycm9yXCIpLCBsLiRzbGlkZXIudHJpZ2dlcihcImxhenlMb2FkRXJyb3JcIiwgW2wsIHQsIG9dKSwgbC5wcm9ncmVzc2l2ZUxhenlMb2FkKCkpO1xuICAgIH0sIHIuc3JjID0gbykgOiBsLiRzbGlkZXIudHJpZ2dlcihcImFsbEltYWdlc0xvYWRlZFwiLCBbbF0pO1xuICB9LCBlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdCxcbiAgICAgIG8sXG4gICAgICBzID0gdGhpcztcbiAgICBvID0gcy5zbGlkZUNvdW50IC0gcy5vcHRpb25zLnNsaWRlc1RvU2hvdywgIXMub3B0aW9ucy5pbmZpbml0ZSAmJiBzLmN1cnJlbnRTbGlkZSA+IG8gJiYgKHMuY3VycmVudFNsaWRlID0gbyksIHMuc2xpZGVDb3VudCA8PSBzLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIChzLmN1cnJlbnRTbGlkZSA9IDApLCB0ID0gcy5jdXJyZW50U2xpZGUsIHMuZGVzdHJveSghMCksIGkuZXh0ZW5kKHMsIHMuaW5pdGlhbHMsIHtcbiAgICAgIGN1cnJlbnRTbGlkZTogdFxuICAgIH0pLCBzLmluaXQoKSwgZSB8fCBzLmNoYW5nZVNsaWRlKHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWVzc2FnZTogXCJpbmRleFwiLFxuICAgICAgICBpbmRleDogdFxuICAgICAgfVxuICAgIH0sICExKTtcbiAgfSwgZS5wcm90b3R5cGUucmVnaXN0ZXJCcmVha3BvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSxcbiAgICAgIHQsXG4gICAgICBvLFxuICAgICAgcyA9IHRoaXMsXG4gICAgICBuID0gcy5vcHRpb25zLnJlc3BvbnNpdmUgfHwgbnVsbDtcbiAgICBpZiAoXCJhcnJheVwiID09PSBpLnR5cGUobikgJiYgbi5sZW5ndGgpIHtcbiAgICAgIHMucmVzcG9uZFRvID0gcy5vcHRpb25zLnJlc3BvbmRUbyB8fCBcIndpbmRvd1wiO1xuICAgICAgZm9yIChlIGluIG4pIGlmIChvID0gcy5icmVha3BvaW50cy5sZW5ndGggLSAxLCBuLmhhc093blByb3BlcnR5KGUpKSB7XG4gICAgICAgIGZvciAodCA9IG5bZV0uYnJlYWtwb2ludDsgbyA+PSAwOykgcy5icmVha3BvaW50c1tvXSAmJiBzLmJyZWFrcG9pbnRzW29dID09PSB0ICYmIHMuYnJlYWtwb2ludHMuc3BsaWNlKG8sIDEpLCBvLS07XG4gICAgICAgIHMuYnJlYWtwb2ludHMucHVzaCh0KSwgcy5icmVha3BvaW50U2V0dGluZ3NbdF0gPSBuW2VdLnNldHRpbmdzO1xuICAgICAgfVxuICAgICAgcy5icmVha3BvaW50cy5zb3J0KGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgIHJldHVybiBzLm9wdGlvbnMubW9iaWxlRmlyc3QgPyBpIC0gZSA6IGUgLSBpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5yZWluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIGUuJHNsaWRlcyA9IGUuJHNsaWRlVHJhY2suY2hpbGRyZW4oZS5vcHRpb25zLnNsaWRlKS5hZGRDbGFzcyhcInNsaWNrLXNsaWRlXCIpLCBlLnNsaWRlQ291bnQgPSBlLiRzbGlkZXMubGVuZ3RoLCBlLmN1cnJlbnRTbGlkZSA+PSBlLnNsaWRlQ291bnQgJiYgMCAhPT0gZS5jdXJyZW50U2xpZGUgJiYgKGUuY3VycmVudFNsaWRlID0gZS5jdXJyZW50U2xpZGUgLSBlLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpLCBlLnNsaWRlQ291bnQgPD0gZS5vcHRpb25zLnNsaWRlc1RvU2hvdyAmJiAoZS5jdXJyZW50U2xpZGUgPSAwKSwgZS5yZWdpc3RlckJyZWFrcG9pbnRzKCksIGUuc2V0UHJvcHMoKSwgZS5zZXR1cEluZmluaXRlKCksIGUuYnVpbGRBcnJvd3MoKSwgZS51cGRhdGVBcnJvd3MoKSwgZS5pbml0QXJyb3dFdmVudHMoKSwgZS5idWlsZERvdHMoKSwgZS51cGRhdGVEb3RzKCksIGUuaW5pdERvdEV2ZW50cygpLCBlLmNsZWFuVXBTbGlkZUV2ZW50cygpLCBlLmluaXRTbGlkZUV2ZW50cygpLCBlLmNoZWNrUmVzcG9uc2l2ZSghMSwgITApLCBlLm9wdGlvbnMuZm9jdXNPblNlbGVjdCA9PT0gITAgJiYgaShlLiRzbGlkZVRyYWNrKS5jaGlsZHJlbigpLm9uKFwiY2xpY2suc2xpY2tcIiwgZS5zZWxlY3RIYW5kbGVyKSwgZS5zZXRTbGlkZUNsYXNzZXMoXCJudW1iZXJcIiA9PSB0eXBlb2YgZS5jdXJyZW50U2xpZGUgPyBlLmN1cnJlbnRTbGlkZSA6IDApLCBlLnNldFBvc2l0aW9uKCksIGUuZm9jdXNIYW5kbGVyKCksIGUucGF1c2VkID0gIWUub3B0aW9ucy5hdXRvcGxheSwgZS5hdXRvUGxheSgpLCBlLiRzbGlkZXIudHJpZ2dlcihcInJlSW5pdFwiLCBbZV0pO1xuICB9LCBlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIGkod2luZG93KS53aWR0aCgpICE9PSBlLndpbmRvd1dpZHRoICYmIChjbGVhclRpbWVvdXQoZS53aW5kb3dEZWxheSksIGUud2luZG93RGVsYXkgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBlLndpbmRvd1dpZHRoID0gaSh3aW5kb3cpLndpZHRoKCksIGUuY2hlY2tSZXNwb25zaXZlKCksIGUudW5zbGlja2VkIHx8IGUuc2V0UG9zaXRpb24oKTtcbiAgICB9LCA1MCkpO1xuICB9LCBlLnByb3RvdHlwZS5yZW1vdmVTbGlkZSA9IGUucHJvdG90eXBlLnNsaWNrUmVtb3ZlID0gZnVuY3Rpb24gKGksIGUsIHQpIHtcbiAgICB2YXIgbyA9IHRoaXM7XG4gICAgcmV0dXJuIFwiYm9vbGVhblwiID09IHR5cGVvZiBpID8gKGUgPSBpLCBpID0gZSA9PT0gITAgPyAwIDogby5zbGlkZUNvdW50IC0gMSkgOiBpID0gZSA9PT0gITAgPyAtLWkgOiBpLCAhKG8uc2xpZGVDb3VudCA8IDEgfHwgaSA8IDAgfHwgaSA+IG8uc2xpZGVDb3VudCAtIDEpICYmIChvLnVubG9hZCgpLCB0ID09PSAhMCA/IG8uJHNsaWRlVHJhY2suY2hpbGRyZW4oKS5yZW1vdmUoKSA6IG8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5lcShpKS5yZW1vdmUoKSwgby4kc2xpZGVzID0gby4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLCBvLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCksIG8uJHNsaWRlVHJhY2suYXBwZW5kKG8uJHNsaWRlcyksIG8uJHNsaWRlc0NhY2hlID0gby4kc2xpZGVzLCB2b2lkIG8ucmVpbml0KCkpO1xuICB9LCBlLnByb3RvdHlwZS5zZXRDU1MgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBlLFxuICAgICAgdCxcbiAgICAgIG8gPSB0aGlzLFxuICAgICAgcyA9IHt9O1xuICAgIG8ub3B0aW9ucy5ydGwgPT09ICEwICYmIChpID0gLWkpLCBlID0gXCJsZWZ0XCIgPT0gby5wb3NpdGlvblByb3AgPyBNYXRoLmNlaWwoaSkgKyBcInB4XCIgOiBcIjBweFwiLCB0ID0gXCJ0b3BcIiA9PSBvLnBvc2l0aW9uUHJvcCA/IE1hdGguY2VpbChpKSArIFwicHhcIiA6IFwiMHB4XCIsIHNbby5wb3NpdGlvblByb3BdID0gaSwgby50cmFuc2Zvcm1zRW5hYmxlZCA9PT0gITEgPyBvLiRzbGlkZVRyYWNrLmNzcyhzKSA6IChzID0ge30sIG8uY3NzVHJhbnNpdGlvbnMgPT09ICExID8gKHNbby5hbmltVHlwZV0gPSBcInRyYW5zbGF0ZShcIiArIGUgKyBcIiwgXCIgKyB0ICsgXCIpXCIsIG8uJHNsaWRlVHJhY2suY3NzKHMpKSA6IChzW28uYW5pbVR5cGVdID0gXCJ0cmFuc2xhdGUzZChcIiArIGUgKyBcIiwgXCIgKyB0ICsgXCIsIDBweClcIiwgby4kc2xpZGVUcmFjay5jc3MocykpKTtcbiAgfSwgZS5wcm90b3R5cGUuc2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXM7XG4gICAgaS5vcHRpb25zLnZlcnRpY2FsID09PSAhMSA/IGkub3B0aW9ucy5jZW50ZXJNb2RlID09PSAhMCAmJiBpLiRsaXN0LmNzcyh7XG4gICAgICBwYWRkaW5nOiBcIjBweCBcIiArIGkub3B0aW9ucy5jZW50ZXJQYWRkaW5nXG4gICAgfSkgOiAoaS4kbGlzdC5oZWlnaHQoaS4kc2xpZGVzLmZpcnN0KCkub3V0ZXJIZWlnaHQoITApICogaS5vcHRpb25zLnNsaWRlc1RvU2hvdyksIGkub3B0aW9ucy5jZW50ZXJNb2RlID09PSAhMCAmJiBpLiRsaXN0LmNzcyh7XG4gICAgICBwYWRkaW5nOiBpLm9wdGlvbnMuY2VudGVyUGFkZGluZyArIFwiIDBweFwiXG4gICAgfSkpLCBpLmxpc3RXaWR0aCA9IGkuJGxpc3Qud2lkdGgoKSwgaS5saXN0SGVpZ2h0ID0gaS4kbGlzdC5oZWlnaHQoKSwgaS5vcHRpb25zLnZlcnRpY2FsID09PSAhMSAmJiBpLm9wdGlvbnMudmFyaWFibGVXaWR0aCA9PT0gITEgPyAoaS5zbGlkZVdpZHRoID0gTWF0aC5jZWlsKGkubGlzdFdpZHRoIC8gaS5vcHRpb25zLnNsaWRlc1RvU2hvdyksIGkuJHNsaWRlVHJhY2sud2lkdGgoTWF0aC5jZWlsKGkuc2xpZGVXaWR0aCAqIGkuJHNsaWRlVHJhY2suY2hpbGRyZW4oXCIuc2xpY2stc2xpZGVcIikubGVuZ3RoKSkpIDogaS5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09ICEwID8gaS4kc2xpZGVUcmFjay53aWR0aCg1ZTMgKiBpLnNsaWRlQ291bnQpIDogKGkuc2xpZGVXaWR0aCA9IE1hdGguY2VpbChpLmxpc3RXaWR0aCksIGkuJHNsaWRlVHJhY2suaGVpZ2h0KE1hdGguY2VpbChpLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCghMCkgKiBpLiRzbGlkZVRyYWNrLmNoaWxkcmVuKFwiLnNsaWNrLXNsaWRlXCIpLmxlbmd0aCkpKTtcbiAgICB2YXIgZSA9IGkuJHNsaWRlcy5maXJzdCgpLm91dGVyV2lkdGgoITApIC0gaS4kc2xpZGVzLmZpcnN0KCkud2lkdGgoKTtcbiAgICBpLm9wdGlvbnMudmFyaWFibGVXaWR0aCA9PT0gITEgJiYgaS4kc2xpZGVUcmFjay5jaGlsZHJlbihcIi5zbGljay1zbGlkZVwiKS53aWR0aChpLnNsaWRlV2lkdGggLSBlKTtcbiAgfSwgZS5wcm90b3R5cGUuc2V0RmFkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSxcbiAgICAgIHQgPSB0aGlzO1xuICAgIHQuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uIChvLCBzKSB7XG4gICAgICBlID0gdC5zbGlkZVdpZHRoICogbyAqIC0xLCB0Lm9wdGlvbnMucnRsID09PSAhMCA/IGkocykuY3NzKHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgcmlnaHQ6IGUsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgekluZGV4OiB0Lm9wdGlvbnMuekluZGV4IC0gMixcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSkgOiBpKHMpLmNzcyh7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIGxlZnQ6IGUsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgekluZGV4OiB0Lm9wdGlvbnMuekluZGV4IC0gMixcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSk7XG4gICAgfSksIHQuJHNsaWRlcy5lcSh0LmN1cnJlbnRTbGlkZSkuY3NzKHtcbiAgICAgIHpJbmRleDogdC5vcHRpb25zLnpJbmRleCAtIDEsXG4gICAgICBvcGFjaXR5OiAxXG4gICAgfSk7XG4gIH0sIGUucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXM7XG4gICAgaWYgKDEgPT09IGkub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiYgaS5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0ID09PSAhMCAmJiBpLm9wdGlvbnMudmVydGljYWwgPT09ICExKSB7XG4gICAgICB2YXIgZSA9IGkuJHNsaWRlcy5lcShpLmN1cnJlbnRTbGlkZSkub3V0ZXJIZWlnaHQoITApO1xuICAgICAgaS4kbGlzdC5jc3MoXCJoZWlnaHRcIiwgZSk7XG4gICAgfVxuICB9LCBlLnByb3RvdHlwZS5zZXRPcHRpb24gPSBlLnByb3RvdHlwZS5zbGlja1NldE9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSxcbiAgICAgIHQsXG4gICAgICBvLFxuICAgICAgcyxcbiAgICAgIG4sXG4gICAgICByID0gdGhpcyxcbiAgICAgIGwgPSAhMTtcbiAgICBpZiAoXCJvYmplY3RcIiA9PT0gaS50eXBlKGFyZ3VtZW50c1swXSkgPyAobyA9IGFyZ3VtZW50c1swXSwgbCA9IGFyZ3VtZW50c1sxXSwgbiA9IFwibXVsdGlwbGVcIikgOiBcInN0cmluZ1wiID09PSBpLnR5cGUoYXJndW1lbnRzWzBdKSAmJiAobyA9IGFyZ3VtZW50c1swXSwgcyA9IGFyZ3VtZW50c1sxXSwgbCA9IGFyZ3VtZW50c1syXSwgXCJyZXNwb25zaXZlXCIgPT09IGFyZ3VtZW50c1swXSAmJiBcImFycmF5XCIgPT09IGkudHlwZShhcmd1bWVudHNbMV0pID8gbiA9IFwicmVzcG9uc2l2ZVwiIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYXJndW1lbnRzWzFdICYmIChuID0gXCJzaW5nbGVcIikpLCBcInNpbmdsZVwiID09PSBuKSByLm9wdGlvbnNbb10gPSBzO2Vsc2UgaWYgKFwibXVsdGlwbGVcIiA9PT0gbikgaS5lYWNoKG8sIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICByLm9wdGlvbnNbaV0gPSBlO1xuICAgIH0pO2Vsc2UgaWYgKFwicmVzcG9uc2l2ZVwiID09PSBuKSBmb3IgKHQgaW4gcykgaWYgKFwiYXJyYXlcIiAhPT0gaS50eXBlKHIub3B0aW9ucy5yZXNwb25zaXZlKSkgci5vcHRpb25zLnJlc3BvbnNpdmUgPSBbc1t0XV07ZWxzZSB7XG4gICAgICBmb3IgKGUgPSByLm9wdGlvbnMucmVzcG9uc2l2ZS5sZW5ndGggLSAxOyBlID49IDA7KSByLm9wdGlvbnMucmVzcG9uc2l2ZVtlXS5icmVha3BvaW50ID09PSBzW3RdLmJyZWFrcG9pbnQgJiYgci5vcHRpb25zLnJlc3BvbnNpdmUuc3BsaWNlKGUsIDEpLCBlLS07XG4gICAgICByLm9wdGlvbnMucmVzcG9uc2l2ZS5wdXNoKHNbdF0pO1xuICAgIH1cbiAgICBsICYmIChyLnVubG9hZCgpLCByLnJlaW5pdCgpKTtcbiAgfSwgZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzO1xuICAgIGkuc2V0RGltZW5zaW9ucygpLCBpLnNldEhlaWdodCgpLCBpLm9wdGlvbnMuZmFkZSA9PT0gITEgPyBpLnNldENTUyhpLmdldExlZnQoaS5jdXJyZW50U2xpZGUpKSA6IGkuc2V0RmFkZSgpLCBpLiRzbGlkZXIudHJpZ2dlcihcInNldFBvc2l0aW9uXCIsIFtpXSk7XG4gIH0sIGUucHJvdG90eXBlLnNldFByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcyxcbiAgICAgIGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgIGkucG9zaXRpb25Qcm9wID0gaS5vcHRpb25zLnZlcnRpY2FsID09PSAhMCA/IFwidG9wXCIgOiBcImxlZnRcIiwgXCJ0b3BcIiA9PT0gaS5wb3NpdGlvblByb3AgPyBpLiRzbGlkZXIuYWRkQ2xhc3MoXCJzbGljay12ZXJ0aWNhbFwiKSA6IGkuJHNsaWRlci5yZW1vdmVDbGFzcyhcInNsaWNrLXZlcnRpY2FsXCIpLCB2b2lkIDAgPT09IGUuV2Via2l0VHJhbnNpdGlvbiAmJiB2b2lkIDAgPT09IGUuTW96VHJhbnNpdGlvbiAmJiB2b2lkIDAgPT09IGUubXNUcmFuc2l0aW9uIHx8IGkub3B0aW9ucy51c2VDU1MgPT09ICEwICYmIChpLmNzc1RyYW5zaXRpb25zID0gITApLCBpLm9wdGlvbnMuZmFkZSAmJiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgaS5vcHRpb25zLnpJbmRleCA/IGkub3B0aW9ucy56SW5kZXggPCAzICYmIChpLm9wdGlvbnMuekluZGV4ID0gMykgOiBpLm9wdGlvbnMuekluZGV4ID0gaS5kZWZhdWx0cy56SW5kZXgpLCB2b2lkIDAgIT09IGUuT1RyYW5zZm9ybSAmJiAoaS5hbmltVHlwZSA9IFwiT1RyYW5zZm9ybVwiLCBpLnRyYW5zZm9ybVR5cGUgPSBcIi1vLXRyYW5zZm9ybVwiLCBpLnRyYW5zaXRpb25UeXBlID0gXCJPVHJhbnNpdGlvblwiLCB2b2lkIDAgPT09IGUucGVyc3BlY3RpdmVQcm9wZXJ0eSAmJiB2b2lkIDAgPT09IGUud2Via2l0UGVyc3BlY3RpdmUgJiYgKGkuYW5pbVR5cGUgPSAhMSkpLCB2b2lkIDAgIT09IGUuTW96VHJhbnNmb3JtICYmIChpLmFuaW1UeXBlID0gXCJNb3pUcmFuc2Zvcm1cIiwgaS50cmFuc2Zvcm1UeXBlID0gXCItbW96LXRyYW5zZm9ybVwiLCBpLnRyYW5zaXRpb25UeXBlID0gXCJNb3pUcmFuc2l0aW9uXCIsIHZvaWQgMCA9PT0gZS5wZXJzcGVjdGl2ZVByb3BlcnR5ICYmIHZvaWQgMCA9PT0gZS5Nb3pQZXJzcGVjdGl2ZSAmJiAoaS5hbmltVHlwZSA9ICExKSksIHZvaWQgMCAhPT0gZS53ZWJraXRUcmFuc2Zvcm0gJiYgKGkuYW5pbVR5cGUgPSBcIndlYmtpdFRyYW5zZm9ybVwiLCBpLnRyYW5zZm9ybVR5cGUgPSBcIi13ZWJraXQtdHJhbnNmb3JtXCIsIGkudHJhbnNpdGlvblR5cGUgPSBcIndlYmtpdFRyYW5zaXRpb25cIiwgdm9pZCAwID09PSBlLnBlcnNwZWN0aXZlUHJvcGVydHkgJiYgdm9pZCAwID09PSBlLndlYmtpdFBlcnNwZWN0aXZlICYmIChpLmFuaW1UeXBlID0gITEpKSwgdm9pZCAwICE9PSBlLm1zVHJhbnNmb3JtICYmIChpLmFuaW1UeXBlID0gXCJtc1RyYW5zZm9ybVwiLCBpLnRyYW5zZm9ybVR5cGUgPSBcIi1tcy10cmFuc2Zvcm1cIiwgaS50cmFuc2l0aW9uVHlwZSA9IFwibXNUcmFuc2l0aW9uXCIsIHZvaWQgMCA9PT0gZS5tc1RyYW5zZm9ybSAmJiAoaS5hbmltVHlwZSA9ICExKSksIHZvaWQgMCAhPT0gZS50cmFuc2Zvcm0gJiYgaS5hbmltVHlwZSAhPT0gITEgJiYgKGkuYW5pbVR5cGUgPSBcInRyYW5zZm9ybVwiLCBpLnRyYW5zZm9ybVR5cGUgPSBcInRyYW5zZm9ybVwiLCBpLnRyYW5zaXRpb25UeXBlID0gXCJ0cmFuc2l0aW9uXCIpLCBpLnRyYW5zZm9ybXNFbmFibGVkID0gaS5vcHRpb25zLnVzZVRyYW5zZm9ybSAmJiBudWxsICE9PSBpLmFuaW1UeXBlICYmIGkuYW5pbVR5cGUgIT09ICExO1xuICB9LCBlLnByb3RvdHlwZS5zZXRTbGlkZUNsYXNzZXMgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBlLFxuICAgICAgdCxcbiAgICAgIG8sXG4gICAgICBzLFxuICAgICAgbiA9IHRoaXM7XG4gICAgaWYgKHQgPSBuLiRzbGlkZXIuZmluZChcIi5zbGljay1zbGlkZVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWFjdGl2ZSBzbGljay1jZW50ZXIgc2xpY2stY3VycmVudFwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLCBuLiRzbGlkZXMuZXEoaSkuYWRkQ2xhc3MoXCJzbGljay1jdXJyZW50XCIpLCBuLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gITApIHtcbiAgICAgIHZhciByID0gbi5vcHRpb25zLnNsaWRlc1RvU2hvdyAlIDIgPT09IDAgPyAxIDogMDtcbiAgICAgIGUgPSBNYXRoLmZsb29yKG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKSwgbi5vcHRpb25zLmluZmluaXRlID09PSAhMCAmJiAoaSA+PSBlICYmIGkgPD0gbi5zbGlkZUNvdW50IC0gMSAtIGUgPyBuLiRzbGlkZXMuc2xpY2UoaSAtIGUgKyByLCBpICsgZSArIDEpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpIDogKG8gPSBuLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgaSwgdC5zbGljZShvIC0gZSArIDEgKyByLCBvICsgZSArIDIpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpKSwgMCA9PT0gaSA/IHQuZXEodC5sZW5ndGggLSAxIC0gbi5vcHRpb25zLnNsaWRlc1RvU2hvdykuYWRkQ2xhc3MoXCJzbGljay1jZW50ZXJcIikgOiBpID09PSBuLnNsaWRlQ291bnQgLSAxICYmIHQuZXEobi5vcHRpb25zLnNsaWRlc1RvU2hvdykuYWRkQ2xhc3MoXCJzbGljay1jZW50ZXJcIikpLCBuLiRzbGlkZXMuZXEoaSkuYWRkQ2xhc3MoXCJzbGljay1jZW50ZXJcIik7XG4gICAgfSBlbHNlIGkgPj0gMCAmJiBpIDw9IG4uc2xpZGVDb3VudCAtIG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPyBuLiRzbGlkZXMuc2xpY2UoaSwgaSArIG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpIDogdC5sZW5ndGggPD0gbi5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IHQuYWRkQ2xhc3MoXCJzbGljay1hY3RpdmVcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsIFwiZmFsc2VcIikgOiAocyA9IG4uc2xpZGVDb3VudCAlIG4ub3B0aW9ucy5zbGlkZXNUb1Nob3csIG8gPSBuLm9wdGlvbnMuaW5maW5pdGUgPT09ICEwID8gbi5vcHRpb25zLnNsaWRlc1RvU2hvdyArIGkgOiBpLCBuLm9wdGlvbnMuc2xpZGVzVG9TaG93ID09IG4ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAmJiBuLnNsaWRlQ291bnQgLSBpIDwgbi5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IHQuc2xpY2UobyAtIChuLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gcyksIG8gKyBzKS5hZGRDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwgXCJmYWxzZVwiKSA6IHQuc2xpY2UobywgbyArIG4ub3B0aW9ucy5zbGlkZXNUb1Nob3cpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpLmF0dHIoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpKTtcbiAgICBcIm9uZGVtYW5kXCIgIT09IG4ub3B0aW9ucy5sYXp5TG9hZCAmJiBcImFudGljaXBhdGVkXCIgIT09IG4ub3B0aW9ucy5sYXp5TG9hZCB8fCBuLmxhenlMb2FkKCk7XG4gIH0sIGUucHJvdG90eXBlLnNldHVwSW5maW5pdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUsXG4gICAgICB0LFxuICAgICAgbyxcbiAgICAgIHMgPSB0aGlzO1xuICAgIGlmIChzLm9wdGlvbnMuZmFkZSA9PT0gITAgJiYgKHMub3B0aW9ucy5jZW50ZXJNb2RlID0gITEpLCBzLm9wdGlvbnMuaW5maW5pdGUgPT09ICEwICYmIHMub3B0aW9ucy5mYWRlID09PSAhMSAmJiAodCA9IG51bGwsIHMuc2xpZGVDb3VudCA+IHMub3B0aW9ucy5zbGlkZXNUb1Nob3cpKSB7XG4gICAgICBmb3IgKG8gPSBzLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gITAgPyBzLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgMSA6IHMub3B0aW9ucy5zbGlkZXNUb1Nob3csIGUgPSBzLnNsaWRlQ291bnQ7IGUgPiBzLnNsaWRlQ291bnQgLSBvOyBlIC09IDEpIHQgPSBlIC0gMSwgaShzLiRzbGlkZXNbdF0pLmNsb25lKCEwKS5hdHRyKFwiaWRcIiwgXCJcIikuYXR0cihcImRhdGEtc2xpY2staW5kZXhcIiwgdCAtIHMuc2xpZGVDb3VudCkucHJlcGVuZFRvKHMuJHNsaWRlVHJhY2spLmFkZENsYXNzKFwic2xpY2stY2xvbmVkXCIpO1xuICAgICAgZm9yIChlID0gMDsgZSA8IG8gKyBzLnNsaWRlQ291bnQ7IGUgKz0gMSkgdCA9IGUsIGkocy4kc2xpZGVzW3RdKS5jbG9uZSghMCkuYXR0cihcImlkXCIsIFwiXCIpLmF0dHIoXCJkYXRhLXNsaWNrLWluZGV4XCIsIHQgKyBzLnNsaWRlQ291bnQpLmFwcGVuZFRvKHMuJHNsaWRlVHJhY2spLmFkZENsYXNzKFwic2xpY2stY2xvbmVkXCIpO1xuICAgICAgcy4kc2xpZGVUcmFjay5maW5kKFwiLnNsaWNrLWNsb25lZFwiKS5maW5kKFwiW2lkXVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaSh0aGlzKS5hdHRyKFwiaWRcIiwgXCJcIik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIGkgfHwgZS5hdXRvUGxheSgpLCBlLmludGVycnVwdGVkID0gaTtcbiAgfSwgZS5wcm90b3R5cGUuc2VsZWN0SGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHQgPSB0aGlzLFxuICAgICAgbyA9IGkoZS50YXJnZXQpLmlzKFwiLnNsaWNrLXNsaWRlXCIpID8gaShlLnRhcmdldCkgOiBpKGUudGFyZ2V0KS5wYXJlbnRzKFwiLnNsaWNrLXNsaWRlXCIpLFxuICAgICAgcyA9IHBhcnNlSW50KG8uYXR0cihcImRhdGEtc2xpY2staW5kZXhcIikpO1xuICAgIHJldHVybiBzIHx8IChzID0gMCksIHQuc2xpZGVDb3VudCA8PSB0Lm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gdm9pZCB0LnNsaWRlSGFuZGxlcihzLCAhMSwgITApIDogdm9pZCB0LnNsaWRlSGFuZGxlcihzKTtcbiAgfSwgZS5wcm90b3R5cGUuc2xpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGksIGUsIHQpIHtcbiAgICB2YXIgbyxcbiAgICAgIHMsXG4gICAgICBuLFxuICAgICAgcixcbiAgICAgIGwsXG4gICAgICBkID0gbnVsbCxcbiAgICAgIGEgPSB0aGlzO1xuICAgIGlmIChlID0gZSB8fCAhMSwgIShhLmFuaW1hdGluZyA9PT0gITAgJiYgYS5vcHRpb25zLndhaXRGb3JBbmltYXRlID09PSAhMCB8fCBhLm9wdGlvbnMuZmFkZSA9PT0gITAgJiYgYS5jdXJyZW50U2xpZGUgPT09IGkpKSByZXR1cm4gZSA9PT0gITEgJiYgYS5hc05hdkZvcihpKSwgbyA9IGksIGQgPSBhLmdldExlZnQobyksIHIgPSBhLmdldExlZnQoYS5jdXJyZW50U2xpZGUpLCBhLmN1cnJlbnRMZWZ0ID0gbnVsbCA9PT0gYS5zd2lwZUxlZnQgPyByIDogYS5zd2lwZUxlZnQsIGEub3B0aW9ucy5pbmZpbml0ZSA9PT0gITEgJiYgYS5vcHRpb25zLmNlbnRlck1vZGUgPT09ICExICYmIChpIDwgMCB8fCBpID4gYS5nZXREb3RDb3VudCgpICogYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSA/IHZvaWQgKGEub3B0aW9ucy5mYWRlID09PSAhMSAmJiAobyA9IGEuY3VycmVudFNsaWRlLCB0ICE9PSAhMCAmJiBhLnNsaWRlQ291bnQgPiBhLm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gYS5hbmltYXRlU2xpZGUociwgZnVuY3Rpb24gKCkge1xuICAgICAgYS5wb3N0U2xpZGUobyk7XG4gICAgfSkgOiBhLnBvc3RTbGlkZShvKSkpIDogYS5vcHRpb25zLmluZmluaXRlID09PSAhMSAmJiBhLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gITAgJiYgKGkgPCAwIHx8IGkgPiBhLnNsaWRlQ291bnQgLSBhLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpID8gdm9pZCAoYS5vcHRpb25zLmZhZGUgPT09ICExICYmIChvID0gYS5jdXJyZW50U2xpZGUsIHQgIT09ICEwICYmIGEuc2xpZGVDb3VudCA+IGEub3B0aW9ucy5zbGlkZXNUb1Nob3cgPyBhLmFuaW1hdGVTbGlkZShyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhLnBvc3RTbGlkZShvKTtcbiAgICB9KSA6IGEucG9zdFNsaWRlKG8pKSkgOiAoYS5vcHRpb25zLmF1dG9wbGF5ICYmIGNsZWFySW50ZXJ2YWwoYS5hdXRvUGxheVRpbWVyKSwgcyA9IG8gPCAwID8gYS5zbGlkZUNvdW50ICUgYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwID8gYS5zbGlkZUNvdW50IC0gYS5zbGlkZUNvdW50ICUgYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogYS5zbGlkZUNvdW50ICsgbyA6IG8gPj0gYS5zbGlkZUNvdW50ID8gYS5zbGlkZUNvdW50ICUgYS5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwID8gMCA6IG8gLSBhLnNsaWRlQ291bnQgOiBvLCBhLmFuaW1hdGluZyA9ICEwLCBhLiRzbGlkZXIudHJpZ2dlcihcImJlZm9yZUNoYW5nZVwiLCBbYSwgYS5jdXJyZW50U2xpZGUsIHNdKSwgbiA9IGEuY3VycmVudFNsaWRlLCBhLmN1cnJlbnRTbGlkZSA9IHMsIGEuc2V0U2xpZGVDbGFzc2VzKGEuY3VycmVudFNsaWRlKSwgYS5vcHRpb25zLmFzTmF2Rm9yICYmIChsID0gYS5nZXROYXZUYXJnZXQoKSwgbCA9IGwuc2xpY2soXCJnZXRTbGlja1wiKSwgbC5zbGlkZUNvdW50IDw9IGwub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiYgbC5zZXRTbGlkZUNsYXNzZXMoYS5jdXJyZW50U2xpZGUpKSwgYS51cGRhdGVEb3RzKCksIGEudXBkYXRlQXJyb3dzKCksIGEub3B0aW9ucy5mYWRlID09PSAhMCA/ICh0ICE9PSAhMCA/IChhLmZhZGVTbGlkZU91dChuKSwgYS5mYWRlU2xpZGUocywgZnVuY3Rpb24gKCkge1xuICAgICAgYS5wb3N0U2xpZGUocyk7XG4gICAgfSkpIDogYS5wb3N0U2xpZGUocyksIHZvaWQgYS5hbmltYXRlSGVpZ2h0KCkpIDogdm9pZCAodCAhPT0gITAgJiYgYS5zbGlkZUNvdW50ID4gYS5vcHRpb25zLnNsaWRlc1RvU2hvdyA/IGEuYW5pbWF0ZVNsaWRlKGQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGEucG9zdFNsaWRlKHMpO1xuICAgIH0pIDogYS5wb3N0U2xpZGUocykpKTtcbiAgfSwgZS5wcm90b3R5cGUuc3RhcnRMb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcztcbiAgICBpLm9wdGlvbnMuYXJyb3dzID09PSAhMCAmJiBpLnNsaWRlQ291bnQgPiBpLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIChpLiRwcmV2QXJyb3cuaGlkZSgpLCBpLiRuZXh0QXJyb3cuaGlkZSgpKSwgaS5vcHRpb25zLmRvdHMgPT09ICEwICYmIGkuc2xpZGVDb3VudCA+IGkub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiYgaS4kZG90cy5oaWRlKCksIGkuJHNsaWRlci5hZGRDbGFzcyhcInNsaWNrLWxvYWRpbmdcIik7XG4gIH0sIGUucHJvdG90eXBlLnN3aXBlRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLFxuICAgICAgZSxcbiAgICAgIHQsXG4gICAgICBvLFxuICAgICAgcyA9IHRoaXM7XG4gICAgcmV0dXJuIGkgPSBzLnRvdWNoT2JqZWN0LnN0YXJ0WCAtIHMudG91Y2hPYmplY3QuY3VyWCwgZSA9IHMudG91Y2hPYmplY3Quc3RhcnRZIC0gcy50b3VjaE9iamVjdC5jdXJZLCB0ID0gTWF0aC5hdGFuMihlLCBpKSwgbyA9IE1hdGgucm91bmQoMTgwICogdCAvIE1hdGguUEkpLCBvIDwgMCAmJiAobyA9IDM2MCAtIE1hdGguYWJzKG8pKSwgbyA8PSA0NSAmJiBvID49IDAgPyBzLm9wdGlvbnMucnRsID09PSAhMSA/IFwibGVmdFwiIDogXCJyaWdodFwiIDogbyA8PSAzNjAgJiYgbyA+PSAzMTUgPyBzLm9wdGlvbnMucnRsID09PSAhMSA/IFwibGVmdFwiIDogXCJyaWdodFwiIDogbyA+PSAxMzUgJiYgbyA8PSAyMjUgPyBzLm9wdGlvbnMucnRsID09PSAhMSA/IFwicmlnaHRcIiA6IFwibGVmdFwiIDogcy5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gITAgPyBvID49IDM1ICYmIG8gPD0gMTM1ID8gXCJkb3duXCIgOiBcInVwXCIgOiBcInZlcnRpY2FsXCI7XG4gIH0sIGUucHJvdG90eXBlLnN3aXBlRW5kID0gZnVuY3Rpb24gKGkpIHtcbiAgICB2YXIgZSxcbiAgICAgIHQsXG4gICAgICBvID0gdGhpcztcbiAgICBpZiAoby5kcmFnZ2luZyA9ICExLCBvLnN3aXBpbmcgPSAhMSwgby5zY3JvbGxpbmcpIHJldHVybiBvLnNjcm9sbGluZyA9ICExLCAhMTtcbiAgICBpZiAoby5pbnRlcnJ1cHRlZCA9ICExLCBvLnNob3VsZENsaWNrID0gIShvLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID4gMTApLCB2b2lkIDAgPT09IG8udG91Y2hPYmplY3QuY3VyWCkgcmV0dXJuICExO1xuICAgIGlmIChvLnRvdWNoT2JqZWN0LmVkZ2VIaXQgPT09ICEwICYmIG8uJHNsaWRlci50cmlnZ2VyKFwiZWRnZVwiLCBbbywgby5zd2lwZURpcmVjdGlvbigpXSksIG8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPj0gby50b3VjaE9iamVjdC5taW5Td2lwZSkge1xuICAgICAgc3dpdGNoICh0ID0gby5zd2lwZURpcmVjdGlvbigpKSB7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgZSA9IG8ub3B0aW9ucy5zd2lwZVRvU2xpZGUgPyBvLmNoZWNrTmF2aWdhYmxlKG8uY3VycmVudFNsaWRlICsgby5nZXRTbGlkZUNvdW50KCkpIDogby5jdXJyZW50U2xpZGUgKyBvLmdldFNsaWRlQ291bnQoKSwgby5jdXJyZW50RGlyZWN0aW9uID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgIGUgPSBvLm9wdGlvbnMuc3dpcGVUb1NsaWRlID8gby5jaGVja05hdmlnYWJsZShvLmN1cnJlbnRTbGlkZSAtIG8uZ2V0U2xpZGVDb3VudCgpKSA6IG8uY3VycmVudFNsaWRlIC0gby5nZXRTbGlkZUNvdW50KCksIG8uY3VycmVudERpcmVjdGlvbiA9IDE7XG4gICAgICB9XG4gICAgICBcInZlcnRpY2FsXCIgIT0gdCAmJiAoby5zbGlkZUhhbmRsZXIoZSksIG8udG91Y2hPYmplY3QgPSB7fSwgby4kc2xpZGVyLnRyaWdnZXIoXCJzd2lwZVwiLCBbbywgdF0pKTtcbiAgICB9IGVsc2Ugby50b3VjaE9iamVjdC5zdGFydFggIT09IG8udG91Y2hPYmplY3QuY3VyWCAmJiAoby5zbGlkZUhhbmRsZXIoby5jdXJyZW50U2xpZGUpLCBvLnRvdWNoT2JqZWN0ID0ge30pO1xuICB9LCBlLnByb3RvdHlwZS5zd2lwZUhhbmRsZXIgPSBmdW5jdGlvbiAoaSkge1xuICAgIHZhciBlID0gdGhpcztcbiAgICBpZiAoIShlLm9wdGlvbnMuc3dpcGUgPT09ICExIHx8IFwib250b3VjaGVuZFwiIGluIGRvY3VtZW50ICYmIGUub3B0aW9ucy5zd2lwZSA9PT0gITEgfHwgZS5vcHRpb25zLmRyYWdnYWJsZSA9PT0gITEgJiYgaS50eXBlLmluZGV4T2YoXCJtb3VzZVwiKSAhPT0gLTEpKSBzd2l0Y2ggKGUudG91Y2hPYmplY3QuZmluZ2VyQ291bnQgPSBpLm9yaWdpbmFsRXZlbnQgJiYgdm9pZCAwICE9PSBpLm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/IGkub3JpZ2luYWxFdmVudC50b3VjaGVzLmxlbmd0aCA6IDEsIGUudG91Y2hPYmplY3QubWluU3dpcGUgPSBlLmxpc3RXaWR0aCAvIGUub3B0aW9ucy50b3VjaFRocmVzaG9sZCwgZS5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gITAgJiYgKGUudG91Y2hPYmplY3QubWluU3dpcGUgPSBlLmxpc3RIZWlnaHQgLyBlLm9wdGlvbnMudG91Y2hUaHJlc2hvbGQpLCBpLmRhdGEuYWN0aW9uKSB7XG4gICAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgICAgZS5zd2lwZVN0YXJ0KGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtb3ZlXCI6XG4gICAgICAgIGUuc3dpcGVNb3ZlKGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgZS5zd2lwZUVuZChpKTtcbiAgICB9XG4gIH0sIGUucHJvdG90eXBlLnN3aXBlTW92ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIGUsXG4gICAgICB0LFxuICAgICAgbyxcbiAgICAgIHMsXG4gICAgICBuLFxuICAgICAgcixcbiAgICAgIGwgPSB0aGlzO1xuICAgIHJldHVybiBuID0gdm9pZCAwICE9PSBpLm9yaWdpbmFsRXZlbnQgPyBpLm9yaWdpbmFsRXZlbnQudG91Y2hlcyA6IG51bGwsICEoIWwuZHJhZ2dpbmcgfHwgbC5zY3JvbGxpbmcgfHwgbiAmJiAxICE9PSBuLmxlbmd0aCkgJiYgKGUgPSBsLmdldExlZnQobC5jdXJyZW50U2xpZGUpLCBsLnRvdWNoT2JqZWN0LmN1clggPSB2b2lkIDAgIT09IG4gPyBuWzBdLnBhZ2VYIDogaS5jbGllbnRYLCBsLnRvdWNoT2JqZWN0LmN1clkgPSB2b2lkIDAgIT09IG4gPyBuWzBdLnBhZ2VZIDogaS5jbGllbnRZLCBsLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3cobC50b3VjaE9iamVjdC5jdXJYIC0gbC50b3VjaE9iamVjdC5zdGFydFgsIDIpKSksIHIgPSBNYXRoLnJvdW5kKE1hdGguc3FydChNYXRoLnBvdyhsLnRvdWNoT2JqZWN0LmN1clkgLSBsLnRvdWNoT2JqZWN0LnN0YXJ0WSwgMikpKSwgIWwub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgJiYgIWwuc3dpcGluZyAmJiByID4gNCA/IChsLnNjcm9sbGluZyA9ICEwLCAhMSkgOiAobC5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gITAgJiYgKGwudG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPSByKSwgdCA9IGwuc3dpcGVEaXJlY3Rpb24oKSwgdm9pZCAwICE9PSBpLm9yaWdpbmFsRXZlbnQgJiYgbC50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+IDQgJiYgKGwuc3dpcGluZyA9ICEwLCBpLnByZXZlbnREZWZhdWx0KCkpLCBzID0gKGwub3B0aW9ucy5ydGwgPT09ICExID8gMSA6IC0xKSAqIChsLnRvdWNoT2JqZWN0LmN1clggPiBsLnRvdWNoT2JqZWN0LnN0YXJ0WCA/IDEgOiAtMSksIGwub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgPT09ICEwICYmIChzID0gbC50b3VjaE9iamVjdC5jdXJZID4gbC50b3VjaE9iamVjdC5zdGFydFkgPyAxIDogLTEpLCBvID0gbC50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCwgbC50b3VjaE9iamVjdC5lZGdlSGl0ID0gITEsIGwub3B0aW9ucy5pbmZpbml0ZSA9PT0gITEgJiYgKDAgPT09IGwuY3VycmVudFNsaWRlICYmIFwicmlnaHRcIiA9PT0gdCB8fCBsLmN1cnJlbnRTbGlkZSA+PSBsLmdldERvdENvdW50KCkgJiYgXCJsZWZ0XCIgPT09IHQpICYmIChvID0gbC50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCAqIGwub3B0aW9ucy5lZGdlRnJpY3Rpb24sIGwudG91Y2hPYmplY3QuZWRnZUhpdCA9ICEwKSwgbC5vcHRpb25zLnZlcnRpY2FsID09PSAhMSA/IGwuc3dpcGVMZWZ0ID0gZSArIG8gKiBzIDogbC5zd2lwZUxlZnQgPSBlICsgbyAqIChsLiRsaXN0LmhlaWdodCgpIC8gbC5saXN0V2lkdGgpICogcywgbC5vcHRpb25zLnZlcnRpY2FsU3dpcGluZyA9PT0gITAgJiYgKGwuc3dpcGVMZWZ0ID0gZSArIG8gKiBzKSwgbC5vcHRpb25zLmZhZGUgIT09ICEwICYmIGwub3B0aW9ucy50b3VjaE1vdmUgIT09ICExICYmIChsLmFuaW1hdGluZyA9PT0gITAgPyAobC5zd2lwZUxlZnQgPSBudWxsLCAhMSkgOiB2b2lkIGwuc2V0Q1NTKGwuc3dpcGVMZWZ0KSkpKTtcbiAgfSwgZS5wcm90b3R5cGUuc3dpcGVTdGFydCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIGUsXG4gICAgICB0ID0gdGhpcztcbiAgICByZXR1cm4gdC5pbnRlcnJ1cHRlZCA9ICEwLCAxICE9PSB0LnRvdWNoT2JqZWN0LmZpbmdlckNvdW50IHx8IHQuc2xpZGVDb3VudCA8PSB0Lm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gKHQudG91Y2hPYmplY3QgPSB7fSwgITEpIDogKHZvaWQgMCAhPT0gaS5vcmlnaW5hbEV2ZW50ICYmIHZvaWQgMCAhPT0gaS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgJiYgKGUgPSBpLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSksIHQudG91Y2hPYmplY3Quc3RhcnRYID0gdC50b3VjaE9iamVjdC5jdXJYID0gdm9pZCAwICE9PSBlID8gZS5wYWdlWCA6IGkuY2xpZW50WCwgdC50b3VjaE9iamVjdC5zdGFydFkgPSB0LnRvdWNoT2JqZWN0LmN1clkgPSB2b2lkIDAgIT09IGUgPyBlLnBhZ2VZIDogaS5jbGllbnRZLCB2b2lkICh0LmRyYWdnaW5nID0gITApKTtcbiAgfSwgZS5wcm90b3R5cGUudW5maWx0ZXJTbGlkZXMgPSBlLnByb3RvdHlwZS5zbGlja1VuZmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcztcbiAgICBudWxsICE9PSBpLiRzbGlkZXNDYWNoZSAmJiAoaS51bmxvYWQoKSwgaS4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpLCBpLiRzbGlkZXNDYWNoZS5hcHBlbmRUbyhpLiRzbGlkZVRyYWNrKSwgaS5yZWluaXQoKSk7XG4gIH0sIGUucHJvdG90eXBlLnVubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZSA9IHRoaXM7XG4gICAgaShcIi5zbGljay1jbG9uZWRcIiwgZS4kc2xpZGVyKS5yZW1vdmUoKSwgZS4kZG90cyAmJiBlLiRkb3RzLnJlbW92ZSgpLCBlLiRwcmV2QXJyb3cgJiYgZS5odG1sRXhwci50ZXN0KGUub3B0aW9ucy5wcmV2QXJyb3cpICYmIGUuJHByZXZBcnJvdy5yZW1vdmUoKSwgZS4kbmV4dEFycm93ICYmIGUuaHRtbEV4cHIudGVzdChlLm9wdGlvbnMubmV4dEFycm93KSAmJiBlLiRuZXh0QXJyb3cucmVtb3ZlKCksIGUuJHNsaWRlcy5yZW1vdmVDbGFzcyhcInNsaWNrLXNsaWRlIHNsaWNrLWFjdGl2ZSBzbGljay12aXNpYmxlIHNsaWNrLWN1cnJlbnRcIikuYXR0cihcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKS5jc3MoXCJ3aWR0aFwiLCBcIlwiKTtcbiAgfSwgZS5wcm90b3R5cGUudW5zbGljayA9IGZ1bmN0aW9uIChpKSB7XG4gICAgdmFyIGUgPSB0aGlzO1xuICAgIGUuJHNsaWRlci50cmlnZ2VyKFwidW5zbGlja1wiLCBbZSwgaV0pLCBlLmRlc3Ryb3koKTtcbiAgfSwgZS5wcm90b3R5cGUudXBkYXRlQXJyb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLFxuICAgICAgZSA9IHRoaXM7XG4gICAgaSA9IE1hdGguZmxvb3IoZS5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpLCBlLm9wdGlvbnMuYXJyb3dzID09PSAhMCAmJiBlLnNsaWRlQ291bnQgPiBlLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmICFlLm9wdGlvbnMuaW5maW5pdGUgJiYgKGUuJHByZXZBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsIFwiZmFsc2VcIiksIGUuJG5leHRBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsIFwiZmFsc2VcIiksIDAgPT09IGUuY3VycmVudFNsaWRlID8gKGUuJHByZXZBcnJvdy5hZGRDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiKSwgZS4kbmV4dEFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgXCJmYWxzZVwiKSkgOiBlLmN1cnJlbnRTbGlkZSA+PSBlLnNsaWRlQ291bnQgLSBlLm9wdGlvbnMuc2xpZGVzVG9TaG93ICYmIGUub3B0aW9ucy5jZW50ZXJNb2RlID09PSAhMSA/IChlLiRuZXh0QXJyb3cuYWRkQ2xhc3MoXCJzbGljay1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIiksIGUuJHByZXZBcnJvdy5yZW1vdmVDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsIFwiZmFsc2VcIikpIDogZS5jdXJyZW50U2xpZGUgPj0gZS5zbGlkZUNvdW50IC0gMSAmJiBlLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gITAgJiYgKGUuJG5leHRBcnJvdy5hZGRDbGFzcyhcInNsaWNrLWRpc2FibGVkXCIpLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiKSwgZS4kcHJldkFycm93LnJlbW92ZUNsYXNzKFwic2xpY2stZGlzYWJsZWRcIikuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgXCJmYWxzZVwiKSkpO1xuICB9LCBlLnByb3RvdHlwZS51cGRhdGVEb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcztcbiAgICBudWxsICE9PSBpLiRkb3RzICYmIChpLiRkb3RzLmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcyhcInNsaWNrLWFjdGl2ZVwiKS5lbmQoKSwgaS4kZG90cy5maW5kKFwibGlcIikuZXEoTWF0aC5mbG9vcihpLmN1cnJlbnRTbGlkZSAvIGkub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkpLmFkZENsYXNzKFwic2xpY2stYWN0aXZlXCIpKTtcbiAgfSwgZS5wcm90b3R5cGUudmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXM7XG4gICAgaS5vcHRpb25zLmF1dG9wbGF5ICYmIChkb2N1bWVudFtpLmhpZGRlbl0gPyBpLmludGVycnVwdGVkID0gITAgOiBpLmludGVycnVwdGVkID0gITEpO1xuICB9LCBpLmZuLnNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLFxuICAgICAgdCxcbiAgICAgIG8gPSB0aGlzLFxuICAgICAgcyA9IGFyZ3VtZW50c1swXSxcbiAgICAgIG4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgciA9IG8ubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCByOyBpKyspIGlmIChcIm9iamVjdFwiID09IF90eXBlb2YocykgfHwgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgcyA/IG9baV0uc2xpY2sgPSBuZXcgZShvW2ldLCBzKSA6IHQgPSBvW2ldLnNsaWNrW3NdLmFwcGx5KG9baV0uc2xpY2ssIG4pLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB0KSByZXR1cm4gdDtcbiAgICByZXR1cm4gbztcbiAgfTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///784\n')},741:function(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__){"use strict";eval("\n// EXTERNAL MODULE: external \"jQuery\"\nvar external_jQuery_ = __webpack_require__(669);\nvar external_jQuery_default = /*#__PURE__*/__webpack_require__.n(external_jQuery_);\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/util.js\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): util.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n/**\n * Private TransitionEnd Helpers\n */\n\nvar TRANSITION_END = 'transitionend';\nvar MAX_UID = 1000000;\nvar MILLISECONDS_MULTIPLIER = 1000;\n\n// Shoutout AngusCroll (https://goo.gl/pxwQGp)\nfunction toType(obj) {\n  if (obj === null || typeof obj === 'undefined') {\n    return \"\".concat(obj);\n  }\n  return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n}\nfunction getSpecialTransitionEndEvent() {\n  return {\n    bindType: TRANSITION_END,\n    delegateType: TRANSITION_END,\n    handle: function handle(event) {\n      if (external_jQuery_default()(event.target).is(this)) {\n        return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n      }\n      return undefined;\n    }\n  };\n}\nfunction transitionEndEmulator(duration) {\n  var _this = this;\n  var called = false;\n  external_jQuery_default()(this).one(Util.TRANSITION_END, function () {\n    called = true;\n  });\n  setTimeout(function () {\n    if (!called) {\n      Util.triggerTransitionEnd(_this);\n    }\n  }, duration);\n  return this;\n}\nfunction setTransitionEndSupport() {\n  (external_jQuery_default()).fn.emulateTransitionEnd = transitionEndEmulator;\n  (external_jQuery_default()).event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n}\n\n/**\n * Public Util API\n */\n\nvar Util = {\n  TRANSITION_END: 'bsTransitionEnd',\n  getUID: function getUID(prefix) {\n    do {\n      // eslint-disable-next-line no-bitwise\n      prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n    } while (document.getElementById(prefix));\n    return prefix;\n  },\n  getSelectorFromElement: function getSelectorFromElement(element) {\n    var selector = element.getAttribute('data-target');\n    if (!selector || selector === '#') {\n      var hrefAttr = element.getAttribute('href');\n      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';\n    }\n    try {\n      return document.querySelector(selector) ? selector : null;\n    } catch (_) {\n      return null;\n    }\n  },\n  getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n    if (!element) {\n      return 0;\n    }\n\n    // Get transition-duration of the element\n    var transitionDuration = external_jQuery_default()(element).css('transition-duration');\n    var transitionDelay = external_jQuery_default()(element).css('transition-delay');\n    var floatTransitionDuration = parseFloat(transitionDuration);\n    var floatTransitionDelay = parseFloat(transitionDelay);\n\n    // Return 0 if element or transition duration is not found\n    if (!floatTransitionDuration && !floatTransitionDelay) {\n      return 0;\n    }\n\n    // If multiple durations are defined, take the first\n    transitionDuration = transitionDuration.split(',')[0];\n    transitionDelay = transitionDelay.split(',')[0];\n    return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n  },\n  reflow: function reflow(element) {\n    return element.offsetHeight;\n  },\n  triggerTransitionEnd: function triggerTransitionEnd(element) {\n    external_jQuery_default()(element).trigger(TRANSITION_END);\n  },\n  supportsTransitionEnd: function supportsTransitionEnd() {\n    return Boolean(TRANSITION_END);\n  },\n  isElement: function isElement(obj) {\n    return (obj[0] || obj).nodeType;\n  },\n  typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n    for (var property in configTypes) {\n      if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n        var expectedTypes = configTypes[property];\n        var value = config[property];\n        var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n        if (!new RegExp(expectedTypes).test(valueType)) {\n          throw new Error(\"\".concat(componentName.toUpperCase(), \": \") + \"Option \\\"\".concat(property, \"\\\" provided type \\\"\").concat(valueType, \"\\\" \") + \"but expected type \\\"\".concat(expectedTypes, \"\\\".\"));\n        }\n      }\n    }\n  },\n  findShadowRoot: function findShadowRoot(element) {\n    if (!document.documentElement.attachShadow) {\n      return null;\n    }\n\n    // Can find the shadow root otherwise it'll return the document\n    if (typeof element.getRootNode === 'function') {\n      var root = element.getRootNode();\n      return root instanceof ShadowRoot ? root : null;\n    }\n    if (element instanceof ShadowRoot) {\n      return element;\n    }\n\n    // when we don't find a shadow root\n    if (!element.parentNode) {\n      return null;\n    }\n    return Util.findShadowRoot(element.parentNode);\n  },\n  jQueryDetection: function jQueryDetection() {\n    if (typeof (external_jQuery_default()) === 'undefined') {\n      throw new TypeError('Bootstrap\\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\\'s JavaScript.');\n    }\n    var version = external_jQuery_default().fn.jquery.split(' ')[0].split('.');\n    var minMajor = 1;\n    var ltMajor = 2;\n    var minMinor = 9;\n    var minPatch = 1;\n    var maxMajor = 4;\n    if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {\n      throw new Error('Bootstrap\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');\n    }\n  }\n};\nUtil.jQueryDetection();\nsetTransitionEndSupport();\n/* harmony default export */ var util = (Util);\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/alert.js\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n\n/**\n * Constants\n */\n\nvar NAME = 'alert';\nvar VERSION = '4.6.2';\nvar DATA_KEY = 'bs.alert';\nvar EVENT_KEY = \".\".concat(DATA_KEY);\nvar DATA_API_KEY = '.data-api';\nvar JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[NAME];\nvar CLASS_NAME_ALERT = 'alert';\nvar CLASS_NAME_FADE = 'fade';\nvar CLASS_NAME_SHOW = 'show';\nvar EVENT_CLOSE = \"close\".concat(EVENT_KEY);\nvar EVENT_CLOSED = \"closed\".concat(EVENT_KEY);\nvar EVENT_CLICK_DATA_API = \"click\".concat(EVENT_KEY).concat(DATA_API_KEY);\nvar SELECTOR_DISMISS = '[data-dismiss=\"alert\"]';\n\n/**\n * Class definition\n */\nvar Alert = /*#__PURE__*/function () {\n  function Alert(element) {\n    _classCallCheck(this, Alert);\n    this._element = element;\n  }\n\n  // Getters\n  return _createClass(Alert, [{\n    key: \"close\",\n    value:\n    // Public\n    function close(element) {\n      var rootElement = this._element;\n      if (element) {\n        rootElement = this._getRootElement(element);\n      }\n      var customEvent = this._triggerCloseEvent(rootElement);\n      if (customEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._removeElement(rootElement);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      external_jQuery_default().removeData(this._element, DATA_KEY);\n      this._element = null;\n    }\n\n    // Private\n  }, {\n    key: \"_getRootElement\",\n    value: function _getRootElement(element) {\n      var selector = util.getSelectorFromElement(element);\n      var parent = false;\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n      if (!parent) {\n        parent = external_jQuery_default()(element).closest(\".\".concat(CLASS_NAME_ALERT))[0];\n      }\n      return parent;\n    }\n  }, {\n    key: \"_triggerCloseEvent\",\n    value: function _triggerCloseEvent(element) {\n      var closeEvent = external_jQuery_default().Event(EVENT_CLOSE);\n      external_jQuery_default()(element).trigger(closeEvent);\n      return closeEvent;\n    }\n  }, {\n    key: \"_removeElement\",\n    value: function _removeElement(element) {\n      var _this = this;\n      external_jQuery_default()(element).removeClass(CLASS_NAME_SHOW);\n      if (!external_jQuery_default()(element).hasClass(CLASS_NAME_FADE)) {\n        this._destroyElement(element);\n        return;\n      }\n      var transitionDuration = util.getTransitionDurationFromElement(element);\n      external_jQuery_default()(element).one(util.TRANSITION_END, function (event) {\n        return _this._destroyElement(element, event);\n      }).emulateTransitionEnd(transitionDuration);\n    }\n  }, {\n    key: \"_destroyElement\",\n    value: function _destroyElement(element) {\n      external_jQuery_default()(element).detach().trigger(EVENT_CLOSED).remove();\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get: function get() {\n      return VERSION;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = external_jQuery_default()(this);\n        var data = $element.data(DATA_KEY);\n        if (!data) {\n          data = new Alert(this);\n          $element.data(DATA_KEY, data);\n        }\n        if (config === 'close') {\n          data[config](this);\n        }\n      });\n    }\n  }, {\n    key: \"_handleDismiss\",\n    value: function _handleDismiss(alertInstance) {\n      return function (event) {\n        if (event) {\n          event.preventDefault();\n        }\n        alertInstance.close(this);\n      };\n    }\n  }]);\n}();\n/**\n * Data API implementation\n */\nexternal_jQuery_default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));\n\n/**\n * jQuery\n */\n\n(external_jQuery_default()).fn[NAME] = Alert._jQueryInterface;\n(external_jQuery_default()).fn[NAME].Constructor = Alert;\n(external_jQuery_default()).fn[NAME].noConflict = function () {\n  (external_jQuery_default()).fn[NAME] = JQUERY_NO_CONFLICT;\n  return Alert._jQueryInterface;\n};\n/* harmony default export */ var src_alert = ((/* unused pure expression or super */ null && (Alert)));\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/button.js\nfunction button_typeof(o) { \"@babel/helpers - typeof\"; return button_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, button_typeof(o); }\nfunction button_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction button_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, button_toPropertyKey(descriptor.key), descriptor); } }\nfunction button_createClass(Constructor, protoProps, staticProps) { if (protoProps) button_defineProperties(Constructor.prototype, protoProps); if (staticProps) button_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction button_toPropertyKey(t) { var i = button_toPrimitive(t, \"string\"); return \"symbol\" == button_typeof(i) ? i : i + \"\"; }\nfunction button_toPrimitive(t, r) { if (\"object\" != button_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != button_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n/**\n * Constants\n */\n\nvar button_NAME = 'button';\nvar button_VERSION = '4.6.2';\nvar button_DATA_KEY = 'bs.button';\nvar button_EVENT_KEY = \".\".concat(button_DATA_KEY);\nvar button_DATA_API_KEY = '.data-api';\nvar button_JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[button_NAME];\nvar CLASS_NAME_ACTIVE = 'active';\nvar CLASS_NAME_BUTTON = 'btn';\nvar CLASS_NAME_FOCUS = 'focus';\nvar button_EVENT_CLICK_DATA_API = \"click\".concat(button_EVENT_KEY).concat(button_DATA_API_KEY);\nvar EVENT_FOCUS_BLUR_DATA_API = \"focus\".concat(button_EVENT_KEY).concat(button_DATA_API_KEY, \" \") + \"blur\".concat(button_EVENT_KEY).concat(button_DATA_API_KEY);\nvar EVENT_LOAD_DATA_API = \"load\".concat(button_EVENT_KEY).concat(button_DATA_API_KEY);\nvar SELECTOR_DATA_TOGGLE_CARROT = '[data-toggle^=\"button\"]';\nvar SELECTOR_DATA_TOGGLES = '[data-toggle=\"buttons\"]';\nvar SELECTOR_DATA_TOGGLE = '[data-toggle=\"button\"]';\nvar SELECTOR_DATA_TOGGLES_BUTTONS = '[data-toggle=\"buttons\"] .btn';\nvar SELECTOR_INPUT = 'input:not([type=\"hidden\"])';\nvar SELECTOR_ACTIVE = '.active';\nvar SELECTOR_BUTTON = '.btn';\n\n/**\n * Class definition\n */\nvar Button = /*#__PURE__*/function () {\n  function Button(element) {\n    button_classCallCheck(this, Button);\n    this._element = element;\n    this.shouldAvoidTriggerChange = false;\n  }\n\n  // Getters\n  return button_createClass(Button, [{\n    key: \"toggle\",\n    value:\n    // Public\n    function toggle() {\n      var triggerChangeEvent = true;\n      var addAriaPressed = true;\n      var rootElement = external_jQuery_default()(this._element).closest(SELECTOR_DATA_TOGGLES)[0];\n      if (rootElement) {\n        var input = this._element.querySelector(SELECTOR_INPUT);\n        if (input) {\n          if (input.type === 'radio') {\n            if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE)) {\n              triggerChangeEvent = false;\n            } else {\n              var activeElement = rootElement.querySelector(SELECTOR_ACTIVE);\n              if (activeElement) {\n                external_jQuery_default()(activeElement).removeClass(CLASS_NAME_ACTIVE);\n              }\n            }\n          }\n          if (triggerChangeEvent) {\n            // if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input\n            if (input.type === 'checkbox' || input.type === 'radio') {\n              input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE);\n            }\n            if (!this.shouldAvoidTriggerChange) {\n              external_jQuery_default()(input).trigger('change');\n            }\n          }\n          input.focus();\n          addAriaPressed = false;\n        }\n      }\n      if (!(this._element.hasAttribute('disabled') || this._element.classList.contains('disabled'))) {\n        if (addAriaPressed) {\n          this._element.setAttribute('aria-pressed', !this._element.classList.contains(CLASS_NAME_ACTIVE));\n        }\n        if (triggerChangeEvent) {\n          external_jQuery_default()(this._element).toggleClass(CLASS_NAME_ACTIVE);\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      external_jQuery_default().removeData(this._element, button_DATA_KEY);\n      this._element = null;\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get: function get() {\n      return button_VERSION;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config, avoidTriggerChange) {\n      return this.each(function () {\n        var $element = external_jQuery_default()(this);\n        var data = $element.data(button_DATA_KEY);\n        if (!data) {\n          data = new Button(this);\n          $element.data(button_DATA_KEY, data);\n        }\n        data.shouldAvoidTriggerChange = avoidTriggerChange;\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    }\n  }]);\n}();\n/**\n * Data API implementation\n */\nexternal_jQuery_default()(document).on(button_EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n  var button = event.target;\n  var initialButton = button;\n  if (!external_jQuery_default()(button).hasClass(CLASS_NAME_BUTTON)) {\n    button = external_jQuery_default()(button).closest(SELECTOR_BUTTON)[0];\n  }\n  if (!button || button.hasAttribute('disabled') || button.classList.contains('disabled')) {\n    event.preventDefault(); // work around Firefox bug #1540995\n  } else {\n    var inputBtn = button.querySelector(SELECTOR_INPUT);\n    if (inputBtn && (inputBtn.hasAttribute('disabled') || inputBtn.classList.contains('disabled'))) {\n      event.preventDefault(); // work around Firefox bug #1540995\n      return;\n    }\n    if (initialButton.tagName === 'INPUT' || button.tagName !== 'LABEL') {\n      Button._jQueryInterface.call(external_jQuery_default()(button), 'toggle', initialButton.tagName === 'INPUT');\n    }\n  }\n}).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n  var button = external_jQuery_default()(event.target).closest(SELECTOR_BUTTON)[0];\n  external_jQuery_default()(button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));\n});\nexternal_jQuery_default()(window).on(EVENT_LOAD_DATA_API, function () {\n  // ensure correct active class is set to match the controls' actual values/states\n\n  // find all checkboxes/readio buttons inside data-toggle groups\n  var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));\n  for (var i = 0, len = buttons.length; i < len; i++) {\n    var button = buttons[i];\n    var input = button.querySelector(SELECTOR_INPUT);\n    if (input.checked || input.hasAttribute('checked')) {\n      button.classList.add(CLASS_NAME_ACTIVE);\n    } else {\n      button.classList.remove(CLASS_NAME_ACTIVE);\n    }\n  }\n\n  // find all button toggles\n  buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE));\n  for (var _i = 0, _len = buttons.length; _i < _len; _i++) {\n    var _button = buttons[_i];\n    if (_button.getAttribute('aria-pressed') === 'true') {\n      _button.classList.add(CLASS_NAME_ACTIVE);\n    } else {\n      _button.classList.remove(CLASS_NAME_ACTIVE);\n    }\n  }\n});\n\n/**\n * jQuery\n */\n\n(external_jQuery_default()).fn[button_NAME] = Button._jQueryInterface;\n(external_jQuery_default()).fn[button_NAME].Constructor = Button;\n(external_jQuery_default()).fn[button_NAME].noConflict = function () {\n  (external_jQuery_default()).fn[button_NAME] = button_JQUERY_NO_CONFLICT;\n  return Button._jQueryInterface;\n};\n/* harmony default export */ var src_button = ((/* unused pure expression or super */ null && (Button)));\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/collapse.js\nfunction collapse_typeof(o) { \"@babel/helpers - typeof\"; return collapse_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, collapse_typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = collapse_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction collapse_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction collapse_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, collapse_toPropertyKey(descriptor.key), descriptor); } }\nfunction collapse_createClass(Constructor, protoProps, staticProps) { if (protoProps) collapse_defineProperties(Constructor.prototype, protoProps); if (staticProps) collapse_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction collapse_toPropertyKey(t) { var i = collapse_toPrimitive(t, \"string\"); return \"symbol\" == collapse_typeof(i) ? i : i + \"\"; }\nfunction collapse_toPrimitive(t, r) { if (\"object\" != collapse_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != collapse_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n\n/**\n * Constants\n */\n\nvar collapse_NAME = 'collapse';\nvar collapse_VERSION = '4.6.2';\nvar collapse_DATA_KEY = 'bs.collapse';\nvar collapse_EVENT_KEY = \".\".concat(collapse_DATA_KEY);\nvar collapse_DATA_API_KEY = '.data-api';\nvar collapse_JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[collapse_NAME];\nvar collapse_CLASS_NAME_SHOW = 'show';\nvar CLASS_NAME_COLLAPSE = 'collapse';\nvar CLASS_NAME_COLLAPSING = 'collapsing';\nvar CLASS_NAME_COLLAPSED = 'collapsed';\nvar DIMENSION_WIDTH = 'width';\nvar DIMENSION_HEIGHT = 'height';\nvar EVENT_SHOW = \"show\".concat(collapse_EVENT_KEY);\nvar EVENT_SHOWN = \"shown\".concat(collapse_EVENT_KEY);\nvar EVENT_HIDE = \"hide\".concat(collapse_EVENT_KEY);\nvar EVENT_HIDDEN = \"hidden\".concat(collapse_EVENT_KEY);\nvar collapse_EVENT_CLICK_DATA_API = \"click\".concat(collapse_EVENT_KEY).concat(collapse_DATA_API_KEY);\nvar SELECTOR_ACTIVES = '.show, .collapsing';\nvar collapse_SELECTOR_DATA_TOGGLE = '[data-toggle=\"collapse\"]';\nvar Default = {\n  toggle: true,\n  parent: ''\n};\nvar DefaultType = {\n  toggle: 'boolean',\n  parent: '(string|element)'\n};\n\n/**\n * Class definition\n */\nvar Collapse = /*#__PURE__*/function () {\n  function Collapse(element, config) {\n    collapse_classCallCheck(this, Collapse);\n    this._isTransitioning = false;\n    this._element = element;\n    this._config = this._getConfig(config);\n    this._triggerArray = [].slice.call(document.querySelectorAll(\"[data-toggle=\\\"collapse\\\"][href=\\\"#\".concat(element.id, \"\\\"],\") + \"[data-toggle=\\\"collapse\\\"][data-target=\\\"#\".concat(element.id, \"\\\"]\")));\n    var toggleList = [].slice.call(document.querySelectorAll(collapse_SELECTOR_DATA_TOGGLE));\n    for (var i = 0, len = toggleList.length; i < len; i++) {\n      var elem = toggleList[i];\n      var selector = util.getSelectorFromElement(elem);\n      var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {\n        return foundElem === element;\n      });\n      if (selector !== null && filterElement.length > 0) {\n        this._selector = selector;\n        this._triggerArray.push(elem);\n      }\n    }\n    this._parent = this._config.parent ? this._getParent() : null;\n    if (!this._config.parent) {\n      this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n    }\n    if (this._config.toggle) {\n      this.toggle();\n    }\n  }\n\n  // Getters\n  return collapse_createClass(Collapse, [{\n    key: \"toggle\",\n    value:\n    // Public\n    function toggle() {\n      if (external_jQuery_default()(this._element).hasClass(collapse_CLASS_NAME_SHOW)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var _this = this;\n      if (this._isTransitioning || external_jQuery_default()(this._element).hasClass(collapse_CLASS_NAME_SHOW)) {\n        return;\n      }\n      var actives;\n      var activesData;\n      if (this._parent) {\n        actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function (elem) {\n          if (typeof _this._config.parent === 'string') {\n            return elem.getAttribute('data-parent') === _this._config.parent;\n          }\n          return elem.classList.contains(CLASS_NAME_COLLAPSE);\n        });\n        if (actives.length === 0) {\n          actives = null;\n        }\n      }\n      if (actives) {\n        activesData = external_jQuery_default()(actives).not(this._selector).data(collapse_DATA_KEY);\n        if (activesData && activesData._isTransitioning) {\n          return;\n        }\n      }\n      var startEvent = external_jQuery_default().Event(EVENT_SHOW);\n      external_jQuery_default()(this._element).trigger(startEvent);\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (actives) {\n        Collapse._jQueryInterface.call(external_jQuery_default()(actives).not(this._selector), 'hide');\n        if (!activesData) {\n          external_jQuery_default()(actives).data(collapse_DATA_KEY, null);\n        }\n      }\n      var dimension = this._getDimension();\n      external_jQuery_default()(this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);\n      this._element.style[dimension] = 0;\n      if (this._triggerArray.length) {\n        external_jQuery_default()(this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', true);\n      }\n      this.setTransitioning(true);\n      var complete = function complete() {\n        external_jQuery_default()(_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(\"\".concat(CLASS_NAME_COLLAPSE, \" \").concat(collapse_CLASS_NAME_SHOW));\n        _this._element.style[dimension] = '';\n        _this.setTransitioning(false);\n        external_jQuery_default()(_this._element).trigger(EVENT_SHOWN);\n      };\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      var scrollSize = \"scroll\".concat(capitalizedDimension);\n      var transitionDuration = util.getTransitionDurationFromElement(this._element);\n      external_jQuery_default()(this._element).one(util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      this._element.style[dimension] = \"\".concat(this._element[scrollSize], \"px\");\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this2 = this;\n      if (this._isTransitioning || !external_jQuery_default()(this._element).hasClass(collapse_CLASS_NAME_SHOW)) {\n        return;\n      }\n      var startEvent = external_jQuery_default().Event(EVENT_HIDE);\n      external_jQuery_default()(this._element).trigger(startEvent);\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n      var dimension = this._getDimension();\n      this._element.style[dimension] = \"\".concat(this._element.getBoundingClientRect()[dimension], \"px\");\n      util.reflow(this._element);\n      external_jQuery_default()(this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(\"\".concat(CLASS_NAME_COLLAPSE, \" \").concat(collapse_CLASS_NAME_SHOW));\n      var triggerArrayLength = this._triggerArray.length;\n      if (triggerArrayLength > 0) {\n        for (var i = 0; i < triggerArrayLength; i++) {\n          var trigger = this._triggerArray[i];\n          var selector = util.getSelectorFromElement(trigger);\n          if (selector !== null) {\n            var $elem = external_jQuery_default()([].slice.call(document.querySelectorAll(selector)));\n            if (!$elem.hasClass(collapse_CLASS_NAME_SHOW)) {\n              external_jQuery_default()(trigger).addClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', false);\n            }\n          }\n        }\n      }\n      this.setTransitioning(true);\n      var complete = function complete() {\n        _this2.setTransitioning(false);\n        external_jQuery_default()(_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN);\n      };\n      this._element.style[dimension] = '';\n      var transitionDuration = util.getTransitionDurationFromElement(this._element);\n      external_jQuery_default()(this._element).one(util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n    }\n  }, {\n    key: \"setTransitioning\",\n    value: function setTransitioning(isTransitioning) {\n      this._isTransitioning = isTransitioning;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      external_jQuery_default().removeData(this._element, collapse_DATA_KEY);\n      this._config = null;\n      this._parent = null;\n      this._element = null;\n      this._triggerArray = null;\n      this._isTransitioning = null;\n    }\n\n    // Private\n  }, {\n    key: \"_getConfig\",\n    value: function _getConfig(config) {\n      config = _objectSpread(_objectSpread({}, Default), config);\n      config.toggle = Boolean(config.toggle); // Coerce string values\n      util.typeCheckConfig(collapse_NAME, config, DefaultType);\n      return config;\n    }\n  }, {\n    key: \"_getDimension\",\n    value: function _getDimension() {\n      var hasWidth = external_jQuery_default()(this._element).hasClass(DIMENSION_WIDTH);\n      return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;\n    }\n  }, {\n    key: \"_getParent\",\n    value: function _getParent() {\n      var _this3 = this;\n      var parent;\n      if (util.isElement(this._config.parent)) {\n        parent = this._config.parent;\n\n        // It's a jQuery object\n        if (typeof this._config.parent.jquery !== 'undefined') {\n          parent = this._config.parent[0];\n        }\n      } else {\n        parent = document.querySelector(this._config.parent);\n      }\n      var selector = \"[data-toggle=\\\"collapse\\\"][data-parent=\\\"\".concat(this._config.parent, \"\\\"]\");\n      var children = [].slice.call(parent.querySelectorAll(selector));\n      external_jQuery_default()(children).each(function (i, element) {\n        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\n      });\n      return parent;\n    }\n  }, {\n    key: \"_addAriaAndCollapsedClass\",\n    value: function _addAriaAndCollapsedClass(element, triggerArray) {\n      var isOpen = external_jQuery_default()(element).hasClass(collapse_CLASS_NAME_SHOW);\n      if (triggerArray.length) {\n        external_jQuery_default()(triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\n      }\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get: function get() {\n      return collapse_VERSION;\n    }\n  }, {\n    key: \"Default\",\n    get: function get() {\n      return Default;\n    }\n  }, {\n    key: \"_getTargetFromElement\",\n    value: function _getTargetFromElement(element) {\n      var selector = util.getSelectorFromElement(element);\n      return selector ? document.querySelector(selector) : null;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = external_jQuery_default()(this);\n        var data = $element.data(collapse_DATA_KEY);\n        var _config = _objectSpread(_objectSpread(_objectSpread({}, Default), $element.data()), collapse_typeof(config) === 'object' && config ? config : {});\n        if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n        if (!data) {\n          data = new Collapse(this, _config);\n          $element.data(collapse_DATA_KEY, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        }\n      });\n    }\n  }]);\n}();\n/**\n * Data API implementation\n */\nexternal_jQuery_default()(document).on(collapse_EVENT_CLICK_DATA_API, collapse_SELECTOR_DATA_TOGGLE, function (event) {\n  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n  if (event.currentTarget.tagName === 'A') {\n    event.preventDefault();\n  }\n  var $trigger = external_jQuery_default()(this);\n  var selector = util.getSelectorFromElement(this);\n  var selectors = [].slice.call(document.querySelectorAll(selector));\n  external_jQuery_default()(selectors).each(function () {\n    var $target = external_jQuery_default()(this);\n    var data = $target.data(collapse_DATA_KEY);\n    var config = data ? 'toggle' : $trigger.data();\n    Collapse._jQueryInterface.call($target, config);\n  });\n});\n\n/**\n * jQuery\n */\n\n(external_jQuery_default()).fn[collapse_NAME] = Collapse._jQueryInterface;\n(external_jQuery_default()).fn[collapse_NAME].Constructor = Collapse;\n(external_jQuery_default()).fn[collapse_NAME].noConflict = function () {\n  (external_jQuery_default()).fn[collapse_NAME] = collapse_JQUERY_NO_CONFLICT;\n  return Collapse._jQueryInterface;\n};\n/* harmony default export */ var collapse = ((/* unused pure expression or super */ null && (Collapse)));\n;// CONCATENATED MODULE: ./node_modules/popper.js/dist/esm/popper.js\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n    overflow = _getStyleComputedProp.overflow,\n    overflowX = _getStyleComputedProp.overflowX,\n    overflowY = _getStyleComputedProp.overflowY;\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n  var nodeName = offsetParent && offsetParent.nodeName;\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n  return offsetParent;\n}\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n};\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n  return getClientRect(result);\n}\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n  return offsets;\n}\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = {\n    top: 0,\n    left: 0\n  };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n        height = _getWindowSizes.height,\n        width = _getWindowSizes.width;\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n  return boundaries;\n}\nfunction getArea(_ref) {\n  var width = _ref.width,\n    height = _ref.height;\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n      height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n  var variation = placement.split('-')[1];\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n      data = fn(data, modifier);\n    }\n  });\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n      enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, {\n    passive: true\n  });\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, {\n    passive: true\n  });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, {\n    position: options.positionFixed ? 'fixed' : 'absolute'\n  });\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var round = Math.round,\n    floor = Math.floor;\n  var noRound = function noRound(v) {\n    return v;\n  };\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n    y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n    top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n  var flipOrder = [];\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n    _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var basePlacement = placement.split('-')[0];\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n    left = popperStyles.left,\n    transform = popperStyles[transformProp];\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n  options.boundaries = boundaries;\n  var order = options.priority;\n  var popper = data.offsets.popper;\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n  data.offsets.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n      reference = _data$offsets.reference,\n      popper = _data$offsets.popper;\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\nPopper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n/* harmony default export */ var popper = (Popper);\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/dropdown.js\nfunction dropdown_typeof(o) { \"@babel/helpers - typeof\"; return dropdown_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, dropdown_typeof(o); }\nfunction dropdown_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction dropdown_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? dropdown_ownKeys(Object(t), !0).forEach(function (r) { dropdown_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : dropdown_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction dropdown_defineProperty(obj, key, value) { key = dropdown_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction dropdown_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction dropdown_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, dropdown_toPropertyKey(descriptor.key), descriptor); } }\nfunction dropdown_createClass(Constructor, protoProps, staticProps) { if (protoProps) dropdown_defineProperties(Constructor.prototype, protoProps); if (staticProps) dropdown_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction dropdown_toPropertyKey(t) { var i = dropdown_toPrimitive(t, \"string\"); return \"symbol\" == dropdown_typeof(i) ? i : i + \"\"; }\nfunction dropdown_toPrimitive(t, r) { if (\"object\" != dropdown_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != dropdown_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n\n\n/**\n * Constants\n */\n\nvar dropdown_NAME = 'dropdown';\nvar dropdown_VERSION = '4.6.2';\nvar dropdown_DATA_KEY = 'bs.dropdown';\nvar dropdown_EVENT_KEY = \".\".concat(dropdown_DATA_KEY);\nvar dropdown_DATA_API_KEY = '.data-api';\nvar dropdown_JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[dropdown_NAME];\nvar ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\nvar SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key\nvar TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key\nvar ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\nvar ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\nvar RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\nvar REGEXP_KEYDOWN = new RegExp(\"\".concat(ARROW_UP_KEYCODE, \"|\").concat(ARROW_DOWN_KEYCODE, \"|\").concat(ESCAPE_KEYCODE));\nvar CLASS_NAME_DISABLED = 'disabled';\nvar dropdown_CLASS_NAME_SHOW = 'show';\nvar CLASS_NAME_DROPUP = 'dropup';\nvar CLASS_NAME_DROPRIGHT = 'dropright';\nvar CLASS_NAME_DROPLEFT = 'dropleft';\nvar CLASS_NAME_MENURIGHT = 'dropdown-menu-right';\nvar CLASS_NAME_POSITION_STATIC = 'position-static';\nvar dropdown_EVENT_HIDE = \"hide\".concat(dropdown_EVENT_KEY);\nvar dropdown_EVENT_HIDDEN = \"hidden\".concat(dropdown_EVENT_KEY);\nvar dropdown_EVENT_SHOW = \"show\".concat(dropdown_EVENT_KEY);\nvar dropdown_EVENT_SHOWN = \"shown\".concat(dropdown_EVENT_KEY);\nvar EVENT_CLICK = \"click\".concat(dropdown_EVENT_KEY);\nvar dropdown_EVENT_CLICK_DATA_API = \"click\".concat(dropdown_EVENT_KEY).concat(dropdown_DATA_API_KEY);\nvar EVENT_KEYDOWN_DATA_API = \"keydown\".concat(dropdown_EVENT_KEY).concat(dropdown_DATA_API_KEY);\nvar EVENT_KEYUP_DATA_API = \"keyup\".concat(dropdown_EVENT_KEY).concat(dropdown_DATA_API_KEY);\nvar dropdown_SELECTOR_DATA_TOGGLE = '[data-toggle=\"dropdown\"]';\nvar SELECTOR_FORM_CHILD = '.dropdown form';\nvar SELECTOR_MENU = '.dropdown-menu';\nvar SELECTOR_NAVBAR_NAV = '.navbar-nav';\nvar SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\nvar PLACEMENT_TOP = 'top-start';\nvar PLACEMENT_TOPEND = 'top-end';\nvar PLACEMENT_BOTTOM = 'bottom-start';\nvar PLACEMENT_BOTTOMEND = 'bottom-end';\nvar PLACEMENT_RIGHT = 'right-start';\nvar PLACEMENT_LEFT = 'left-start';\nvar dropdown_Default = {\n  offset: 0,\n  flip: true,\n  boundary: 'scrollParent',\n  reference: 'toggle',\n  display: 'dynamic',\n  popperConfig: null\n};\nvar dropdown_DefaultType = {\n  offset: '(number|string|function)',\n  flip: 'boolean',\n  boundary: '(string|element)',\n  reference: '(string|element)',\n  display: 'string',\n  popperConfig: '(null|object)'\n};\n\n/**\n * Class definition\n */\nvar Dropdown = /*#__PURE__*/function () {\n  function Dropdown(element, config) {\n    dropdown_classCallCheck(this, Dropdown);\n    this._element = element;\n    this._popper = null;\n    this._config = this._getConfig(config);\n    this._menu = this._getMenuElement();\n    this._inNavbar = this._detectNavbar();\n    this._addEventListeners();\n  }\n\n  // Getters\n  return dropdown_createClass(Dropdown, [{\n    key: \"toggle\",\n    value:\n    // Public\n    function toggle() {\n      if (this._element.disabled || external_jQuery_default()(this._element).hasClass(CLASS_NAME_DISABLED)) {\n        return;\n      }\n      var isActive = external_jQuery_default()(this._menu).hasClass(dropdown_CLASS_NAME_SHOW);\n      Dropdown._clearMenus();\n      if (isActive) {\n        return;\n      }\n      this.show(true);\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var usePopper = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this._element.disabled || external_jQuery_default()(this._element).hasClass(CLASS_NAME_DISABLED) || external_jQuery_default()(this._menu).hasClass(dropdown_CLASS_NAME_SHOW)) {\n        return;\n      }\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var showEvent = external_jQuery_default().Event(dropdown_EVENT_SHOW, relatedTarget);\n      var parent = Dropdown._getParentFromElement(this._element);\n      external_jQuery_default()(parent).trigger(showEvent);\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      // Totally disable Popper for Dropdowns in Navbar\n      if (!this._inNavbar && usePopper) {\n        // Check for Popper dependency\n        if (typeof popper === 'undefined') {\n          throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n        }\n        var referenceElement = this._element;\n        if (this._config.reference === 'parent') {\n          referenceElement = parent;\n        } else if (util.isElement(this._config.reference)) {\n          referenceElement = this._config.reference;\n\n          // Check if it's jQuery element\n          if (typeof this._config.reference.jquery !== 'undefined') {\n            referenceElement = this._config.reference[0];\n          }\n        }\n\n        // If boundary is not `scrollParent`, then set position to `static`\n        // to allow the menu to \"escape\" the scroll parent's boundaries\n        // https://github.com/twbs/bootstrap/issues/24251\n        if (this._config.boundary !== 'scrollParent') {\n          external_jQuery_default()(parent).addClass(CLASS_NAME_POSITION_STATIC);\n        }\n        this._popper = new popper(referenceElement, this._menu, this._getPopperConfig());\n      }\n\n      // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n      if ('ontouchstart' in document.documentElement && external_jQuery_default()(parent).closest(SELECTOR_NAVBAR_NAV).length === 0) {\n        external_jQuery_default()(document.body).children().on('mouseover', null, (external_jQuery_default()).noop);\n      }\n      this._element.focus();\n      this._element.setAttribute('aria-expanded', true);\n      external_jQuery_default()(this._menu).toggleClass(dropdown_CLASS_NAME_SHOW);\n      external_jQuery_default()(parent).toggleClass(dropdown_CLASS_NAME_SHOW).trigger(external_jQuery_default().Event(dropdown_EVENT_SHOWN, relatedTarget));\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (this._element.disabled || external_jQuery_default()(this._element).hasClass(CLASS_NAME_DISABLED) || !external_jQuery_default()(this._menu).hasClass(dropdown_CLASS_NAME_SHOW)) {\n        return;\n      }\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var hideEvent = external_jQuery_default().Event(dropdown_EVENT_HIDE, relatedTarget);\n      var parent = Dropdown._getParentFromElement(this._element);\n      external_jQuery_default()(parent).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (this._popper) {\n        this._popper.destroy();\n      }\n      external_jQuery_default()(this._menu).toggleClass(dropdown_CLASS_NAME_SHOW);\n      external_jQuery_default()(parent).toggleClass(dropdown_CLASS_NAME_SHOW).trigger(external_jQuery_default().Event(dropdown_EVENT_HIDDEN, relatedTarget));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      external_jQuery_default().removeData(this._element, dropdown_DATA_KEY);\n      external_jQuery_default()(this._element).off(dropdown_EVENT_KEY);\n      this._element = null;\n      this._menu = null;\n      if (this._popper !== null) {\n        this._popper.destroy();\n        this._popper = null;\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this._inNavbar = this._detectNavbar();\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    }\n\n    // Private\n  }, {\n    key: \"_addEventListeners\",\n    value: function _addEventListeners() {\n      var _this = this;\n      external_jQuery_default()(this._element).on(EVENT_CLICK, function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        _this.toggle();\n      });\n    }\n  }, {\n    key: \"_getConfig\",\n    value: function _getConfig(config) {\n      config = dropdown_objectSpread(dropdown_objectSpread(dropdown_objectSpread({}, this.constructor.Default), external_jQuery_default()(this._element).data()), config);\n      util.typeCheckConfig(dropdown_NAME, config, this.constructor.DefaultType);\n      return config;\n    }\n  }, {\n    key: \"_getMenuElement\",\n    value: function _getMenuElement() {\n      if (!this._menu) {\n        var parent = Dropdown._getParentFromElement(this._element);\n        if (parent) {\n          this._menu = parent.querySelector(SELECTOR_MENU);\n        }\n      }\n      return this._menu;\n    }\n  }, {\n    key: \"_getPlacement\",\n    value: function _getPlacement() {\n      var $parentDropdown = external_jQuery_default()(this._element.parentNode);\n      var placement = PLACEMENT_BOTTOM;\n\n      // Handle dropup\n      if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {\n        placement = external_jQuery_default()(this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {\n        placement = PLACEMENT_RIGHT;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {\n        placement = PLACEMENT_LEFT;\n      } else if (external_jQuery_default()(this._menu).hasClass(CLASS_NAME_MENURIGHT)) {\n        placement = PLACEMENT_BOTTOMEND;\n      }\n      return placement;\n    }\n  }, {\n    key: \"_detectNavbar\",\n    value: function _detectNavbar() {\n      return external_jQuery_default()(this._element).closest('.navbar').length > 0;\n    }\n  }, {\n    key: \"_getOffset\",\n    value: function _getOffset() {\n      var _this2 = this;\n      var offset = {};\n      if (typeof this._config.offset === 'function') {\n        offset.fn = function (data) {\n          data.offsets = dropdown_objectSpread(dropdown_objectSpread({}, data.offsets), _this2._config.offset(data.offsets, _this2._element));\n          return data;\n        };\n      } else {\n        offset.offset = this._config.offset;\n      }\n      return offset;\n    }\n  }, {\n    key: \"_getPopperConfig\",\n    value: function _getPopperConfig() {\n      var popperConfig = {\n        placement: this._getPlacement(),\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            enabled: this._config.flip\n          },\n          preventOverflow: {\n            boundariesElement: this._config.boundary\n          }\n        }\n      };\n\n      // Disable Popper if we have a static display\n      if (this._config.display === 'static') {\n        popperConfig.modifiers.applyStyle = {\n          enabled: false\n        };\n      }\n      return dropdown_objectSpread(dropdown_objectSpread({}, popperConfig), this._config.popperConfig);\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get: function get() {\n      return dropdown_VERSION;\n    }\n  }, {\n    key: \"Default\",\n    get: function get() {\n      return dropdown_Default;\n    }\n  }, {\n    key: \"DefaultType\",\n    get: function get() {\n      return dropdown_DefaultType;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = external_jQuery_default()(this).data(dropdown_DATA_KEY);\n        var _config = dropdown_typeof(config) === 'object' ? config : null;\n        if (!data) {\n          data = new Dropdown(this, _config);\n          external_jQuery_default()(this).data(dropdown_DATA_KEY, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        }\n      });\n    }\n  }, {\n    key: \"_clearMenus\",\n    value: function _clearMenus(event) {\n      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {\n        return;\n      }\n      var toggles = [].slice.call(document.querySelectorAll(dropdown_SELECTOR_DATA_TOGGLE));\n      for (var i = 0, len = toggles.length; i < len; i++) {\n        var parent = Dropdown._getParentFromElement(toggles[i]);\n        var context = external_jQuery_default()(toggles[i]).data(dropdown_DATA_KEY);\n        var relatedTarget = {\n          relatedTarget: toggles[i]\n        };\n        if (event && event.type === 'click') {\n          relatedTarget.clickEvent = event;\n        }\n        if (!context) {\n          continue;\n        }\n        var dropdownMenu = context._menu;\n        if (!external_jQuery_default()(parent).hasClass(dropdown_CLASS_NAME_SHOW)) {\n          continue;\n        }\n        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && external_jQuery_default().contains(parent, event.target)) {\n          continue;\n        }\n        var hideEvent = external_jQuery_default().Event(dropdown_EVENT_HIDE, relatedTarget);\n        external_jQuery_default()(parent).trigger(hideEvent);\n        if (hideEvent.isDefaultPrevented()) {\n          continue;\n        }\n\n        // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n        if ('ontouchstart' in document.documentElement) {\n          external_jQuery_default()(document.body).children().off('mouseover', null, (external_jQuery_default()).noop);\n        }\n        toggles[i].setAttribute('aria-expanded', 'false');\n        if (context._popper) {\n          context._popper.destroy();\n        }\n        external_jQuery_default()(dropdownMenu).removeClass(dropdown_CLASS_NAME_SHOW);\n        external_jQuery_default()(parent).removeClass(dropdown_CLASS_NAME_SHOW).trigger(external_jQuery_default().Event(dropdown_EVENT_HIDDEN, relatedTarget));\n      }\n    }\n  }, {\n    key: \"_getParentFromElement\",\n    value: function _getParentFromElement(element) {\n      var parent;\n      var selector = util.getSelectorFromElement(element);\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n      return parent || element.parentNode;\n    }\n\n    // eslint-disable-next-line complexity\n  }, {\n    key: \"_dataApiKeydownHandler\",\n    value: function _dataApiKeydownHandler(event) {\n      // If not input/textarea:\n      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n      // If input/textarea:\n      //  - If space key => not a dropdown command\n      //  - If key is other than escape\n      //    - If key is not up or down => not a dropdown command\n      //    - If trigger inside the menu => not a dropdown command\n      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || external_jQuery_default()(event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {\n        return;\n      }\n      if (this.disabled || external_jQuery_default()(this).hasClass(CLASS_NAME_DISABLED)) {\n        return;\n      }\n      var parent = Dropdown._getParentFromElement(this);\n      var isActive = external_jQuery_default()(parent).hasClass(dropdown_CLASS_NAME_SHOW);\n      if (!isActive && event.which === ESCAPE_KEYCODE) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      if (!isActive || event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE) {\n        if (event.which === ESCAPE_KEYCODE) {\n          external_jQuery_default()(parent.querySelector(dropdown_SELECTOR_DATA_TOGGLE)).trigger('focus');\n        }\n        external_jQuery_default()(this).trigger('click');\n        return;\n      }\n      var items = [].slice.call(parent.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function (item) {\n        return external_jQuery_default()(item).is(':visible');\n      });\n      if (items.length === 0) {\n        return;\n      }\n      var index = items.indexOf(event.target);\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\n        // Up\n        index--;\n      }\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\n        // Down\n        index++;\n      }\n      if (index < 0) {\n        index = 0;\n      }\n      items[index].focus();\n    }\n  }]);\n}();\n/**\n * Data API implementation\n */\nexternal_jQuery_default()(document).on(EVENT_KEYDOWN_DATA_API, dropdown_SELECTOR_DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(\"\".concat(dropdown_EVENT_CLICK_DATA_API, \" \").concat(EVENT_KEYUP_DATA_API), Dropdown._clearMenus).on(dropdown_EVENT_CLICK_DATA_API, dropdown_SELECTOR_DATA_TOGGLE, function (event) {\n  event.preventDefault();\n  event.stopPropagation();\n  Dropdown._jQueryInterface.call(external_jQuery_default()(this), 'toggle');\n}).on(dropdown_EVENT_CLICK_DATA_API, SELECTOR_FORM_CHILD, function (e) {\n  e.stopPropagation();\n});\n\n/**\n * jQuery\n */\n\n(external_jQuery_default()).fn[dropdown_NAME] = Dropdown._jQueryInterface;\n(external_jQuery_default()).fn[dropdown_NAME].Constructor = Dropdown;\n(external_jQuery_default()).fn[dropdown_NAME].noConflict = function () {\n  (external_jQuery_default()).fn[dropdown_NAME] = dropdown_JQUERY_NO_CONFLICT;\n  return Dropdown._jQueryInterface;\n};\n/* harmony default export */ var dropdown = ((/* unused pure expression or super */ null && (Dropdown)));\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/modal.js\nfunction modal_typeof(o) { \"@babel/helpers - typeof\"; return modal_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, modal_typeof(o); }\nfunction modal_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction modal_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? modal_ownKeys(Object(t), !0).forEach(function (r) { modal_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : modal_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction modal_defineProperty(obj, key, value) { key = modal_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction modal_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction modal_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, modal_toPropertyKey(descriptor.key), descriptor); } }\nfunction modal_createClass(Constructor, protoProps, staticProps) { if (protoProps) modal_defineProperties(Constructor.prototype, protoProps); if (staticProps) modal_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction modal_toPropertyKey(t) { var i = modal_toPrimitive(t, \"string\"); return \"symbol\" == modal_typeof(i) ? i : i + \"\"; }\nfunction modal_toPrimitive(t, r) { if (\"object\" != modal_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != modal_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n\n/**\n * Constants\n */\n\nvar modal_NAME = 'modal';\nvar modal_VERSION = '4.6.2';\nvar modal_DATA_KEY = 'bs.modal';\nvar modal_EVENT_KEY = \".\".concat(modal_DATA_KEY);\nvar modal_DATA_API_KEY = '.data-api';\nvar modal_JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[modal_NAME];\nvar modal_ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\nvar CLASS_NAME_SCROLLABLE = 'modal-dialog-scrollable';\nvar CLASS_NAME_SCROLLBAR_MEASURER = 'modal-scrollbar-measure';\nvar CLASS_NAME_BACKDROP = 'modal-backdrop';\nvar CLASS_NAME_OPEN = 'modal-open';\nvar modal_CLASS_NAME_FADE = 'fade';\nvar modal_CLASS_NAME_SHOW = 'show';\nvar CLASS_NAME_STATIC = 'modal-static';\nvar modal_EVENT_HIDE = \"hide\".concat(modal_EVENT_KEY);\nvar EVENT_HIDE_PREVENTED = \"hidePrevented\".concat(modal_EVENT_KEY);\nvar modal_EVENT_HIDDEN = \"hidden\".concat(modal_EVENT_KEY);\nvar modal_EVENT_SHOW = \"show\".concat(modal_EVENT_KEY);\nvar modal_EVENT_SHOWN = \"shown\".concat(modal_EVENT_KEY);\nvar EVENT_FOCUSIN = \"focusin\".concat(modal_EVENT_KEY);\nvar EVENT_RESIZE = \"resize\".concat(modal_EVENT_KEY);\nvar EVENT_CLICK_DISMISS = \"click.dismiss\".concat(modal_EVENT_KEY);\nvar EVENT_KEYDOWN_DISMISS = \"keydown.dismiss\".concat(modal_EVENT_KEY);\nvar EVENT_MOUSEUP_DISMISS = \"mouseup.dismiss\".concat(modal_EVENT_KEY);\nvar EVENT_MOUSEDOWN_DISMISS = \"mousedown.dismiss\".concat(modal_EVENT_KEY);\nvar modal_EVENT_CLICK_DATA_API = \"click\".concat(modal_EVENT_KEY).concat(modal_DATA_API_KEY);\nvar SELECTOR_DIALOG = '.modal-dialog';\nvar SELECTOR_MODAL_BODY = '.modal-body';\nvar modal_SELECTOR_DATA_TOGGLE = '[data-toggle=\"modal\"]';\nvar SELECTOR_DATA_DISMISS = '[data-dismiss=\"modal\"]';\nvar SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\nvar SELECTOR_STICKY_CONTENT = '.sticky-top';\nvar modal_Default = {\n  backdrop: true,\n  keyboard: true,\n  focus: true,\n  show: true\n};\nvar modal_DefaultType = {\n  backdrop: '(boolean|string)',\n  keyboard: 'boolean',\n  focus: 'boolean',\n  show: 'boolean'\n};\n\n/**\n * Class definition\n */\nvar Modal = /*#__PURE__*/function () {\n  function Modal(element, config) {\n    modal_classCallCheck(this, Modal);\n    this._config = this._getConfig(config);\n    this._element = element;\n    this._dialog = element.querySelector(SELECTOR_DIALOG);\n    this._backdrop = null;\n    this._isShown = false;\n    this._isBodyOverflowing = false;\n    this._ignoreBackdropClick = false;\n    this._isTransitioning = false;\n    this._scrollbarWidth = 0;\n  }\n\n  // Getters\n  return modal_createClass(Modal, [{\n    key: \"toggle\",\n    value:\n    // Public\n    function toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    }\n  }, {\n    key: \"show\",\n    value: function show(relatedTarget) {\n      var _this = this;\n      if (this._isShown || this._isTransitioning) {\n        return;\n      }\n      var showEvent = external_jQuery_default().Event(modal_EVENT_SHOW, {\n        relatedTarget: relatedTarget\n      });\n      external_jQuery_default()(this._element).trigger(showEvent);\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._isShown = true;\n      if (external_jQuery_default()(this._element).hasClass(modal_CLASS_NAME_FADE)) {\n        this._isTransitioning = true;\n      }\n      this._checkScrollbar();\n      this._setScrollbar();\n      this._adjustDialog();\n      this._setEscapeEvent();\n      this._setResizeEvent();\n      external_jQuery_default()(this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function (event) {\n        return _this.hide(event);\n      });\n      external_jQuery_default()(this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function () {\n        external_jQuery_default()(_this._element).one(EVENT_MOUSEUP_DISMISS, function (event) {\n          if (external_jQuery_default()(event.target).is(_this._element)) {\n            _this._ignoreBackdropClick = true;\n          }\n        });\n      });\n      this._showBackdrop(function () {\n        return _this._showElement(relatedTarget);\n      });\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(event) {\n      var _this2 = this;\n      if (event) {\n        event.preventDefault();\n      }\n      if (!this._isShown || this._isTransitioning) {\n        return;\n      }\n      var hideEvent = external_jQuery_default().Event(modal_EVENT_HIDE);\n      external_jQuery_default()(this._element).trigger(hideEvent);\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._isShown = false;\n      var transition = external_jQuery_default()(this._element).hasClass(modal_CLASS_NAME_FADE);\n      if (transition) {\n        this._isTransitioning = true;\n      }\n      this._setEscapeEvent();\n      this._setResizeEvent();\n      external_jQuery_default()(document).off(EVENT_FOCUSIN);\n      external_jQuery_default()(this._element).removeClass(modal_CLASS_NAME_SHOW);\n      external_jQuery_default()(this._element).off(EVENT_CLICK_DISMISS);\n      external_jQuery_default()(this._dialog).off(EVENT_MOUSEDOWN_DISMISS);\n      if (transition) {\n        var transitionDuration = util.getTransitionDurationFromElement(this._element);\n        external_jQuery_default()(this._element).one(util.TRANSITION_END, function (event) {\n          return _this2._hideModal(event);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        this._hideModal();\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      [window, this._element, this._dialog].forEach(function (htmlElement) {\n        return external_jQuery_default()(htmlElement).off(modal_EVENT_KEY);\n      });\n\n      /**\n       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\n       * Do not move `document` in `htmlElements` array\n       * It will remove `EVENT_CLICK_DATA_API` event that should remain\n       */\n      external_jQuery_default()(document).off(EVENT_FOCUSIN);\n      external_jQuery_default().removeData(this._element, modal_DATA_KEY);\n      this._config = null;\n      this._element = null;\n      this._dialog = null;\n      this._backdrop = null;\n      this._isShown = null;\n      this._isBodyOverflowing = null;\n      this._ignoreBackdropClick = null;\n      this._isTransitioning = null;\n      this._scrollbarWidth = null;\n    }\n  }, {\n    key: \"handleUpdate\",\n    value: function handleUpdate() {\n      this._adjustDialog();\n    }\n\n    // Private\n  }, {\n    key: \"_getConfig\",\n    value: function _getConfig(config) {\n      config = modal_objectSpread(modal_objectSpread({}, modal_Default), config);\n      util.typeCheckConfig(modal_NAME, config, modal_DefaultType);\n      return config;\n    }\n  }, {\n    key: \"_triggerBackdropTransition\",\n    value: function _triggerBackdropTransition() {\n      var _this3 = this;\n      var hideEventPrevented = external_jQuery_default().Event(EVENT_HIDE_PREVENTED);\n      external_jQuery_default()(this._element).trigger(hideEventPrevented);\n      if (hideEventPrevented.isDefaultPrevented()) {\n        return;\n      }\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n      if (!isModalOverflowing) {\n        this._element.style.overflowY = 'hidden';\n      }\n      this._element.classList.add(CLASS_NAME_STATIC);\n      var modalTransitionDuration = util.getTransitionDurationFromElement(this._dialog);\n      external_jQuery_default()(this._element).off(util.TRANSITION_END);\n      external_jQuery_default()(this._element).one(util.TRANSITION_END, function () {\n        _this3._element.classList.remove(CLASS_NAME_STATIC);\n        if (!isModalOverflowing) {\n          external_jQuery_default()(_this3._element).one(util.TRANSITION_END, function () {\n            _this3._element.style.overflowY = '';\n          }).emulateTransitionEnd(_this3._element, modalTransitionDuration);\n        }\n      }).emulateTransitionEnd(modalTransitionDuration);\n      this._element.focus();\n    }\n  }, {\n    key: \"_showElement\",\n    value: function _showElement(relatedTarget) {\n      var _this4 = this;\n      var transition = external_jQuery_default()(this._element).hasClass(modal_CLASS_NAME_FADE);\n      var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // Don't move modal's DOM position\n        document.body.appendChild(this._element);\n      }\n      this._element.style.display = 'block';\n      this._element.removeAttribute('aria-hidden');\n      this._element.setAttribute('aria-modal', true);\n      this._element.setAttribute('role', 'dialog');\n      if (external_jQuery_default()(this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {\n        modalBody.scrollTop = 0;\n      } else {\n        this._element.scrollTop = 0;\n      }\n      if (transition) {\n        util.reflow(this._element);\n      }\n      external_jQuery_default()(this._element).addClass(modal_CLASS_NAME_SHOW);\n      if (this._config.focus) {\n        this._enforceFocus();\n      }\n      var shownEvent = external_jQuery_default().Event(modal_EVENT_SHOWN, {\n        relatedTarget: relatedTarget\n      });\n      var transitionComplete = function transitionComplete() {\n        if (_this4._config.focus) {\n          _this4._element.focus();\n        }\n        _this4._isTransitioning = false;\n        external_jQuery_default()(_this4._element).trigger(shownEvent);\n      };\n      if (transition) {\n        var transitionDuration = util.getTransitionDurationFromElement(this._dialog);\n        external_jQuery_default()(this._dialog).one(util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\n      } else {\n        transitionComplete();\n      }\n    }\n  }, {\n    key: \"_enforceFocus\",\n    value: function _enforceFocus() {\n      var _this5 = this;\n      external_jQuery_default()(document).off(EVENT_FOCUSIN) // Guard against infinite focus loop\n      .on(EVENT_FOCUSIN, function (event) {\n        if (document !== event.target && _this5._element !== event.target && external_jQuery_default()(_this5._element).has(event.target).length === 0) {\n          _this5._element.focus();\n        }\n      });\n    }\n  }, {\n    key: \"_setEscapeEvent\",\n    value: function _setEscapeEvent() {\n      var _this6 = this;\n      if (this._isShown) {\n        external_jQuery_default()(this._element).on(EVENT_KEYDOWN_DISMISS, function (event) {\n          if (_this6._config.keyboard && event.which === modal_ESCAPE_KEYCODE) {\n            event.preventDefault();\n            _this6.hide();\n          } else if (!_this6._config.keyboard && event.which === modal_ESCAPE_KEYCODE) {\n            _this6._triggerBackdropTransition();\n          }\n        });\n      } else if (!this._isShown) {\n        external_jQuery_default()(this._element).off(EVENT_KEYDOWN_DISMISS);\n      }\n    }\n  }, {\n    key: \"_setResizeEvent\",\n    value: function _setResizeEvent() {\n      var _this7 = this;\n      if (this._isShown) {\n        external_jQuery_default()(window).on(EVENT_RESIZE, function (event) {\n          return _this7.handleUpdate(event);\n        });\n      } else {\n        external_jQuery_default()(window).off(EVENT_RESIZE);\n      }\n    }\n  }, {\n    key: \"_hideModal\",\n    value: function _hideModal() {\n      var _this8 = this;\n      this._element.style.display = 'none';\n      this._element.setAttribute('aria-hidden', true);\n      this._element.removeAttribute('aria-modal');\n      this._element.removeAttribute('role');\n      this._isTransitioning = false;\n      this._showBackdrop(function () {\n        external_jQuery_default()(document.body).removeClass(CLASS_NAME_OPEN);\n        _this8._resetAdjustments();\n        _this8._resetScrollbar();\n        external_jQuery_default()(_this8._element).trigger(modal_EVENT_HIDDEN);\n      });\n    }\n  }, {\n    key: \"_removeBackdrop\",\n    value: function _removeBackdrop() {\n      if (this._backdrop) {\n        external_jQuery_default()(this._backdrop).remove();\n        this._backdrop = null;\n      }\n    }\n  }, {\n    key: \"_showBackdrop\",\n    value: function _showBackdrop(callback) {\n      var _this9 = this;\n      var animate = external_jQuery_default()(this._element).hasClass(modal_CLASS_NAME_FADE) ? modal_CLASS_NAME_FADE : '';\n      if (this._isShown && this._config.backdrop) {\n        this._backdrop = document.createElement('div');\n        this._backdrop.className = CLASS_NAME_BACKDROP;\n        if (animate) {\n          this._backdrop.classList.add(animate);\n        }\n        external_jQuery_default()(this._backdrop).appendTo(document.body);\n        external_jQuery_default()(this._element).on(EVENT_CLICK_DISMISS, function (event) {\n          if (_this9._ignoreBackdropClick) {\n            _this9._ignoreBackdropClick = false;\n            return;\n          }\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n          if (_this9._config.backdrop === 'static') {\n            _this9._triggerBackdropTransition();\n          } else {\n            _this9.hide();\n          }\n        });\n        if (animate) {\n          util.reflow(this._backdrop);\n        }\n        external_jQuery_default()(this._backdrop).addClass(modal_CLASS_NAME_SHOW);\n        if (!callback) {\n          return;\n        }\n        if (!animate) {\n          callback();\n          return;\n        }\n        var backdropTransitionDuration = util.getTransitionDurationFromElement(this._backdrop);\n        external_jQuery_default()(this._backdrop).one(util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\n      } else if (!this._isShown && this._backdrop) {\n        external_jQuery_default()(this._backdrop).removeClass(modal_CLASS_NAME_SHOW);\n        var callbackRemove = function callbackRemove() {\n          _this9._removeBackdrop();\n          if (callback) {\n            callback();\n          }\n        };\n        if (external_jQuery_default()(this._element).hasClass(modal_CLASS_NAME_FADE)) {\n          var _backdropTransitionDuration = util.getTransitionDurationFromElement(this._backdrop);\n          external_jQuery_default()(this._backdrop).one(util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    }\n\n    // ----------------------------------------------------------------------\n    // the following methods are used to handle overflowing modals\n    // todo (fat): these should probably be refactored out of modal.js\n    // ----------------------------------------------------------------------\n  }, {\n    key: \"_adjustDialog\",\n    value: function _adjustDialog() {\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n      if (!this._isBodyOverflowing && isModalOverflowing) {\n        this._element.style.paddingLeft = \"\".concat(this._scrollbarWidth, \"px\");\n      }\n      if (this._isBodyOverflowing && !isModalOverflowing) {\n        this._element.style.paddingRight = \"\".concat(this._scrollbarWidth, \"px\");\n      }\n    }\n  }, {\n    key: \"_resetAdjustments\",\n    value: function _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    }\n  }, {\n    key: \"_checkScrollbar\",\n    value: function _checkScrollbar() {\n      var rect = document.body.getBoundingClientRect();\n      this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;\n      this._scrollbarWidth = this._getScrollbarWidth();\n    }\n  }, {\n    key: \"_setScrollbar\",\n    value: function _setScrollbar() {\n      var _this10 = this;\n      if (this._isBodyOverflowing) {\n        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set\n        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\n        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n        var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT));\n\n        // Adjust fixed content padding\n        external_jQuery_default()(fixedContent).each(function (index, element) {\n          var actualPadding = element.style.paddingRight;\n          var calculatedPadding = external_jQuery_default()(element).css('padding-right');\n          external_jQuery_default()(element).data('padding-right', actualPadding).css('padding-right', \"\".concat(parseFloat(calculatedPadding) + _this10._scrollbarWidth, \"px\"));\n        });\n\n        // Adjust sticky content margin\n        external_jQuery_default()(stickyContent).each(function (index, element) {\n          var actualMargin = element.style.marginRight;\n          var calculatedMargin = external_jQuery_default()(element).css('margin-right');\n          external_jQuery_default()(element).data('margin-right', actualMargin).css('margin-right', \"\".concat(parseFloat(calculatedMargin) - _this10._scrollbarWidth, \"px\"));\n        });\n\n        // Adjust body padding\n        var actualPadding = document.body.style.paddingRight;\n        var calculatedPadding = external_jQuery_default()(document.body).css('padding-right');\n        external_jQuery_default()(document.body).data('padding-right', actualPadding).css('padding-right', \"\".concat(parseFloat(calculatedPadding) + this._scrollbarWidth, \"px\"));\n      }\n      external_jQuery_default()(document.body).addClass(CLASS_NAME_OPEN);\n    }\n  }, {\n    key: \"_resetScrollbar\",\n    value: function _resetScrollbar() {\n      // Restore fixed content padding\n      var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n      external_jQuery_default()(fixedContent).each(function (index, element) {\n        var padding = external_jQuery_default()(element).data('padding-right');\n        external_jQuery_default()(element).removeData('padding-right');\n        element.style.paddingRight = padding ? padding : '';\n      });\n\n      // Restore sticky content\n      var elements = [].slice.call(document.querySelectorAll(\"\".concat(SELECTOR_STICKY_CONTENT)));\n      external_jQuery_default()(elements).each(function (index, element) {\n        var margin = external_jQuery_default()(element).data('margin-right');\n        if (typeof margin !== 'undefined') {\n          external_jQuery_default()(element).css('margin-right', margin).removeData('margin-right');\n        }\n      });\n\n      // Restore body padding\n      var padding = external_jQuery_default()(document.body).data('padding-right');\n      external_jQuery_default()(document.body).removeData('padding-right');\n      document.body.style.paddingRight = padding ? padding : '';\n    }\n  }, {\n    key: \"_getScrollbarWidth\",\n    value: function _getScrollbarWidth() {\n      // thx d.walsh\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;\n      document.body.appendChild(scrollDiv);\n      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get: function get() {\n      return modal_VERSION;\n    }\n  }, {\n    key: \"Default\",\n    get: function get() {\n      return modal_Default;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        var data = external_jQuery_default()(this).data(modal_DATA_KEY);\n        var _config = modal_objectSpread(modal_objectSpread(modal_objectSpread({}, modal_Default), external_jQuery_default()(this).data()), modal_typeof(config) === 'object' && config ? config : {});\n        if (!data) {\n          data = new Modal(this, _config);\n          external_jQuery_default()(this).data(modal_DATA_KEY, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](relatedTarget);\n        } else if (_config.show) {\n          data.show(relatedTarget);\n        }\n      });\n    }\n  }]);\n}();\n/**\n * Data API implementation\n */\nexternal_jQuery_default()(document).on(modal_EVENT_CLICK_DATA_API, modal_SELECTOR_DATA_TOGGLE, function (event) {\n  var _this11 = this;\n  var target;\n  var selector = util.getSelectorFromElement(this);\n  if (selector) {\n    target = document.querySelector(selector);\n  }\n  var config = external_jQuery_default()(target).data(modal_DATA_KEY) ? 'toggle' : modal_objectSpread(modal_objectSpread({}, external_jQuery_default()(target).data()), external_jQuery_default()(this).data());\n  if (this.tagName === 'A' || this.tagName === 'AREA') {\n    event.preventDefault();\n  }\n  var $target = external_jQuery_default()(target).one(modal_EVENT_SHOW, function (showEvent) {\n    if (showEvent.isDefaultPrevented()) {\n      // Only register focus restorer if modal will actually get shown\n      return;\n    }\n    $target.one(modal_EVENT_HIDDEN, function () {\n      if (external_jQuery_default()(_this11).is(':visible')) {\n        _this11.focus();\n      }\n    });\n  });\n  Modal._jQueryInterface.call(external_jQuery_default()(target), config, this);\n});\n\n/**\n * jQuery\n */\n\n(external_jQuery_default()).fn[modal_NAME] = Modal._jQueryInterface;\n(external_jQuery_default()).fn[modal_NAME].Constructor = Modal;\n(external_jQuery_default()).fn[modal_NAME].noConflict = function () {\n  (external_jQuery_default()).fn[modal_NAME] = modal_JQUERY_NO_CONFLICT;\n  return Modal._jQueryInterface;\n};\n/* harmony default export */ var modal = ((/* unused pure expression or super */ null && (Modal)));\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/tools/sanitizer.js\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): tools/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nvar uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];\nvar ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\nvar DefaultWhitelist = {\n  // Global attributes allowed on any supplied element below.\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n  a: ['target', 'href', 'title', 'rel'],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  div: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n */\nvar SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;\n\n/**\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\n *\n * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n */\nvar DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\nfunction allowedAttribute(attr, allowedAttributeList) {\n  var attrName = attr.nodeName.toLowerCase();\n  if (allowedAttributeList.indexOf(attrName) !== -1) {\n    if (uriAttrs.indexOf(attrName) !== -1) {\n      return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));\n    }\n    return true;\n  }\n  var regExp = allowedAttributeList.filter(function (attrRegex) {\n    return attrRegex instanceof RegExp;\n  });\n\n  // Check if a regular expression validates the attribute.\n  for (var i = 0, len = regExp.length; i < len; i++) {\n    if (regExp[i].test(attrName)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {\n  if (unsafeHtml.length === 0) {\n    return unsafeHtml;\n  }\n  if (sanitizeFn && typeof sanitizeFn === 'function') {\n    return sanitizeFn(unsafeHtml);\n  }\n  var domParser = new window.DOMParser();\n  var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n  var whitelistKeys = Object.keys(whiteList);\n  var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));\n  var _loop = function _loop() {\n    var el = elements[i];\n    var elName = el.nodeName.toLowerCase();\n    if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {\n      el.parentNode.removeChild(el);\n      return 1; // continue\n    }\n    var attributeList = [].slice.call(el.attributes);\n    // eslint-disable-next-line unicorn/prefer-spread\n    var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\n    attributeList.forEach(function (attr) {\n      if (!allowedAttribute(attr, whitelistedAttributes)) {\n        el.removeAttribute(attr.nodeName);\n      }\n    });\n  };\n  for (var i = 0, len = elements.length; i < len; i++) {\n    if (_loop()) continue;\n  }\n  return createdDocument.body.innerHTML;\n}\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/tooltip.js\nfunction tooltip_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction tooltip_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? tooltip_ownKeys(Object(t), !0).forEach(function (r) { tooltip_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : tooltip_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction tooltip_defineProperty(obj, key, value) { key = tooltip_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction tooltip_typeof(o) { \"@babel/helpers - typeof\"; return tooltip_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, tooltip_typeof(o); }\nfunction tooltip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction tooltip_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, tooltip_toPropertyKey(descriptor.key), descriptor); } }\nfunction tooltip_createClass(Constructor, protoProps, staticProps) { if (protoProps) tooltip_defineProperties(Constructor.prototype, protoProps); if (staticProps) tooltip_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction tooltip_toPropertyKey(t) { var i = tooltip_toPrimitive(t, \"string\"); return \"symbol\" == tooltip_typeof(i) ? i : i + \"\"; }\nfunction tooltip_toPrimitive(t, r) { if (\"object\" != tooltip_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != tooltip_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n\n\n\n/**\n * Constants\n */\n\nvar tooltip_NAME = 'tooltip';\nvar tooltip_VERSION = '4.6.2';\nvar tooltip_DATA_KEY = 'bs.tooltip';\nvar tooltip_EVENT_KEY = \".\".concat(tooltip_DATA_KEY);\nvar tooltip_JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[tooltip_NAME];\nvar CLASS_PREFIX = 'bs-tooltip';\nvar BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\".concat(CLASS_PREFIX, \"\\\\S+\"), 'g');\nvar DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\nvar tooltip_CLASS_NAME_FADE = 'fade';\nvar tooltip_CLASS_NAME_SHOW = 'show';\nvar HOVER_STATE_SHOW = 'show';\nvar HOVER_STATE_OUT = 'out';\nvar SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\nvar SELECTOR_ARROW = '.arrow';\nvar TRIGGER_HOVER = 'hover';\nvar TRIGGER_FOCUS = 'focus';\nvar TRIGGER_CLICK = 'click';\nvar TRIGGER_MANUAL = 'manual';\nvar AttachmentMap = {\n  AUTO: 'auto',\n  TOP: 'top',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  LEFT: 'left'\n};\nvar tooltip_Default = {\n  animation: true,\n  template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n  trigger: 'hover focus',\n  title: '',\n  delay: 0,\n  html: false,\n  selector: false,\n  placement: 'top',\n  offset: 0,\n  container: false,\n  fallbackPlacement: 'flip',\n  boundary: 'scrollParent',\n  customClass: '',\n  sanitize: true,\n  sanitizeFn: null,\n  whiteList: DefaultWhitelist,\n  popperConfig: null\n};\nvar tooltip_DefaultType = {\n  animation: 'boolean',\n  template: 'string',\n  title: '(string|element|function)',\n  trigger: 'string',\n  delay: '(number|object)',\n  html: 'boolean',\n  selector: '(string|boolean)',\n  placement: '(string|function)',\n  offset: '(number|string|function)',\n  container: '(string|element|boolean)',\n  fallbackPlacement: '(string|array)',\n  boundary: '(string|element)',\n  customClass: '(string|function)',\n  sanitize: 'boolean',\n  sanitizeFn: '(null|function)',\n  whiteList: 'object',\n  popperConfig: '(null|object)'\n};\nvar Event = {\n  HIDE: \"hide\".concat(tooltip_EVENT_KEY),\n  HIDDEN: \"hidden\".concat(tooltip_EVENT_KEY),\n  SHOW: \"show\".concat(tooltip_EVENT_KEY),\n  SHOWN: \"shown\".concat(tooltip_EVENT_KEY),\n  INSERTED: \"inserted\".concat(tooltip_EVENT_KEY),\n  CLICK: \"click\".concat(tooltip_EVENT_KEY),\n  FOCUSIN: \"focusin\".concat(tooltip_EVENT_KEY),\n  FOCUSOUT: \"focusout\".concat(tooltip_EVENT_KEY),\n  MOUSEENTER: \"mouseenter\".concat(tooltip_EVENT_KEY),\n  MOUSELEAVE: \"mouseleave\".concat(tooltip_EVENT_KEY)\n};\n\n/**\n * Class definition\n */\nvar Tooltip = /*#__PURE__*/function () {\n  function Tooltip(element, config) {\n    tooltip_classCallCheck(this, Tooltip);\n    if (typeof popper === 'undefined') {\n      throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n    }\n\n    // Private\n    this._isEnabled = true;\n    this._timeout = 0;\n    this._hoverState = '';\n    this._activeTrigger = {};\n    this._popper = null;\n\n    // Protected\n    this.element = element;\n    this.config = this._getConfig(config);\n    this.tip = null;\n    this._setListeners();\n  }\n\n  // Getters\n  return tooltip_createClass(Tooltip, [{\n    key: \"enable\",\n    value:\n    // Public\n    function enable() {\n      this._isEnabled = true;\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this._isEnabled = false;\n    }\n  }, {\n    key: \"toggleEnabled\",\n    value: function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    }\n  }, {\n    key: \"toggle\",\n    value: function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = external_jQuery_default()(event.currentTarget).data(dataKey);\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          external_jQuery_default()(event.currentTarget).data(dataKey, context);\n        }\n        context._activeTrigger.click = !context._activeTrigger.click;\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if (external_jQuery_default()(this.getTipElement()).hasClass(tooltip_CLASS_NAME_SHOW)) {\n          this._leave(null, this);\n          return;\n        }\n        this._enter(null, this);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      clearTimeout(this._timeout);\n      external_jQuery_default().removeData(this.element, this.constructor.DATA_KEY);\n      external_jQuery_default()(this.element).off(this.constructor.EVENT_KEY);\n      external_jQuery_default()(this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);\n      if (this.tip) {\n        external_jQuery_default()(this.tip).remove();\n      }\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n      if (this._popper) {\n        this._popper.destroy();\n      }\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var _this = this;\n      if (external_jQuery_default()(this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n      var showEvent = external_jQuery_default().Event(this.constructor.Event.SHOW);\n      if (this.isWithContent() && this._isEnabled) {\n        external_jQuery_default()(this.element).trigger(showEvent);\n        var shadowRoot = util.findShadowRoot(this.element);\n        var isInTheDom = external_jQuery_default().contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n        var tip = this.getTipElement();\n        var tipId = util.getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n        if (this.config.animation) {\n          external_jQuery_default()(tip).addClass(tooltip_CLASS_NAME_FADE);\n        }\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n        var attachment = this._getAttachment(placement);\n        this.addAttachmentClass(attachment);\n        var container = this._getContainer();\n        external_jQuery_default()(tip).data(this.constructor.DATA_KEY, this);\n        if (!external_jQuery_default().contains(this.element.ownerDocument.documentElement, this.tip)) {\n          external_jQuery_default()(tip).appendTo(container);\n        }\n        external_jQuery_default()(this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new popper(this.element, tip, this._getPopperConfig(attachment));\n        external_jQuery_default()(tip).addClass(tooltip_CLASS_NAME_SHOW);\n        external_jQuery_default()(tip).addClass(this.config.customClass);\n\n        // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n        if ('ontouchstart' in document.documentElement) {\n          external_jQuery_default()(document.body).children().on('mouseover', null, (external_jQuery_default()).noop);\n        }\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          external_jQuery_default()(_this.element).trigger(_this.constructor.Event.SHOWN);\n          if (prevHoverState === HOVER_STATE_OUT) {\n            _this._leave(null, _this);\n          }\n        };\n        if (external_jQuery_default()(this.tip).hasClass(tooltip_CLASS_NAME_FADE)) {\n          var transitionDuration = util.getTransitionDurationFromElement(this.tip);\n          external_jQuery_default()(this.tip).one(util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(callback) {\n      var _this2 = this;\n      var tip = this.getTipElement();\n      var hideEvent = external_jQuery_default().Event(this.constructor.Event.HIDE);\n      var complete = function complete() {\n        if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n        _this2._cleanTipClass();\n        _this2.element.removeAttribute('aria-describedby');\n        external_jQuery_default()(_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n        if (callback) {\n          callback();\n        }\n      };\n      external_jQuery_default()(this.element).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      external_jQuery_default()(tip).removeClass(tooltip_CLASS_NAME_SHOW);\n\n      // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n      if ('ontouchstart' in document.documentElement) {\n        external_jQuery_default()(document.body).children().off('mouseover', null, (external_jQuery_default()).noop);\n      }\n      this._activeTrigger[TRIGGER_CLICK] = false;\n      this._activeTrigger[TRIGGER_FOCUS] = false;\n      this._activeTrigger[TRIGGER_HOVER] = false;\n      if (external_jQuery_default()(this.tip).hasClass(tooltip_CLASS_NAME_FADE)) {\n        var transitionDuration = util.getTransitionDurationFromElement(tip);\n        external_jQuery_default()(tip).one(util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n      this._hoverState = '';\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    }\n\n    // Protected\n  }, {\n    key: \"isWithContent\",\n    value: function isWithContent() {\n      return Boolean(this.getTitle());\n    }\n  }, {\n    key: \"addAttachmentClass\",\n    value: function addAttachmentClass(attachment) {\n      external_jQuery_default()(this.getTipElement()).addClass(\"\".concat(CLASS_PREFIX, \"-\").concat(attachment));\n    }\n  }, {\n    key: \"getTipElement\",\n    value: function getTipElement() {\n      this.tip = this.tip || external_jQuery_default()(this.config.template)[0];\n      return this.tip;\n    }\n  }, {\n    key: \"setContent\",\n    value: function setContent() {\n      var tip = this.getTipElement();\n      this.setElementContent(external_jQuery_default()(tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());\n      external_jQuery_default()(tip).removeClass(\"\".concat(tooltip_CLASS_NAME_FADE, \" \").concat(tooltip_CLASS_NAME_SHOW));\n    }\n  }, {\n    key: \"setElementContent\",\n    value: function setElementContent($element, content) {\n      if (tooltip_typeof(content) === 'object' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (this.config.html) {\n          if (!external_jQuery_default()(content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text(external_jQuery_default()(content).text());\n        }\n        return;\n      }\n      if (this.config.html) {\n        if (this.config.sanitize) {\n          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);\n        }\n        $element.html(content);\n      } else {\n        $element.text(content);\n      }\n    }\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n      return title;\n    }\n\n    // Private\n  }, {\n    key: \"_getPopperConfig\",\n    value: function _getPopperConfig(attachment) {\n      var _this3 = this;\n      var defaultBsConfig = {\n        placement: attachment,\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            behavior: this.config.fallbackPlacement\n          },\n          arrow: {\n            element: SELECTOR_ARROW\n          },\n          preventOverflow: {\n            boundariesElement: this.config.boundary\n          }\n        },\n        onCreate: function onCreate(data) {\n          if (data.originalPlacement !== data.placement) {\n            _this3._handlePopperPlacementChange(data);\n          }\n        },\n        onUpdate: function onUpdate(data) {\n          return _this3._handlePopperPlacementChange(data);\n        }\n      };\n      return tooltip_objectSpread(tooltip_objectSpread({}, defaultBsConfig), this.config.popperConfig);\n    }\n  }, {\n    key: \"_getOffset\",\n    value: function _getOffset() {\n      var _this4 = this;\n      var offset = {};\n      if (typeof this.config.offset === 'function') {\n        offset.fn = function (data) {\n          data.offsets = tooltip_objectSpread(tooltip_objectSpread({}, data.offsets), _this4.config.offset(data.offsets, _this4.element));\n          return data;\n        };\n      } else {\n        offset.offset = this.config.offset;\n      }\n      return offset;\n    }\n  }, {\n    key: \"_getContainer\",\n    value: function _getContainer() {\n      if (this.config.container === false) {\n        return document.body;\n      }\n      if (util.isElement(this.config.container)) {\n        return external_jQuery_default()(this.config.container);\n      }\n      return external_jQuery_default()(document).find(this.config.container);\n    }\n  }, {\n    key: \"_getAttachment\",\n    value: function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    }\n  }, {\n    key: \"_setListeners\",\n    value: function _setListeners() {\n      var _this5 = this;\n      var triggers = this.config.trigger.split(' ');\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          external_jQuery_default()(_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {\n            return _this5.toggle(event);\n          });\n        } else if (trigger !== TRIGGER_MANUAL) {\n          var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;\n          var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;\n          external_jQuery_default()(_this5.element).on(eventIn, _this5.config.selector, function (event) {\n            return _this5._enter(event);\n          }).on(eventOut, _this5.config.selector, function (event) {\n            return _this5._leave(event);\n          });\n        }\n      });\n      this._hideModalHandler = function () {\n        if (_this5.element) {\n          _this5.hide();\n        }\n      };\n      external_jQuery_default()(this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);\n      if (this.config.selector) {\n        this.config = tooltip_objectSpread(tooltip_objectSpread({}, this.config), {}, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    }\n  }, {\n    key: \"_fixTitle\",\n    value: function _fixTitle() {\n      var titleType = tooltip_typeof(this.element.getAttribute('data-original-title'));\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    }\n  }, {\n    key: \"_enter\",\n    value: function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || external_jQuery_default()(event.currentTarget).data(dataKey);\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        external_jQuery_default()(event.currentTarget).data(dataKey, context);\n      }\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n      }\n      if (external_jQuery_default()(context.getTipElement()).hasClass(tooltip_CLASS_NAME_SHOW) || context._hoverState === HOVER_STATE_SHOW) {\n        context._hoverState = HOVER_STATE_SHOW;\n        return;\n      }\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_SHOW;\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    }\n  }, {\n    key: \"_leave\",\n    value: function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || external_jQuery_default()(event.currentTarget).data(dataKey);\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        external_jQuery_default()(event.currentTarget).data(dataKey, context);\n      }\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;\n      }\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_OUT;\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    }\n  }, {\n    key: \"_isWithActiveTrigger\",\n    value: function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_getConfig\",\n    value: function _getConfig(config) {\n      var dataAttributes = external_jQuery_default()(this.element).data();\n      Object.keys(dataAttributes).forEach(function (dataAttr) {\n        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {\n          delete dataAttributes[dataAttr];\n        }\n      });\n      config = tooltip_objectSpread(tooltip_objectSpread(tooltip_objectSpread({}, this.constructor.Default), dataAttributes), tooltip_typeof(config) === 'object' && config ? config : {});\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n      util.typeCheckConfig(tooltip_NAME, config, this.constructor.DefaultType);\n      if (config.sanitize) {\n        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);\n      }\n      return config;\n    }\n  }, {\n    key: \"_getDelegateConfig\",\n    value: function _getDelegateConfig() {\n      var config = {};\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n      return config;\n    }\n  }, {\n    key: \"_cleanTipClass\",\n    value: function _cleanTipClass() {\n      var $tip = external_jQuery_default()(this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n      if (tabClass !== null && tabClass.length) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    }\n  }, {\n    key: \"_handlePopperPlacementChange\",\n    value: function _handlePopperPlacementChange(popperData) {\n      this.tip = popperData.instance.popper;\n      this._cleanTipClass();\n      this.addAttachmentClass(this._getAttachment(popperData.placement));\n    }\n  }, {\n    key: \"_fixTransition\",\n    value: function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n      if (tip.getAttribute('x-placement') !== null) {\n        return;\n      }\n      external_jQuery_default()(tip).removeClass(tooltip_CLASS_NAME_FADE);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get: function get() {\n      return tooltip_VERSION;\n    }\n  }, {\n    key: \"Default\",\n    get: function get() {\n      return tooltip_Default;\n    }\n  }, {\n    key: \"NAME\",\n    get: function get() {\n      return tooltip_NAME;\n    }\n  }, {\n    key: \"DATA_KEY\",\n    get: function get() {\n      return tooltip_DATA_KEY;\n    }\n  }, {\n    key: \"Event\",\n    get: function get() {\n      return Event;\n    }\n  }, {\n    key: \"EVENT_KEY\",\n    get: function get() {\n      return tooltip_EVENT_KEY;\n    }\n  }, {\n    key: \"DefaultType\",\n    get: function get() {\n      return tooltip_DefaultType;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = external_jQuery_default()(this);\n        var data = $element.data(tooltip_DATA_KEY);\n        var _config = tooltip_typeof(config) === 'object' && config;\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $element.data(tooltip_DATA_KEY, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        }\n      });\n    }\n  }]);\n}();\n/**\n * jQuery\n */\n(external_jQuery_default()).fn[tooltip_NAME] = Tooltip._jQueryInterface;\n(external_jQuery_default()).fn[tooltip_NAME].Constructor = Tooltip;\n(external_jQuery_default()).fn[tooltip_NAME].noConflict = function () {\n  (external_jQuery_default()).fn[tooltip_NAME] = tooltip_JQUERY_NO_CONFLICT;\n  return Tooltip._jQueryInterface;\n};\n/* harmony default export */ var tooltip = (Tooltip);\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/popover.js\nfunction popover_typeof(o) { \"@babel/helpers - typeof\"; return popover_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, popover_typeof(o); }\nfunction popover_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction popover_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, popover_toPropertyKey(descriptor.key), descriptor); } }\nfunction popover_createClass(Constructor, protoProps, staticProps) { if (protoProps) popover_defineProperties(Constructor.prototype, protoProps); if (staticProps) popover_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (popover_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction popover_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction popover_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? popover_ownKeys(Object(t), !0).forEach(function (r) { popover_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : popover_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction popover_defineProperty(obj, key, value) { key = popover_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction popover_toPropertyKey(t) { var i = popover_toPrimitive(t, \"string\"); return \"symbol\" == popover_typeof(i) ? i : i + \"\"; }\nfunction popover_toPrimitive(t, r) { if (\"object\" != popover_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != popover_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n\n/**\n * Constants\n */\n\nvar popover_NAME = 'popover';\nvar popover_VERSION = '4.6.2';\nvar popover_DATA_KEY = 'bs.popover';\nvar popover_EVENT_KEY = \".\".concat(popover_DATA_KEY);\nvar popover_JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[popover_NAME];\nvar popover_CLASS_PREFIX = 'bs-popover';\nvar popover_BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\".concat(popover_CLASS_PREFIX, \"\\\\S+\"), 'g');\nvar popover_CLASS_NAME_FADE = 'fade';\nvar popover_CLASS_NAME_SHOW = 'show';\nvar SELECTOR_TITLE = '.popover-header';\nvar SELECTOR_CONTENT = '.popover-body';\nvar popover_Default = popover_objectSpread(popover_objectSpread({}, tooltip.Default), {}, {\n  placement: 'right',\n  trigger: 'click',\n  content: '',\n  template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div></div>'\n});\nvar popover_DefaultType = popover_objectSpread(popover_objectSpread({}, tooltip.DefaultType), {}, {\n  content: '(string|element|function)'\n});\nvar popover_Event = {\n  HIDE: \"hide\".concat(popover_EVENT_KEY),\n  HIDDEN: \"hidden\".concat(popover_EVENT_KEY),\n  SHOW: \"show\".concat(popover_EVENT_KEY),\n  SHOWN: \"shown\".concat(popover_EVENT_KEY),\n  INSERTED: \"inserted\".concat(popover_EVENT_KEY),\n  CLICK: \"click\".concat(popover_EVENT_KEY),\n  FOCUSIN: \"focusin\".concat(popover_EVENT_KEY),\n  FOCUSOUT: \"focusout\".concat(popover_EVENT_KEY),\n  MOUSEENTER: \"mouseenter\".concat(popover_EVENT_KEY),\n  MOUSELEAVE: \"mouseleave\".concat(popover_EVENT_KEY)\n};\n\n/**\n * Class definition\n */\nvar Popover = /*#__PURE__*/function (_Tooltip) {\n  function Popover() {\n    popover_classCallCheck(this, Popover);\n    return _callSuper(this, Popover, arguments);\n  }\n  _inherits(Popover, _Tooltip);\n  return popover_createClass(Popover, [{\n    key: \"isWithContent\",\n    value:\n    // Overrides\n    function isWithContent() {\n      return this.getTitle() || this._getContent();\n    }\n  }, {\n    key: \"addAttachmentClass\",\n    value: function addAttachmentClass(attachment) {\n      external_jQuery_default()(this.getTipElement()).addClass(\"\".concat(popover_CLASS_PREFIX, \"-\").concat(attachment));\n    }\n  }, {\n    key: \"getTipElement\",\n    value: function getTipElement() {\n      this.tip = this.tip || external_jQuery_default()(this.config.template)[0];\n      return this.tip;\n    }\n  }, {\n    key: \"setContent\",\n    value: function setContent() {\n      var $tip = external_jQuery_default()(this.getTipElement());\n\n      // We use append for html objects to maintain js events\n      this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());\n      var content = this._getContent();\n      if (typeof content === 'function') {\n        content = content.call(this.element);\n      }\n      this.setElementContent($tip.find(SELECTOR_CONTENT), content);\n      $tip.removeClass(\"\".concat(popover_CLASS_NAME_FADE, \" \").concat(popover_CLASS_NAME_SHOW));\n    }\n\n    // Private\n  }, {\n    key: \"_getContent\",\n    value: function _getContent() {\n      return this.element.getAttribute('data-content') || this.config.content;\n    }\n  }, {\n    key: \"_cleanTipClass\",\n    value: function _cleanTipClass() {\n      var $tip = external_jQuery_default()(this.getTipElement());\n      var tabClass = $tip.attr('class').match(popover_BSCLS_PREFIX_REGEX);\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get:\n    // Getters\n    function get() {\n      return popover_VERSION;\n    }\n  }, {\n    key: \"Default\",\n    get: function get() {\n      return popover_Default;\n    }\n  }, {\n    key: \"NAME\",\n    get: function get() {\n      return popover_NAME;\n    }\n  }, {\n    key: \"DATA_KEY\",\n    get: function get() {\n      return popover_DATA_KEY;\n    }\n  }, {\n    key: \"Event\",\n    get: function get() {\n      return popover_Event;\n    }\n  }, {\n    key: \"EVENT_KEY\",\n    get: function get() {\n      return popover_EVENT_KEY;\n    }\n  }, {\n    key: \"DefaultType\",\n    get: function get() {\n      return popover_DefaultType;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = external_jQuery_default()(this).data(popover_DATA_KEY);\n        var _config = popover_typeof(config) === 'object' ? config : null;\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n        if (!data) {\n          data = new Popover(this, _config);\n          external_jQuery_default()(this).data(popover_DATA_KEY, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        }\n      });\n    }\n  }]);\n}(tooltip);\n/**\n * jQuery\n */\n(external_jQuery_default()).fn[popover_NAME] = Popover._jQueryInterface;\n(external_jQuery_default()).fn[popover_NAME].Constructor = Popover;\n(external_jQuery_default()).fn[popover_NAME].noConflict = function () {\n  (external_jQuery_default()).fn[popover_NAME] = popover_JQUERY_NO_CONFLICT;\n  return Popover._jQueryInterface;\n};\n/* harmony default export */ var popover = ((/* unused pure expression or super */ null && (Popover)));\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/tab.js\nfunction tab_typeof(o) { \"@babel/helpers - typeof\"; return tab_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, tab_typeof(o); }\nfunction tab_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction tab_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, tab_toPropertyKey(descriptor.key), descriptor); } }\nfunction tab_createClass(Constructor, protoProps, staticProps) { if (protoProps) tab_defineProperties(Constructor.prototype, protoProps); if (staticProps) tab_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction tab_toPropertyKey(t) { var i = tab_toPrimitive(t, \"string\"); return \"symbol\" == tab_typeof(i) ? i : i + \"\"; }\nfunction tab_toPrimitive(t, r) { if (\"object\" != tab_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != tab_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n\n/**\n * Constants\n */\n\nvar tab_NAME = 'tab';\nvar tab_VERSION = '4.6.2';\nvar tab_DATA_KEY = 'bs.tab';\nvar tab_EVENT_KEY = \".\".concat(tab_DATA_KEY);\nvar tab_DATA_API_KEY = '.data-api';\nvar tab_JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[tab_NAME];\nvar CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';\nvar tab_CLASS_NAME_ACTIVE = 'active';\nvar tab_CLASS_NAME_DISABLED = 'disabled';\nvar tab_CLASS_NAME_FADE = 'fade';\nvar tab_CLASS_NAME_SHOW = 'show';\nvar tab_EVENT_HIDE = \"hide\".concat(tab_EVENT_KEY);\nvar tab_EVENT_HIDDEN = \"hidden\".concat(tab_EVENT_KEY);\nvar tab_EVENT_SHOW = \"show\".concat(tab_EVENT_KEY);\nvar tab_EVENT_SHOWN = \"shown\".concat(tab_EVENT_KEY);\nvar tab_EVENT_CLICK_DATA_API = \"click\".concat(tab_EVENT_KEY).concat(tab_DATA_API_KEY);\nvar SELECTOR_DROPDOWN = '.dropdown';\nvar SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\nvar tab_SELECTOR_ACTIVE = '.active';\nvar SELECTOR_ACTIVE_UL = '> li > .active';\nvar tab_SELECTOR_DATA_TOGGLE = '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]';\nvar SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\nvar SELECTOR_DROPDOWN_ACTIVE_CHILD = '> .dropdown-menu .active';\n\n/**\n * Class definition\n */\nvar Tab = /*#__PURE__*/function () {\n  function Tab(element) {\n    tab_classCallCheck(this, Tab);\n    this._element = element;\n  }\n\n  // Getters\n  return tab_createClass(Tab, [{\n    key: \"show\",\n    value:\n    // Public\n    function show() {\n      var _this = this;\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && external_jQuery_default()(this._element).hasClass(tab_CLASS_NAME_ACTIVE) || external_jQuery_default()(this._element).hasClass(tab_CLASS_NAME_DISABLED) || this._element.hasAttribute('disabled')) {\n        return;\n      }\n      var target;\n      var previous;\n      var listElement = external_jQuery_default()(this._element).closest(SELECTOR_NAV_LIST_GROUP)[0];\n      var selector = util.getSelectorFromElement(this._element);\n      if (listElement) {\n        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : tab_SELECTOR_ACTIVE;\n        previous = external_jQuery_default().makeArray(external_jQuery_default()(listElement).find(itemSelector));\n        previous = previous[previous.length - 1];\n      }\n      var hideEvent = external_jQuery_default().Event(tab_EVENT_HIDE, {\n        relatedTarget: this._element\n      });\n      var showEvent = external_jQuery_default().Event(tab_EVENT_SHOW, {\n        relatedTarget: previous\n      });\n      if (previous) {\n        external_jQuery_default()(previous).trigger(hideEvent);\n      }\n      external_jQuery_default()(this._element).trigger(showEvent);\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (selector) {\n        target = document.querySelector(selector);\n      }\n      this._activate(this._element, listElement);\n      var complete = function complete() {\n        var hiddenEvent = external_jQuery_default().Event(tab_EVENT_HIDDEN, {\n          relatedTarget: _this._element\n        });\n        var shownEvent = external_jQuery_default().Event(tab_EVENT_SHOWN, {\n          relatedTarget: previous\n        });\n        external_jQuery_default()(previous).trigger(hiddenEvent);\n        external_jQuery_default()(_this._element).trigger(shownEvent);\n      };\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      external_jQuery_default().removeData(this._element, tab_DATA_KEY);\n      this._element = null;\n    }\n\n    // Private\n  }, {\n    key: \"_activate\",\n    value: function _activate(element, container, callback) {\n      var _this2 = this;\n      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? external_jQuery_default()(container).find(SELECTOR_ACTIVE_UL) : external_jQuery_default()(container).children(tab_SELECTOR_ACTIVE);\n      var active = activeElements[0];\n      var isTransitioning = callback && active && external_jQuery_default()(active).hasClass(tab_CLASS_NAME_FADE);\n      var complete = function complete() {\n        return _this2._transitionComplete(element, active, callback);\n      };\n      if (active && isTransitioning) {\n        var transitionDuration = util.getTransitionDurationFromElement(active);\n        external_jQuery_default()(active).removeClass(tab_CLASS_NAME_SHOW).one(util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    }\n  }, {\n    key: \"_transitionComplete\",\n    value: function _transitionComplete(element, active, callback) {\n      if (active) {\n        external_jQuery_default()(active).removeClass(tab_CLASS_NAME_ACTIVE);\n        var dropdownChild = external_jQuery_default()(active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];\n        if (dropdownChild) {\n          external_jQuery_default()(dropdownChild).removeClass(tab_CLASS_NAME_ACTIVE);\n        }\n        if (active.getAttribute('role') === 'tab') {\n          active.setAttribute('aria-selected', false);\n        }\n      }\n      external_jQuery_default()(element).addClass(tab_CLASS_NAME_ACTIVE);\n      if (element.getAttribute('role') === 'tab') {\n        element.setAttribute('aria-selected', true);\n      }\n      util.reflow(element);\n      if (element.classList.contains(tab_CLASS_NAME_FADE)) {\n        element.classList.add(tab_CLASS_NAME_SHOW);\n      }\n      var parent = element.parentNode;\n      if (parent && parent.nodeName === 'LI') {\n        parent = parent.parentNode;\n      }\n      if (parent && external_jQuery_default()(parent).hasClass(CLASS_NAME_DROPDOWN_MENU)) {\n        var dropdownElement = external_jQuery_default()(element).closest(SELECTOR_DROPDOWN)[0];\n        if (dropdownElement) {\n          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE));\n          external_jQuery_default()(dropdownToggleList).addClass(tab_CLASS_NAME_ACTIVE);\n        }\n        element.setAttribute('aria-expanded', true);\n      }\n      if (callback) {\n        callback();\n      }\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get: function get() {\n      return tab_VERSION;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = external_jQuery_default()(this);\n        var data = $this.data(tab_DATA_KEY);\n        if (!data) {\n          data = new Tab(this);\n          $this.data(tab_DATA_KEY, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        }\n      });\n    }\n  }]);\n}();\n/**\n * Data API implementation\n */\nexternal_jQuery_default()(document).on(tab_EVENT_CLICK_DATA_API, tab_SELECTOR_DATA_TOGGLE, function (event) {\n  event.preventDefault();\n  Tab._jQueryInterface.call(external_jQuery_default()(this), 'show');\n});\n\n/**\n * jQuery\n */\n\n(external_jQuery_default()).fn[tab_NAME] = Tab._jQueryInterface;\n(external_jQuery_default()).fn[tab_NAME].Constructor = Tab;\n(external_jQuery_default()).fn[tab_NAME].noConflict = function () {\n  (external_jQuery_default()).fn[tab_NAME] = tab_JQUERY_NO_CONFLICT;\n  return Tab._jQueryInterface;\n};\n/* harmony default export */ var tab = ((/* unused pure expression or super */ null && (Tab)));\n;// CONCATENATED MODULE: ./node_modules/bootstrap/js/src/toast.js\nfunction toast_typeof(o) { \"@babel/helpers - typeof\"; return toast_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, toast_typeof(o); }\nfunction toast_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction toast_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? toast_ownKeys(Object(t), !0).forEach(function (r) { toast_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : toast_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction toast_defineProperty(obj, key, value) { key = toast_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction toast_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction toast_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, toast_toPropertyKey(descriptor.key), descriptor); } }\nfunction toast_createClass(Constructor, protoProps, staticProps) { if (protoProps) toast_defineProperties(Constructor.prototype, protoProps); if (staticProps) toast_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction toast_toPropertyKey(t) { var i = toast_toPrimitive(t, \"string\"); return \"symbol\" == toast_typeof(i) ? i : i + \"\"; }\nfunction toast_toPrimitive(t, r) { if (\"object\" != toast_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != toast_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v4.6.2): toast.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n\n\n/**\n * Constants\n */\n\nvar toast_NAME = 'toast';\nvar toast_VERSION = '4.6.2';\nvar toast_DATA_KEY = 'bs.toast';\nvar toast_EVENT_KEY = \".\".concat(toast_DATA_KEY);\nvar toast_JQUERY_NO_CONFLICT = (external_jQuery_default()).fn[toast_NAME];\nvar toast_CLASS_NAME_FADE = 'fade';\nvar CLASS_NAME_HIDE = 'hide';\nvar toast_CLASS_NAME_SHOW = 'show';\nvar CLASS_NAME_SHOWING = 'showing';\nvar toast_EVENT_CLICK_DISMISS = \"click.dismiss\".concat(toast_EVENT_KEY);\nvar toast_EVENT_HIDE = \"hide\".concat(toast_EVENT_KEY);\nvar toast_EVENT_HIDDEN = \"hidden\".concat(toast_EVENT_KEY);\nvar toast_EVENT_SHOW = \"show\".concat(toast_EVENT_KEY);\nvar toast_EVENT_SHOWN = \"shown\".concat(toast_EVENT_KEY);\nvar toast_SELECTOR_DATA_DISMISS = '[data-dismiss=\"toast\"]';\nvar toast_Default = {\n  animation: true,\n  autohide: true,\n  delay: 500\n};\nvar toast_DefaultType = {\n  animation: 'boolean',\n  autohide: 'boolean',\n  delay: 'number'\n};\n\n/**\n * Class definition\n */\nvar Toast = /*#__PURE__*/function () {\n  function Toast(element, config) {\n    toast_classCallCheck(this, Toast);\n    this._element = element;\n    this._config = this._getConfig(config);\n    this._timeout = null;\n    this._setListeners();\n  }\n\n  // Getters\n  return toast_createClass(Toast, [{\n    key: \"show\",\n    value:\n    // Public\n    function show() {\n      var _this = this;\n      var showEvent = external_jQuery_default().Event(toast_EVENT_SHOW);\n      external_jQuery_default()(this._element).trigger(showEvent);\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._clearTimeout();\n      if (this._config.animation) {\n        this._element.classList.add(toast_CLASS_NAME_FADE);\n      }\n      var complete = function complete() {\n        _this._element.classList.remove(CLASS_NAME_SHOWING);\n        _this._element.classList.add(toast_CLASS_NAME_SHOW);\n        external_jQuery_default()(_this._element).trigger(toast_EVENT_SHOWN);\n        if (_this._config.autohide) {\n          _this._timeout = setTimeout(function () {\n            _this.hide();\n          }, _this._config.delay);\n        }\n      };\n      this._element.classList.remove(CLASS_NAME_HIDE);\n      util.reflow(this._element);\n      this._element.classList.add(CLASS_NAME_SHOWING);\n      if (this._config.animation) {\n        var transitionDuration = util.getTransitionDurationFromElement(this._element);\n        external_jQuery_default()(this._element).one(util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (!this._element.classList.contains(toast_CLASS_NAME_SHOW)) {\n        return;\n      }\n      var hideEvent = external_jQuery_default().Event(toast_EVENT_HIDE);\n      external_jQuery_default()(this._element).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._close();\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._clearTimeout();\n      if (this._element.classList.contains(toast_CLASS_NAME_SHOW)) {\n        this._element.classList.remove(toast_CLASS_NAME_SHOW);\n      }\n      external_jQuery_default()(this._element).off(toast_EVENT_CLICK_DISMISS);\n      external_jQuery_default().removeData(this._element, toast_DATA_KEY);\n      this._element = null;\n      this._config = null;\n    }\n\n    // Private\n  }, {\n    key: \"_getConfig\",\n    value: function _getConfig(config) {\n      config = toast_objectSpread(toast_objectSpread(toast_objectSpread({}, toast_Default), external_jQuery_default()(this._element).data()), toast_typeof(config) === 'object' && config ? config : {});\n      util.typeCheckConfig(toast_NAME, config, this.constructor.DefaultType);\n      return config;\n    }\n  }, {\n    key: \"_setListeners\",\n    value: function _setListeners() {\n      var _this2 = this;\n      external_jQuery_default()(this._element).on(toast_EVENT_CLICK_DISMISS, toast_SELECTOR_DATA_DISMISS, function () {\n        return _this2.hide();\n      });\n    }\n  }, {\n    key: \"_close\",\n    value: function _close() {\n      var _this3 = this;\n      var complete = function complete() {\n        _this3._element.classList.add(CLASS_NAME_HIDE);\n        external_jQuery_default()(_this3._element).trigger(toast_EVENT_HIDDEN);\n      };\n      this._element.classList.remove(toast_CLASS_NAME_SHOW);\n      if (this._config.animation) {\n        var transitionDuration = util.getTransitionDurationFromElement(this._element);\n        external_jQuery_default()(this._element).one(util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    }\n  }, {\n    key: \"_clearTimeout\",\n    value: function _clearTimeout() {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n\n    // Static\n  }], [{\n    key: \"VERSION\",\n    get: function get() {\n      return toast_VERSION;\n    }\n  }, {\n    key: \"DefaultType\",\n    get: function get() {\n      return toast_DefaultType;\n    }\n  }, {\n    key: \"Default\",\n    get: function get() {\n      return toast_Default;\n    }\n  }, {\n    key: \"_jQueryInterface\",\n    value: function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = external_jQuery_default()(this);\n        var data = $element.data(toast_DATA_KEY);\n        var _config = toast_typeof(config) === 'object' && config;\n        if (!data) {\n          data = new Toast(this, _config);\n          $element.data(toast_DATA_KEY, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](this);\n        }\n      });\n    }\n  }]);\n}();\n/**\n * jQuery\n */\n(external_jQuery_default()).fn[toast_NAME] = Toast._jQueryInterface;\n(external_jQuery_default()).fn[toast_NAME].Constructor = Toast;\n(external_jQuery_default()).fn[toast_NAME].noConflict = function () {\n  (external_jQuery_default()).fn[toast_NAME] = toast_JQUERY_NO_CONFLICT;\n  return Toast._jQueryInterface;\n};\n/* harmony default export */ var toast = ((/* unused pure expression or super */ null && (Toast)));\n// EXTERNAL MODULE: ./node_modules/bootstrap-touchspin/dist/jquery.bootstrap-touchspin.js\nvar jquery_bootstrap_touchspin = __webpack_require__(285);\n// EXTERNAL MODULE: ./js/lib/slick.min.js\nvar slick_min = __webpack_require__(784);\n// EXTERNAL MODULE: ./js/lib/jquery.hoverIntent.min.js\nvar jquery_hoverIntent_min = __webpack_require__(42);\n;// CONCATENATED MODULE: ./js/components/slick.js\nfunction slick_typeof(o) { \"@babel/helpers - typeof\"; return slick_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, slick_typeof(o); }\nfunction slick_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction slick_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, slick_toPropertyKey(descriptor.key), descriptor); } }\nfunction slick_createClass(Constructor, protoProps, staticProps) { if (protoProps) slick_defineProperties(Constructor.prototype, protoProps); if (staticProps) slick_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction slick_toPropertyKey(t) { var i = slick_toPrimitive(t, \"string\"); return \"symbol\" == slick_typeof(i) ? i : i + \"\"; }\nfunction slick_toPrimitive(t, r) { if (\"object\" != slick_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != slick_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar SlickSlider = /*#__PURE__*/function () {\n  function SlickSlider() {\n    slick_classCallCheck(this, SlickSlider);\n  }\n  return slick_createClass(SlickSlider, [{\n    key: \"init\",\n    value: function init() {\n      external_jQuery_default()('[data-slick]').not('.slick-initialized').each(function () {\n        var self = external_jQuery_default()(this);\n        if (self.data('count') === 1) {\n          return;\n        }\n        self.slick({\n          prevArrow: \"<button type=\\\"button\\\" class=\\\"btn btn-link slick-prev slick-arrow\\\"><i class=\\\"material-icons left\\\">&#xE314;</i></button>\",\n          nextArrow: \"<button type=\\\"button\\\" class=\\\"btn btn-link slick-next slick-arrow\\\"><i class=\\\"material-icons right\\\">&#xE315;</i></button>\"\n        });\n      });\n    }\n  }]);\n}();\n\n// EXTERNAL MODULE: ./node_modules/jquery-zoom/jquery.zoom.min.js\nvar jquery_zoom_min = __webpack_require__(471);\n;// CONCATENATED MODULE: external \"prestashop\"\nvar external_prestashop_namespaceObject = prestashop;\nvar external_prestashop_default = /*#__PURE__*/__webpack_require__.n(external_prestashop_namespaceObject);\n;// CONCATENATED MODULE: ./js/responsive.js\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\n\n(external_prestashop_default()).responsive = (external_prestashop_default()).responsive || {};\n(external_prestashop_default()).responsive.current_width = window.innerWidth;\n(external_prestashop_default()).responsive.min_width = 992;\n(external_prestashop_default()).responsive.mobile = (external_prestashop_default()).responsive.current_width < (external_prestashop_default()).responsive.min_width;\nfunction swapChildren(obj1, obj2) {\n  var temp = obj2.children().detach();\n  obj2.empty().append(obj1.children().detach());\n  obj1.append(temp);\n}\nfunction toggleMobileStyles() {\n  if ((external_prestashop_default()).responsive.mobile) {\n    external_jQuery_default()(\"*[id^='_desktop_']\").each(function (idx, el) {\n      var target = external_jQuery_default()('#' + el.id.replace('_desktop_', '_mobile_'));\n      if (target.length) {\n        swapChildren(external_jQuery_default()(el), target);\n      }\n    });\n    external_jQuery_default()('[data-collapse-hide-mobile]').collapse('hide');\n  } else {\n    external_jQuery_default()(\"*[id^='_mobile_']\").each(function (idx, el) {\n      var target = external_jQuery_default()('#' + el.id.replace('_mobile_', '_desktop_'));\n      if (target.length) {\n        swapChildren(external_jQuery_default()(el), target);\n      }\n    });\n    external_jQuery_default()('[data-collapse-hide-mobile]').not('.show').collapse('show');\n    external_jQuery_default()('[data-modal-hide-mobile].show').modal('hide');\n  }\n  external_prestashop_default().emit('responsive update', {\n    mobile: (external_prestashop_default()).responsive.mobile\n  });\n}\nexternal_jQuery_default()(window).on('resize', function () {\n  var _cw = (external_prestashop_default()).responsive.current_width;\n  var _mw = (external_prestashop_default()).responsive.min_width;\n  var _w = window.innerWidth;\n  var _toggle = _cw >= _mw && _w < _mw || _cw < _mw && _w >= _mw;\n  (external_prestashop_default()).responsive.current_width = _w;\n  (external_prestashop_default()).responsive.mobile = (external_prestashop_default()).responsive.current_width < (external_prestashop_default()).responsive.min_width;\n  if (_toggle) {\n    toggleMobileStyles();\n  }\n});\nexternal_jQuery_default()(document).ready(function () {\n  if ((external_prestashop_default()).responsive.mobile) {\n    toggleMobileStyles();\n  }\n});\n;// CONCATENATED MODULE: ./js/checkout.js\nvar _this = undefined;\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\n\nfunction setUpCheckout() {\n  external_jQuery_default()('.js-terms a').on('click', function (event) {\n    event.preventDefault();\n    var url = external_jQuery_default()(event.target).attr('href');\n    if (url) {\n      // TODO: Handle request if no pretty URL\n      url += \"?content_only=1\";\n      external_jQuery_default().get(url, function (content) {\n        external_jQuery_default()('#modal').find('.js-modal-content').html(external_jQuery_default()(content).find('.page-content--cms').contents());\n      }).fail(function (resp) {\n        external_prestashop_default().emit('handleError', {\n          eventType: 'clickTerms',\n          resp: resp\n        });\n      });\n    }\n    external_jQuery_default()('#modal').modal('show');\n  });\n  external_jQuery_default()('.js-gift-checkbox').on('click', function (event) {\n    external_jQuery_default()('#gift').collapse('toggle');\n  });\n}\nexternal_jQuery_default()(document).ready(function () {\n  if (external_jQuery_default()('body#checkout').length === 1) {\n    setUpCheckout();\n  }\n  external_prestashop_default().on('updatedDeliveryForm', function (params) {\n    if (typeof params.deliveryOption === 'undefined' || 0 === params.deliveryOption.length) {\n      return;\n    }\n    // Hide all carrier extra content ...\n    external_jQuery_default()(\".carrier-extra-content\").hide();\n    // and show the one related to the selected carrier\n    params.deliveryOption.next(\".carrier-extra-content\").slideDown();\n  });\n  external_prestashop_default().on('changedCheckoutStep', function (params) {\n    if (typeof params.event.currentTarget !== 'undefined') {\n      external_jQuery_default()('.collapse', params.event.currentTarget).not('.show').not('.collapse .collapse').collapse('show');\n    }\n  });\n});\nexternal_jQuery_default()(document).on('change', '.js-input-delivery:checked', function (event) {\n  external_jQuery_default()('.js-label-delivery.selected').removeClass('selected');\n  external_jQuery_default()('#js-' + external_jQuery_default()(_this).attr('id')).addClass('selected');\n});\nexternal_jQuery_default()(document).on('click', '.js-checkout-step-header', function (event) {\n  var stepIdentifier = external_jQuery_default()(event.currentTarget).data('identifier');\n  external_jQuery_default()('#' + stepIdentifier).addClass('-current');\n  external_jQuery_default()('#content-' + stepIdentifier).collapse('show').scrollTop();\n});\n;// CONCATENATED MODULE: ./js/customer.js\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\nfunction initRmaItemSelector() {\n  external_jQuery_default()('#order-return-form table thead input[type=checkbox]').on('click', function () {\n    var checked = external_jQuery_default()(this).prop('checked');\n    external_jQuery_default()('#order-return-form table tbody input[type=checkbox]').each(function (_, checkbox) {\n      external_jQuery_default()(checkbox).prop('checked', checked);\n    });\n  });\n}\nfunction setupCustomerScripts() {\n  if (external_jQuery_default()('body#order-detail')) {\n    initRmaItemSelector();\n  }\n}\nexternal_jQuery_default()(document).ready(setupCustomerScripts);\n;// CONCATENATED MODULE: ./js/listing.js\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\n\n\nexternal_jQuery_default()(document).ready(function () {\n  external_prestashop_default().on('clickQuickView', function (elm) {\n    var data = {\n      'action': 'quickview',\n      'id_product': elm.dataset.idProduct,\n      'id_product_attribute': elm.dataset.idProductAttribute\n    };\n    external_jQuery_default().post((external_prestashop_default()).urls.pages.product, data, null, 'json').then(function (resp) {\n      external_jQuery_default()('body').append(resp.quickview_html);\n      var productModal = external_jQuery_default()(\"#quickview-modal-\".concat(resp.product.id, \"-\").concat(resp.product.id_product_attribute));\n      productModal.modal('show');\n      productModal.on('hidden.bs.modal', function () {\n        productModal.remove();\n      });\n      productModal.on('shown.bs.modal', function () {\n        productConfig(productModal);\n      });\n    }).fail(function (resp) {\n      external_prestashop_default().emit('handleError', {\n        eventType: 'clickQuickView',\n        resp: resp\n      });\n    });\n  });\n  var productConfig = function productConfig(qv) {\n    var slickSlider = new SlickSlider();\n    slickSlider.init();\n    qv.find('#quantity_wanted').TouchSpin({\n      buttondown_class: 'btn js-touchspin',\n      buttonup_class: 'btn js-touchspin',\n      min: 1,\n      max: 1000000\n    });\n  };\n  var parseSearchUrl = function parseSearchUrl(event) {\n    if (event.target.dataset.searchUrl !== undefined) {\n      return event.target.dataset.searchUrl;\n    }\n    if (external_jQuery_default()(event.target).parent()[0].dataset.searchUrl === undefined) {\n      throw new Error('Can not parse search URL');\n    }\n    return external_jQuery_default()(event.target).parent()[0].dataset.searchUrl;\n  };\n  external_jQuery_default()('body').on('change', '#search_filters input[data-search-url]', function (event) {\n    external_prestashop_default().emit('updateFacets', parseSearchUrl(event));\n  });\n  external_jQuery_default()('body').on('click', '.js-search-filters-clear-all', function (event) {\n    external_prestashop_default().emit('updateFacets', parseSearchUrl(event));\n  });\n  external_jQuery_default()('body').on('click', '.js-search-link', function (event) {\n    event.preventDefault();\n    external_prestashop_default().emit('updateFacets', external_jQuery_default()(event.target).closest('a').get(0).href);\n  });\n  external_jQuery_default()('body').on('change', '#select-sort-order', function () {\n    var urlsearch = external_jQuery_default()(this).val();\n    external_prestashop_default().emit('updateFacets', urlsearch);\n  });\n  external_jQuery_default()('body').on('change', '#search_filters select', function (event) {\n    var urlsearch = external_jQuery_default()(this).val();\n    external_prestashop_default().emit('updateFacets', urlsearch);\n  });\n  external_prestashop_default().on('updateProductList', function (data) {\n    updateProductListDOM(data);\n    window.scrollTo(0, 0);\n  });\n});\nfunction updateProductListDOM(data) {\n  external_jQuery_default()('#search_filters').replaceWith(data.rendered_facets);\n  external_jQuery_default()('#js-active-search-filters').replaceWith(data.rendered_active_filters);\n  external_jQuery_default()('#js-product-list-top').replaceWith(data.rendered_products_top);\n  external_jQuery_default()('#js-product-list').replaceWith(data.rendered_products);\n  external_jQuery_default()('#js-product-list-bottom').replaceWith(data.rendered_products_bottom);\n  if (typeof data.rendered_products_header !== 'undefined' && data.rendered_products_header) {\n    external_jQuery_default()('#js-product-list-header').replaceWith(data.rendered_products_header);\n  }\n}\n;// CONCATENATED MODULE: ./js/product.js\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\n\n\nexternal_jQuery_default()(document).ready(function () {\n  console.log('ready product');\n  createProductSpin();\n  createInputFile();\n  //let slickSlider = new SlickSlider();\n  slickSliderProductInit();\n  if ((external_prestashop_default()).responsive.mobile) {\n    //$(\".btn-zoom\").hide();\n    console.log('zoom');\n    //$(\".product-img img\").parent().zoom();\n    external_jQuery_default()(\"#product-modal img\").parent().zoom({\n      magnify: 0.8\n    });\n  }\n  external_prestashop_default().on('updatedProduct', function (event) {\n    console.log('updatedProduct');\n    createInputFile();\n    if (event && event.product_minimal_quantity) {\n      var minimalProductQuantity = parseInt(event.product_minimal_quantity, 10);\n      var quantityInputSelector = '#quantity_wanted';\n      var quantityInput = external_jQuery_default()(quantityInputSelector);\n\n      // @see http://www.virtuosoft.eu/code/bootstrap-touchspin/ about Bootstrap TouchSpin\n      quantityInput.trigger('touchspin.updatesettings', {\n        min: minimalProductQuantity\n      });\n    }\n    external_jQuery_default()(external_jQuery_default()('.tabs .nav-link.active').attr('href')).addClass('active').removeClass('fade');\n    external_jQuery_default()('.js-product-images-modal').replaceWith(event.product_images_modal);\n    // slickSlider.init();\n    slickSliderProductInit();\n  });\n  function slickSliderProductInit() {\n    console.log('slickSliderProductInit');\n    external_jQuery_default()('.product-thumbs').slick({\n      asNavFor: '.products-imagescover',\n      prevArrow: '<button type=\"button\" class=\"btn btn-link slick-prev slick-arrow\"><i class=\"material-icons\">expand_less</i></button>',\n      nextArrow: '<button type=\"button\" class=\"btn btn-link slick-next slick-arrow\"><i class=\"material-icons\">expand_more</i></button>',\n      dots: false,\n      infinite: true,\n      speed: 300,\n      rows: 0,\n      slidesToShow: 6,\n      slidesToScroll: 1,\n      \"focusOnSelect\": true,\n      vertical: true,\n      verticalSwiping: true,\n      responsive: [{\n        breakpoint: 1024,\n        settings: {\n          slidesToShow: 4,\n          slidesToScroll: 2,\n          vertical: false,\n          verticalSwiping: false,\n          prevArrow: '<button type=\"button\" class=\"btn btn-link slick-prev slick-arrow\"><i class=\"material-icons\">chevron_left</i></button>',\n          nextArrow: '<button type=\"button\" class=\"btn btn-link slick-next slick-arrow\"><i class=\"material-icons\">chevron_right</i></button>'\n        }\n      }, {\n        breakpoint: 480,\n        settings: {\n          slidesToShow: 3,\n          slidesToScroll: 1,\n          vertical: false,\n          verticalSwiping: false,\n          prevArrow: '<button type=\"button\" class=\"btn btn-link slick-prev slick-arrow\"><i class=\"material-icons\">chevron_left</i></button>',\n          nextArrow: '<button type=\"button\" class=\"btn btn-link slick-next slick-arrow\"><i class=\"material-icons\">chevron_right</i></button>'\n        }\n      }]\n    });\n    external_jQuery_default()('.products-imagescover').slick({\n      asNavFor: '.product-thumbs',\n      prevArrow: '<button type=\"button\" class=\"btn btn-link slick-prev slick-arrow\"><i class=\"material-icons\">chevron_left</i></button>',\n      nextArrow: '<button type=\"button\" class=\"btn btn-link slick-next slick-arrow\"><i class=\"material-icons\">chevron_right</i></button>',\n      dots: false,\n      infinite: true,\n      speed: 300,\n      rows: 0,\n      slidesToShow: 1,\n      slidesToScroll: 1,\n      vertical: false,\n      verticalSwiping: false\n    });\n    external_jQuery_default()('#js-slick-product').slick({\n      asNavFor: '.product-thumbs, .products-imagescover',\n      prevArrow: '<button type=\"button\" class=\"btn btn-link slick-prev slick-arrow d-none d-md-flex\"><i class=\"material-icons\">chevron_left</i></button>',\n      nextArrow: '<button type=\"button\" class=\"btn btn-link slick-next slick-arrow d-none d-md-flex\"><i class=\"material-icons\">chevron_right</i></button>',\n      dots: false,\n      infinite: true,\n      speed: 300,\n      rows: 0,\n      slidesToShow: 1,\n      slidesToScroll: 1,\n      vertical: false,\n      verticalSwiping: false,\n      swipe: false\n    });\n\n    // On before slide change\n    /*\n     $('#js-slick-product').on('beforeChange', function (event, slick, currentSlide, nextSlide) {\n     console.log(nextSlide);\n     //$('.products-imagescover').slick('slickGoTo', nextSlide);\n     //$('.product-thumbs').slick('slickGoTo', nextSlide);\n     \n     });*/\n\n    external_jQuery_default()('.btn-zoom').on('click', function () {\n      console.log('btn-zoom click');\n      idImage = external_jQuery_default()(this).data('id-image');\n      numImage = external_jQuery_default()(this).data('num-image');\n      numSlide = external_jQuery_default()(this).parent().data('slick-index');\n      external_jQuery_default()('#js-slick-product').slick('slickGoTo', numSlide);\n      console.log('numImage : ' + numImage);\n      console.log('numSlide : ' + numSlide);\n      /*  $(\"#product-modal img.img-fluid\").addClass('d-none').removeClass('current');\n       $(\"#product-modal img#image-\" + idImage).removeClass('d-none').addClass('current');*/\n    });\n  }\n  function createInputFile() {\n    external_jQuery_default()('.js-file-input').on('change', function (event) {\n      var target, file;\n      if ((target = external_jQuery_default()(event.currentTarget)[0]) && (file = target.files[0])) {\n        external_jQuery_default()(target).prev().text(file.name);\n      }\n    });\n  }\n  function createProductSpin() {\n    var $quantityInput = external_jQuery_default()('#quantity_wanted');\n    $quantityInput.TouchSpin({\n      buttondown_class: 'btn js-touchspin',\n      buttonup_class: 'btn js-touchspin',\n      min: parseInt($quantityInput.attr('min'), 10),\n      max: 1000000\n    });\n    external_jQuery_default()('body').on('change keyup', '#quantity_wanted', function (e) {\n      external_jQuery_default()(e.currentTarget).trigger('touchspin.stopspin');\n      external_prestashop_default().emit('updateProduct', {\n        eventType: 'updatedProductQuantity',\n        event: e\n      });\n    });\n  }\n});\nvar idImage = 0;\nvar numImage = 0;\nvar numSlide = 0;\nexternal_jQuery_default()(document).on('shown.bs.modal', '#product-modal', function (e) {\n  console.log('shown #product-modal');\n  console.log('numImage : ' + numImage);\n  external_jQuery_default()('#js-slick-product').resize();\n});\nexternal_jQuery_default()(document).on('click', '.next-image-modal', function (e) {\n  console.log('next-image-modal click');\n  external_jQuery_default()('#js-slick-product').slick('slickNext');\n});\nexternal_jQuery_default()(document).on('click', '.prev-image-modal', function (e) {\n  console.log('prev-image-modal click');\n  external_jQuery_default()('#js-slick-product').slick('slickPrev');\n});\n\n//add to cart loader\nexternal_jQuery_default()(document).on('click', '.js-add-to-cart:enabled:not(.is--loading)', function () {\n  external_jQuery_default()(this).addClass('is--loading').attr(\"disabled\", true);\n});\n/*\nprestashop.on('updateCart', function (event) {\n    removeAddToCartLoader();\n\n});\nprestashop.on('handleError', function (event) {\n    removeAddToCartLoader();\n    $('.js-add-to-cart').attr(\"disabled\", false);\n\n});\nfunction removeAddToCartLoader() {\n    $('.js-add-to-cart.is--loading').removeClass('is--loading');\n\n}*/\n;// CONCATENATED MODULE: ./js/cart.js\n\n\n(external_prestashop_default()).cart = (external_prestashop_default()).cart || {};\n(external_prestashop_default()).cart.active_inputs = null;\nvar spinnerSelector = 'input[name=\"product-quantity-spin\"]';\nvar hasError = false;\nvar isUpdateOperation = false;\nvar errorMsg = '';\n\n/**\n * Attach Bootstrap TouchSpin event handlers\n */\nfunction createSpin() {\n  external_jQuery_default().each(external_jQuery_default()(spinnerSelector), function (index, spinner) {\n    external_jQuery_default()(spinner).TouchSpin({\n      buttondown_class: 'btn js-touchspin',\n      buttonup_class: 'btn js-touchspin',\n      min: parseInt(external_jQuery_default()(spinner).attr('min'), 10),\n      max: 1000000\n    });\n  });\n  CheckUpdateQuantityOperations.switchErrorStat();\n}\nexternal_jQuery_default()(document).ready(function () {\n  var productLineInCartSelector = '.js-cart-line-product-quantity';\n  var promises = [];\n  external_prestashop_default().on('updateCart', function () {\n    external_jQuery_default()('.quickview').modal('hide');\n    external_jQuery_default()('.js-cart__card-body').addClass('is--loading');\n  });\n  external_prestashop_default().on('updatedCart', function () {\n    createSpin();\n    external_jQuery_default()('.js-cart__card-body.is--loading').removeClass('is--loading');\n  });\n  external_prestashop_default().on('handleError', function (event) {\n    external_jQuery_default()('.js-cart__card-body.is--loading').removeClass('is--loading');\n  });\n  createSpin();\n  var $body = external_jQuery_default()('body');\n  function isTouchSpin(namespace) {\n    return namespace === 'on.startupspin' || namespace === 'on.startdownspin';\n  }\n  function shouldIncreaseProductQuantity(namespace) {\n    return namespace === 'on.startupspin';\n  }\n  function findCartLineProductQuantityInput($target) {\n    var $input = $target.parents('.bootstrap-touchspin').find(productLineInCartSelector);\n    if ($input.is(':focus')) {\n      return null;\n    }\n    return $input;\n  }\n  function camelize(subject) {\n    var actionTypeParts = subject.split('-');\n    var i;\n    var part;\n    var camelizedSubject = '';\n    for (i = 0; i < actionTypeParts.length; i++) {\n      part = actionTypeParts[i];\n      if (0 !== i) {\n        part = part.substring(0, 1).toUpperCase() + part.substring(1);\n      }\n      camelizedSubject = camelizedSubject + part;\n    }\n    return camelizedSubject;\n  }\n  function parseCartAction($target, namespace) {\n    if (!isTouchSpin(namespace)) {\n      return {\n        url: $target.attr('href'),\n        type: camelize($target.data('link-action'))\n      };\n    }\n    var $input = findCartLineProductQuantityInput($target);\n    if (!$input) {\n      return;\n    }\n    var cartAction = {};\n    if (shouldIncreaseProductQuantity(namespace)) {\n      cartAction = {\n        url: $input.data('up-url'),\n        type: 'increaseProductQuantity'\n      };\n    } else {\n      cartAction = {\n        url: $input.data('down-url'),\n        type: 'decreaseProductQuantity'\n      };\n    }\n    return cartAction;\n  }\n  var abortPreviousRequests = function abortPreviousRequests() {\n    var promise;\n    while (promises.length > 0) {\n      promise = promises.pop();\n      promise.abort();\n    }\n  };\n  var getTouchSpinInput = function getTouchSpinInput($button) {\n    return external_jQuery_default()($button.parents('.bootstrap-touchspin').find('input'));\n  };\n  var handleCartAction = function handleCartAction(event) {\n    event.preventDefault();\n    var $target = external_jQuery_default()(event.currentTarget);\n    var dataset = event.currentTarget.dataset;\n    var cartAction = parseCartAction($target, event.namespace);\n    var requestData = {\n      ajax: '1',\n      action: 'update'\n    };\n    if (typeof cartAction === 'undefined') {\n      return;\n    }\n    abortPreviousRequests();\n    external_jQuery_default().ajax({\n      url: cartAction.url,\n      method: 'POST',\n      data: requestData,\n      dataType: 'json',\n      beforeSend: function beforeSend(jqXHR) {\n        promises.push(jqXHR);\n      }\n    }).then(function (resp) {\n      CheckUpdateQuantityOperations.checkUpdateOpertation(resp);\n      var $quantityInput = getTouchSpinInput($target);\n      $quantityInput.val(resp.quantity);\n\n      // Refresh cart preview\n      external_prestashop_default().emit('updateCart', {\n        reason: dataset,\n        resp: resp\n      });\n    }).fail(function (resp) {\n      external_prestashop_default().emit('handleError', {\n        eventType: 'updateProductInCart',\n        resp: resp,\n        cartAction: cartAction.type\n      });\n    });\n  };\n  $body.on('click', '[data-link-action=\"delete-from-cart\"], [data-link-action=\"remove-voucher\"]', handleCartAction);\n  $body.on('touchspin.on.startdownspin', spinnerSelector, handleCartAction);\n  $body.on('touchspin.on.startupspin', spinnerSelector, handleCartAction);\n  function sendUpdateQuantityInCartRequest(updateQuantityInCartUrl, requestData, $target) {\n    abortPreviousRequests();\n    return external_jQuery_default().ajax({\n      url: updateQuantityInCartUrl,\n      method: 'POST',\n      data: requestData,\n      dataType: 'json',\n      beforeSend: function beforeSend(jqXHR) {\n        promises.push(jqXHR);\n      }\n    }).then(function (resp) {\n      CheckUpdateQuantityOperations.checkUpdateOpertation(resp);\n      $target.val(resp.quantity);\n      var dataset;\n      if ($target && $target.dataset) {\n        dataset = $target.dataset;\n      } else {\n        dataset = resp;\n      }\n\n      // Refresh cart preview\n      external_prestashop_default().emit('updateCart', {\n        reason: dataset,\n        resp: resp\n      });\n    }).fail(function (resp) {\n      external_prestashop_default().emit('handleError', {\n        eventType: 'updateProductQuantityInCart',\n        resp: resp\n      });\n    });\n  }\n  function getRequestData(quantity) {\n    return {\n      ajax: '1',\n      qty: Math.abs(quantity),\n      action: 'update',\n      op: getQuantityChangeType(quantity)\n    };\n  }\n  function getQuantityChangeType($quantity) {\n    return $quantity > 0 ? 'up' : 'down';\n  }\n  function updateProductQuantityInCart(event) {\n    var $target = external_jQuery_default()(event.currentTarget);\n    var updateQuantityInCartUrl = $target.data('update-url');\n    var baseValue = $target.attr('value');\n\n    // There should be a valid product quantity in cart\n    var targetValue = $target.val();\n    if (targetValue != parseInt(targetValue) || targetValue < 0 || isNaN(targetValue)) {\n      $target.val(baseValue);\n      return;\n    }\n\n    // There should be a new product quantity in cart\n    var qty = targetValue - baseValue;\n    if (qty === 0) {\n      return;\n    }\n    $target.attr('value', targetValue);\n    sendUpdateQuantityInCartRequest(updateQuantityInCartUrl, getRequestData(qty), $target);\n  }\n  $body.on('focusout keyup', productLineInCartSelector, function (event) {\n    if (event.type === 'keyup') {\n      if (event.keyCode === 13) {\n        updateProductQuantityInCart(event);\n      }\n      return false;\n    }\n    updateProductQuantityInCart(event);\n  });\n  $body.on('click', '.js-discount .code', function (event) {\n    event.stopPropagation();\n    var $code = external_jQuery_default()(event.currentTarget);\n    var $discountInput = external_jQuery_default()('[name=discount_name]');\n    $discountInput.val($code.text());\n    external_jQuery_default()('#promo-code').collapse('show');\n    return false;\n  });\n});\nvar CheckUpdateQuantityOperations = {\n  'switchErrorStat': function switchErrorStat() {\n    /**\n     * resp.hasError can be not defined but resp.errors not empty: quantity is updated but order cannot be placed\n     * when resp.hasError=true, quantity is not updated\n     */\n    var $checkoutBtn = external_jQuery_default()('.checkout a');\n    if (external_jQuery_default()(\"#notifications article.alert-danger\").length || '' !== errorMsg && !hasError) {\n      $checkoutBtn.addClass('disabled');\n    }\n    if ('' !== errorMsg) {\n      var strError = ' <article class=\"alert alert-danger\" role=\"alert\" data-alert=\"danger\"><ul><li>' + errorMsg + '</li></ul></article>';\n      external_jQuery_default()('#notifications.notifications-container').html(strError);\n      errorMsg = '';\n      isUpdateOperation = false;\n      if (hasError) {\n        // if hasError is true, quantity was not updated : allow checkout\n        $checkoutBtn.removeClass('disabled');\n      }\n    } else if (!hasError && isUpdateOperation) {\n      hasError = false;\n      isUpdateOperation = false;\n      external_jQuery_default()('#notifications.notifications-container').html('');\n      $checkoutBtn.removeClass('disabled');\n    }\n  },\n  'checkUpdateOpertation': function checkUpdateOpertation(resp) {\n    /**\n     * resp.hasError can be not defined but resp.errors not empty: quantity is updated but order cannot be placed\n     * when resp.hasError=true, quantity is not updated\n     */\n    hasError = resp.hasOwnProperty('hasError');\n    var errors = resp.errors || \"\";\n    // 1.7.2.x returns errors as string, 1.7.3.x returns array\n    if (errors instanceof Array) {\n      errorMsg = errors.join(\" \");\n    } else {\n      errorMsg = errors;\n    }\n    isUpdateOperation = true;\n  }\n};\n;// CONCATENATED MODULE: ./js/components/form.js\nfunction form_typeof(o) { \"@babel/helpers - typeof\"; return form_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, form_typeof(o); }\nfunction form_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction form_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, form_toPropertyKey(descriptor.key), descriptor); } }\nfunction form_createClass(Constructor, protoProps, staticProps) { if (protoProps) form_defineProperties(Constructor.prototype, protoProps); if (staticProps) form_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction form_toPropertyKey(t) { var i = form_toPrimitive(t, \"string\"); return \"symbol\" == form_typeof(i) ? i : i + \"\"; }\nfunction form_toPrimitive(t, r) { if (\"object\" != form_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != form_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\nvar Form = /*#__PURE__*/function () {\n  function Form() {\n    form_classCallCheck(this, Form);\n  }\n  return form_createClass(Form, [{\n    key: \"init\",\n    value: function init() {\n      this.parentFocus();\n      this.togglePasswordVisibility();\n      this.formValidation();\n    }\n  }, {\n    key: \"parentFocus\",\n    value: function parentFocus() {\n      external_jQuery_default()('.js-child-focus').focus(function () {\n        external_jQuery_default()(this).closest('.js-parent-focus').addClass('focus');\n      });\n      external_jQuery_default()('.js-child-focus').focusout(function () {\n        external_jQuery_default()(this).closest('.js-parent-focus').removeClass('focus');\n      });\n    }\n  }, {\n    key: \"togglePasswordVisibility\",\n    value: function togglePasswordVisibility() {\n      external_jQuery_default()('button[data-action=\"show-password\"]').on('click', function () {\n        var elm = external_jQuery_default()(this).closest('.input-group').children('input.js-visible-password');\n        if (elm.attr('type') === 'password') {\n          elm.attr('type', 'text');\n          external_jQuery_default()(this).text(external_jQuery_default()(this).data('textHide'));\n        } else {\n          elm.attr('type', 'password');\n          external_jQuery_default()(this).text(external_jQuery_default()(this).data('textShow'));\n        }\n      });\n    }\n  }, {\n    key: \"formValidation\",\n    value: function formValidation() {\n      // Fetch all the forms we want to apply custom Bootstrap validation styles to\n      var forms = document.getElementsByClassName('needs-validation');\n      if (forms.length > 0) {\n        console.log(supportedValidity());\n        if (!supportedValidity()) {\n          return;\n        }\n        // Loop over them and prevent submission\n        var divToScroll = false;\n        var validation = Array.prototype.filter.call(forms, function (form) {\n          form.addEventListener('submit', function (event) {\n            if (form.checkValidity() === false) {\n              event.preventDefault();\n              event.stopPropagation();\n              external_jQuery_default()('input:invalid,select:invalid,textarea:invalid', form).each(function (index) {\n                var _field = external_jQuery_default()(this),\n                  _parent = _field.parents('.form-group').first();\n                external_jQuery_default()('.js-invalid-feedback-browser', _parent).text(_field[0].validationMessage);\n                if (!divToScroll) {\n                  divToScroll = _parent;\n                }\n              });\n              external_jQuery_default()(this).data('disabled', false);\n              external_jQuery_default()('button[type=\"submit\"]', form).removeClass('disabled');\n            }\n            form.classList.add('was-validated');\n            if (divToScroll) {\n              external_jQuery_default()('html, body').animate({\n                scrollTop: divToScroll.offset().top\n              }, 300);\n              divToScroll = false;\n            }\n          }, false);\n        });\n      }\n    }\n  }]);\n}();\n\nvar supportedValidity = function supportedValidity() {\n  var input = document.createElement('input');\n  return 'validity' in input && 'badInput' in input.validity && 'patternMismatch' in input.validity && 'rangeOverflow' in input.validity && 'rangeUnderflow' in input.validity && 'tooLong' in input.validity && 'tooShort' in input.validity && 'typeMismatch' in input.validity && 'valid' in input.validity && 'valueMissing' in input.validity;\n};\n;// CONCATENATED MODULE: ./js/components/top-menu.js\nfunction top_menu_typeof(o) { \"@babel/helpers - typeof\"; return top_menu_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, top_menu_typeof(o); }\nfunction top_menu_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction top_menu_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, top_menu_toPropertyKey(descriptor.key), descriptor); } }\nfunction top_menu_createClass(Constructor, protoProps, staticProps) { if (protoProps) top_menu_defineProperties(Constructor.prototype, protoProps); if (staticProps) top_menu_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction top_menu_toPropertyKey(t) { var i = top_menu_toPrimitive(t, \"string\"); return \"symbol\" == top_menu_typeof(i) ? i : i + \"\"; }\nfunction top_menu_toPrimitive(t, r) { if (\"object\" != top_menu_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != top_menu_typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\nvar TopMenu = /*#__PURE__*/function () {\n  function TopMenu(el) {\n    top_menu_classCallCheck(this, TopMenu);\n    this.el = el;\n  }\n  return top_menu_createClass(TopMenu, [{\n    key: \"init\",\n    value: function init() {\n      var self = this;\n      self.el.hoverIntent({\n        over: self.toggleClassSubMenu,\n        out: self.toggleClassSubMenu,\n        selector: ' > li',\n        timeout: 100\n      });\n    }\n  }, {\n    key: \"toggleClassSubMenu\",\n    value: function toggleClassSubMenu() {\n      var _item = external_jQuery_default()(this);\n      var expanded = _item.attr('aria-expanded');\n      if (typeof expanded !== \"undefined\") {\n        expanded = expanded.toLowerCase() === 'true';\n        _item.toggleClass('menu__item--active').attr('aria-expanded', !expanded);\n        external_jQuery_default()('.menu-sub', _item).attr('aria-expanded', !expanded).attr('aria-hidden', expanded);\n      }\n    }\n  }]);\n}();\n\n// EXTERNAL MODULE: ./node_modules/events/events.js\nvar events = __webpack_require__(32);\nvar events_default = /*#__PURE__*/__webpack_require__.n(events);\n;// CONCATENATED MODULE: ./js/components/block-cart.js\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\n\n(external_prestashop_default()).blockcart = (external_prestashop_default()).blockcart || {};\n(external_prestashop_default()).blockcart.showModal = function (html) {\n  function getBlockCartModal() {\n    return external_jQuery_default()('#blockcart-modal');\n  }\n  var $blockCartModal = getBlockCartModal();\n  if ($blockCartModal.length) {\n    $blockCartModal.remove();\n  }\n  external_jQuery_default()('body').append(html);\n  $blockCartModal = getBlockCartModal();\n  $blockCartModal.modal('show').on('hidden.bs.modal', function (event) {\n    external_prestashop_default().emit('updateProduct', {\n      reason: event.currentTarget.dataset,\n      event: event\n    });\n  });\n};\n// EXTERNAL MODULE: ./node_modules/lazysizes/lazysizes.js\nvar lazysizes = __webpack_require__(64);\n;// CONCATENATED MODULE: ./js/theme.js\n/**\n * 2007-2017 PrestaShop\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Academic Free License 3.0 (AFL-3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/AFL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to http://www.prestashop.com for more information.\n *\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2007-2017 PrestaShop SA\n * @license   https://opensource.org/licenses/AFL-3.0 Academic Free License 3.0 (AFL-3.0)\n * International Registered Trademark & Property of PrestaShop SA\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// \"inherit\" EventEmitter\nfor (var i in (events_default()).prototype) {\n  (external_prestashop_default())[i] = (events_default()).prototype[i];\n}\n$(document).ready(function () {\n  var form = new Form();\n  var slickSlider = new SlickSlider();\n  var topMenuEl = $('#_desktop_top_menu #top-menu');\n  var topMenu = new TopMenu(topMenuEl);\n  form.init();\n  slickSlider.init();\n  topMenu.init();\n\n  //display input file content in custom file input BS\n  $('.custom-file-input').on('change', function () {\n    var fileName = $(this).val().split('\\\\').pop();\n    $(this).next('.custom-file-label').addClass(\"selected\").html(fileName);\n  });\n});\ndocument.addEventListener('lazyloaded', function (e) {\n  $(e.target).parent().addClass('rc--lazyload');\n});\n$(document).ready(function () {\n  console.log('ready');\n  /* SCROLL TO ANCHOR */\n  if (window.location.hash && window.location.hash[1] != '/') {\n    scrollToAnchor(window.location.hash);\n  }\n  FullWidth();\n  if ($(location).attr(\"pathname\") != \"/commande\" && $(location).attr(\"pathname\") != \"/checkout\") {\n    sticky();\n    MobileMenuOk();\n  }\n  $(window).resize(function () {\n    FullWidth();\n    if ($(location).attr(\"pathname\") != \"/commande\" && $(location).attr(\"pathname\") != \"/checkout\") {\n      MobileMenuOk();\n    }\n  });\n  function FullWidth() {\n    $('.fullwidth').each(function () {\n      var content = $(this);\n      var fullwidth = $('body').width(),\n        margin_full = fullwidth / 2;\n      //console.log(fullwidth);\n      //console.log(content);\n      content.css({\n        'left': '50%',\n        'position': 'relative',\n        'width': fullwidth,\n        'margin-left': -margin_full\n      });\n    });\n  }\n  function sticky() {\n    console.log('sticky');\n    var yourNavigation = $(\"#header\");\n    var stickyDiv = \"sticky\";\n    var unStickyDiv = \"unsticky\";\n    var yourHeader = $('#header').height();\n    $(window).scroll(function () {\n      if ($(this).scrollTop() > 0) {\n        yourNavigation.addClass(stickyDiv).removeClass(unStickyDiv);\n        $('body').css('padding-top', yourHeader);\n      } else {\n        yourNavigation.addClass(unStickyDiv).removeClass(stickyDiv);\n        $('body').css('padding-top', 0);\n      }\n    });\n  }\n  function MobileMenuOk() {\n    $(\".modal-dialog__offcanvas #adtm_menu\").addClass(\"adtm_menu_toggle_open\");\n    //$('#adtm_menu').toggleClass('adtm_menu_toggle_open');\n    //$('#adtm_menu .advtm_menu_toggle').toggleClass('adtm_menu_mobile_mode');\n  }\n  function scrollToAnchor(anchor) {\n    console.log(anchor);\n    var target = $(anchor);\n    var scrollTop = target.offset().top - $('#header').height() - 40;\n    //var scrollTop = target.offset().top - $('#header').height();\n    console.log('header height: ' + $('#header').height());\n    console.log('scrollTop : ' + scrollTop);\n    $('html, body').animate({\n      scrollTop: scrollTop\n    }, 1000, function () {\n      // Callback after animation\n      // Must change focus!\n      var $target = $(target);\n      $target.focus();\n      if ($target.is(\":focus\")) {\n        // Checking if the target was focused\n        return false;\n      } else {\n        $target.attr('tabindex', '-1'); // Adding tabindex for elements not focusable\n        $target.focus(); // Set focus again\n      }\n    });\n  }\n\n  // Fonction pour scroller les liens vers ancres\n  $('a[href*=\"#\"]')\n  // Remove links that don't actually link to anything\n  .not('[href=\"#\"]').not('[href*=\"#footer\"]').not('.footer__title--mobile').not('.noscroll')\n  /*\n   .not('[href=\"#0\"]')\n   .not('[href=\"#bt_tabs-0\"]')\n   .not('[href=\"#bt_tabs-1\"]')*/.click(function (event) {\n    // On-page links\n    if (location.pathname.replace(/^\\//, '') == this.pathname.replace(/^\\//, '') && location.hostname == this.hostname) {\n      // Figure out element to scroll to\n\n      if ($(this).hasClass('nav-link')) {\n        var target = $(this).parent().parent();\n      } else {\n        var target = $(this.hash);\n        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');\n      }\n      console.log('target');\n      console.log(target);\n      console.log(target.offset().top);\n      console.log('header height');\n      console.log($('#header').height());\n\n      // Does a scroll target exist?\n      if (target.length) {\n        // Only prevent default if animation is actually gonna happen\n        //event.preventDefault();\n\n        var scrollTop = target.offset().top - $('#header').height() - 40;\n        console.log('header height: ' + $('#header').height());\n        console.log('scrollTop : ' + scrollTop);\n        $('html, body').animate({\n          scrollTop: scrollTop\n        }, 1000, function () {\n          // Callback after animation\n          // Must change focus!\n          var $target = $(target);\n          $target.focus();\n          if ($target.is(\":focus\")) {\n            // Checking if the target was focused\n            return false;\n          } else {\n            $target.attr('tabindex', '-1'); // Adding tabindex for elements not focusable\n            $target.focus(); // Set focus again\n          }\n        });\n      }\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQxLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxQkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL3V0aWwuanM/YWJkMSIsIndlYnBhY2s6Ly9wcmVzdGFyb2NrZXQtZGV2LXRvb2xzLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9zcmMvYWxlcnQuanM/MDY5YSIsIndlYnBhY2s6Ly9wcmVzdGFyb2NrZXQtZGV2LXRvb2xzLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9zcmMvYnV0dG9uLmpzPzYxMDgiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL2NvbGxhcHNlLmpzPzJjZTYiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzPzYxNjkiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL2Ryb3Bkb3duLmpzPzZjNTAiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL21vZGFsLmpzPzkxNGMiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL3Rvb2xzL3Nhbml0aXplci5qcz8zMGE5Iiwid2VicGFjazovL3ByZXN0YXJvY2tldC1kZXYtdG9vbHMvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3NyYy90b29sdGlwLmpzP2JjOWYiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL3BvcG92ZXIuanM/NTFjMiIsIndlYnBhY2s6Ly9wcmVzdGFyb2NrZXQtZGV2LXRvb2xzLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9zcmMvdGFiLmpzP2EzMGIiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL3RvYXN0LmpzPzhmMWYiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL2pzL2NvbXBvbmVudHMvc2xpY2suanM/NzE3ZSIsIndlYnBhY2s6Ly9wcmVzdGFyb2NrZXQtZGV2LXRvb2xzL2V4dGVybmFsIHZhciBcInByZXN0YXNob3BcIj9hMmExIiwid2VicGFjazovL3ByZXN0YXJvY2tldC1kZXYtdG9vbHMvLi9qcy9yZXNwb25zaXZlLmpzP2RkMDAiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL2pzL2NoZWNrb3V0LmpzPzE1YzkiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL2pzL2N1c3RvbWVyLmpzPzBjYTIiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL2pzL2xpc3RpbmcuanM/OTU0MSIsIndlYnBhY2s6Ly9wcmVzdGFyb2NrZXQtZGV2LXRvb2xzLy4vanMvcHJvZHVjdC5qcz9lOGEwIiwid2VicGFjazovL3ByZXN0YXJvY2tldC1kZXYtdG9vbHMvLi9qcy9jYXJ0LmpzPzQ1YjMiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL2pzL2NvbXBvbmVudHMvZm9ybS5qcz83NmY4Iiwid2VicGFjazovL3ByZXN0YXJvY2tldC1kZXYtdG9vbHMvLi9qcy9jb21wb25lbnRzL3RvcC1tZW51LmpzP2Q1YWYiLCJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL2pzL2NvbXBvbmVudHMvYmxvY2stY2FydC5qcz83NjI5Iiwid2VicGFjazovL3ByZXN0YXJvY2tldC1kZXYtdG9vbHMvLi9qcy90aGVtZS5qcz82YzNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4yKTogdXRpbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5cbi8qKlxuICogUHJpdmF0ZSBUcmFuc2l0aW9uRW5kIEhlbHBlcnNcbiAqL1xuXG52YXIgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgTUFYX1VJRCA9IDEwMDAwMDA7XG52YXIgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwO1xuXG4vLyBTaG91dG91dCBBbmd1c0Nyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXG5mdW5jdGlvbiB0b1R5cGUob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQob2JqKTtcbiAgfVxuICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopLm1hdGNoKC9cXHMoW2Etel0rKS9pKVsxXS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBiaW5kVHlwZTogVFJBTlNJVElPTl9FTkQsXG4gICAgZGVsZWdhdGVUeXBlOiBUUkFOU0lUSU9OX0VORCxcbiAgICBoYW5kbGU6IGZ1bmN0aW9uIGhhbmRsZShldmVudCkge1xuICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkVuZEVtdWxhdG9yKGR1cmF0aW9uKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgJCh0aGlzKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgIGNhbGxlZCA9IHRydWU7XG4gIH0pO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZChfdGhpcyk7XG4gICAgfVxuICB9LCBkdXJhdGlvbik7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQoKSB7XG4gICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kRW11bGF0b3I7XG4gICQuZXZlbnQuc3BlY2lhbFtVdGlsLlRSQU5TSVRJT05fRU5EXSA9IGdldFNwZWNpYWxUcmFuc2l0aW9uRW5kRXZlbnQoKTtcbn1cblxuLyoqXG4gKiBQdWJsaWMgVXRpbCBBUElcbiAqL1xuXG52YXIgVXRpbCA9IHtcbiAgVFJBTlNJVElPTl9FTkQ6ICdic1RyYW5zaXRpb25FbmQnLFxuICBnZXRVSUQ6IGZ1bmN0aW9uIGdldFVJRChwcmVmaXgpIHtcbiAgICBkbyB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTsgLy8gXCJ+flwiIGFjdHMgbGlrZSBhIGZhc3RlciBNYXRoLmZsb29yKCkgaGVyZVxuICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpO1xuICAgIHJldHVybiBwcmVmaXg7XG4gIH0sXG4gIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpO1xuICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xuICAgICAgdmFyIGhyZWZBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgIHNlbGVjdG9yID0gaHJlZkF0dHIgJiYgaHJlZkF0dHIgIT09ICcjJyA/IGhyZWZBdHRyLnRyaW0oKSA6ICcnO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIEdldCB0cmFuc2l0aW9uLWR1cmF0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9ICQoZWxlbWVudCkuY3NzKCd0cmFuc2l0aW9uLWR1cmF0aW9uJyk7XG4gICAgdmFyIHRyYW5zaXRpb25EZWxheSA9ICQoZWxlbWVudCkuY3NzKCd0cmFuc2l0aW9uLWRlbGF5Jyk7XG4gICAgdmFyIGZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uID0gcGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIHZhciBmbG9hdFRyYW5zaXRpb25EZWxheSA9IHBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTtcblxuICAgIC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcbiAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbi5zcGxpdCgnLCcpWzBdO1xuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xuICAgIHJldHVybiAocGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgcGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpKSAqIE1JTExJU0VDT05EU19NVUxUSVBMSUVSO1xuICB9LFxuICByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICB9LFxuICB0cmlnZ2VyVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCkge1xuICAgICQoZWxlbWVudCkudHJpZ2dlcihUUkFOU0lUSU9OX0VORCk7XG4gIH0sXG4gIHN1cHBvcnRzVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkge1xuICAgIHJldHVybiBCb29sZWFuKFRSQU5TSVRJT05fRU5EKTtcbiAgfSxcbiAgaXNFbGVtZW50OiBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIChvYmpbMF0gfHwgb2JqKS5ub2RlVHlwZTtcbiAgfSxcbiAgdHlwZUNoZWNrQ29uZmlnOiBmdW5jdGlvbiB0eXBlQ2hlY2tDb25maWcoY29tcG9uZW50TmFtZSwgY29uZmlnLCBjb25maWdUeXBlcykge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGNvbmZpZ1R5cGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ1R5cGVzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICAgIHZhciB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBVdGlsLmlzRWxlbWVudCh2YWx1ZSkgPyAnZWxlbWVudCcgOiB0b1R5cGUodmFsdWUpO1xuICAgICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGNvbXBvbmVudE5hbWUudG9VcHBlckNhc2UoKSwgXCI6IFwiKSArIFwiT3B0aW9uIFxcXCJcIi5jb25jYXQocHJvcGVydHksIFwiXFxcIiBwcm92aWRlZCB0eXBlIFxcXCJcIikuY29uY2F0KHZhbHVlVHlwZSwgXCJcXFwiIFwiKSArIFwiYnV0IGV4cGVjdGVkIHR5cGUgXFxcIlwiLmNvbmNhdChleHBlY3RlZFR5cGVzLCBcIlxcXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZmluZFNoYWRvd1Jvb3Q6IGZ1bmN0aW9uIGZpbmRTaGFkb3dSb290KGVsZW1lbnQpIHtcbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5nZXRSb290Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyB3aGVuIHdlIGRvbid0IGZpbmQgYSBzaGFkb3cgcm9vdFxuICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWwuZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgfSxcbiAgalF1ZXJ5RGV0ZWN0aW9uOiBmdW5jdGlvbiBqUXVlcnlEZXRlY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiAkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeS4galF1ZXJ5IG11c3QgYmUgaW5jbHVkZWQgYmVmb3JlIEJvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdC4nKTtcbiAgICB9XG4gICAgdmFyIHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJyk7XG4gICAgdmFyIG1pbk1ham9yID0gMTtcbiAgICB2YXIgbHRNYWpvciA9IDI7XG4gICAgdmFyIG1pbk1pbm9yID0gOTtcbiAgICB2YXIgbWluUGF0Y2ggPSAxO1xuICAgIHZhciBtYXhNYWpvciA9IDQ7XG4gICAgaWYgKHZlcnNpb25bMF0gPCBsdE1ham9yICYmIHZlcnNpb25bMV0gPCBtaW5NaW5vciB8fCB2ZXJzaW9uWzBdID09PSBtaW5NYWpvciAmJiB2ZXJzaW9uWzFdID09PSBtaW5NaW5vciAmJiB2ZXJzaW9uWzJdIDwgbWluUGF0Y2ggfHwgdmVyc2lvblswXSA+PSBtYXhNYWpvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgYXQgbGVhc3QgalF1ZXJ5IHYxLjkuMSBidXQgbGVzcyB0aGFuIHY0LjAuMCcpO1xuICAgIH1cbiAgfVxufTtcblV0aWwualF1ZXJ5RGV0ZWN0aW9uKCk7XG5zZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpO1xuZXhwb3J0IGRlZmF1bHQgVXRpbDsiLCJmdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjIpOiBhbGVydC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBOQU1FID0gJ2FsZXJ0JztcbnZhciBWRVJTSU9OID0gJzQuNi4yJztcbnZhciBEQVRBX0tFWSA9ICdicy5hbGVydCc7XG52YXIgRVZFTlRfS0VZID0gXCIuXCIuY29uY2F0KERBVEFfS0VZKTtcbnZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbnZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xudmFyIENMQVNTX05BTUVfQUxFUlQgPSAnYWxlcnQnO1xudmFyIENMQVNTX05BTUVfRkFERSA9ICdmYWRlJztcbnZhciBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XG52YXIgRVZFTlRfQ0xPU0UgPSBcImNsb3NlXCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfQ0xPU0VEID0gXCJjbG9zZWRcIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9DTElDS19EQVRBX0FQSSA9IFwiY2xpY2tcIi5jb25jYXQoRVZFTlRfS0VZKS5jb25jYXQoREFUQV9BUElfS0VZKTtcbnZhciBTRUxFQ1RPUl9ESVNNSVNTID0gJ1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXSc7XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG52YXIgQWxlcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbGVydChlbGVtZW50KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFsZXJ0KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBbGVydCwgW3tcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBQdWJsaWNcbiAgICBmdW5jdGlvbiBjbG9zZShlbGVtZW50KSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQgPSB0aGlzLl9nZXRSb290RWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBjdXN0b21FdmVudCA9IHRoaXMuX3RyaWdnZXJDbG9zZUV2ZW50KHJvb3RFbGVtZW50KTtcbiAgICAgIGlmIChjdXN0b21FdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Um9vdEVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcbiAgICAgIHZhciBwYXJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9ICQoZWxlbWVudCkuY2xvc2VzdChcIi5cIi5jb25jYXQoQ0xBU1NfTkFNRV9BTEVSVCkpWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyaWdnZXJDbG9zZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmlnZ2VyQ2xvc2VFdmVudChlbGVtZW50KSB7XG4gICAgICB2YXIgY2xvc2VFdmVudCA9ICQuRXZlbnQoRVZFTlRfQ0xPU0UpO1xuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGNsb3NlRXZlbnQpO1xuICAgICAgcmV0dXJuIGNsb3NlRXZlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAkKGVsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICBpZiAoISQoZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAkKGVsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50LCBldmVudCk7XG4gICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICQoZWxlbWVudCkuZGV0YWNoKCkudHJpZ2dlcihFVkVOVF9DTE9TRUQpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICB9XSwgW3tcbiAgICBrZXk6IFwiVkVSU0lPTlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9qUXVlcnlJbnRlcmZhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IEFsZXJ0KHRoaXMpO1xuICAgICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlRGlzbWlzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRGlzbWlzcyhhbGVydEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxlcnRJbnN0YW5jZS5jbG9zZSh0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cbiQoZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9ESVNNSVNTLCBBbGVydC5faGFuZGxlRGlzbWlzcyhuZXcgQWxlcnQoKSkpO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbiQuZm5bTkFNRV0gPSBBbGVydC5falF1ZXJ5SW50ZXJmYWNlO1xuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IEFsZXJ0O1xuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICByZXR1cm4gQWxlcnQuX2pRdWVyeUludGVyZmFjZTtcbn07XG5leHBvcnQgZGVmYXVsdCBBbGVydDsiLCJmdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjIpOiBidXR0b24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBOQU1FID0gJ2J1dHRvbic7XG52YXIgVkVSU0lPTiA9ICc0LjYuMic7XG52YXIgREFUQV9LRVkgPSAnYnMuYnV0dG9uJztcbnZhciBFVkVOVF9LRVkgPSBcIi5cIi5jb25jYXQoREFUQV9LRVkpO1xudmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xudmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG52YXIgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJztcbnZhciBDTEFTU19OQU1FX0JVVFRPTiA9ICdidG4nO1xudmFyIENMQVNTX05BTUVfRk9DVVMgPSAnZm9jdXMnO1xudmFyIEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gXCJjbGlja1wiLmNvbmNhdChFVkVOVF9LRVkpLmNvbmNhdChEQVRBX0FQSV9LRVkpO1xudmFyIEVWRU5UX0ZPQ1VTX0JMVVJfREFUQV9BUEkgPSBcImZvY3VzXCIuY29uY2F0KEVWRU5UX0tFWSkuY29uY2F0KERBVEFfQVBJX0tFWSwgXCIgXCIpICsgXCJibHVyXCIuY29uY2F0KEVWRU5UX0tFWSkuY29uY2F0KERBVEFfQVBJX0tFWSk7XG52YXIgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IFwibG9hZFwiLmNvbmNhdChFVkVOVF9LRVkpLmNvbmNhdChEQVRBX0FQSV9LRVkpO1xudmFyIFNFTEVDVE9SX0RBVEFfVE9HR0xFX0NBUlJPVCA9ICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJztcbnZhciBTRUxFQ1RPUl9EQVRBX1RPR0dMRVMgPSAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXSc7XG52YXIgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uXCJdJztcbnZhciBTRUxFQ1RPUl9EQVRBX1RPR0dMRVNfQlVUVE9OUyA9ICdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdIC5idG4nO1xudmFyIFNFTEVDVE9SX0lOUFVUID0gJ2lucHV0Om5vdChbdHlwZT1cImhpZGRlblwiXSknO1xudmFyIFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJztcbnZhciBTRUxFQ1RPUl9CVVRUT04gPSAnLmJ0bic7XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG52YXIgQnV0dG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnV0dG9uKGVsZW1lbnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uKTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLnNob3VsZEF2b2lkVHJpZ2dlckNoYW5nZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJ1dHRvbiwgW3tcbiAgICBrZXk6IFwidG9nZ2xlXCIsXG4gICAgdmFsdWU6XG4gICAgLy8gUHVibGljXG4gICAgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgdmFyIHRyaWdnZXJDaGFuZ2VFdmVudCA9IHRydWU7XG4gICAgICB2YXIgYWRkQXJpYVByZXNzZWQgPSB0cnVlO1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFUylbMF07XG4gICAgICBpZiAocm9vdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0lOUFVUKTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkICYmIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKSkge1xuICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9BQ1RJVkUpO1xuICAgICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICQoYWN0aXZlRWxlbWVudCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IGEgcmFkaW8gYnV0dG9uIG9yIGNoZWNrYm94IGRvbid0IGFkZCBhIHBvaW50bGVzcy9pbnZhbGlkIGNoZWNrZWQgcHJvcGVydHkgdG8gdGhlIGlucHV0XG4gICAgICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF2b2lkVHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgICAkKGlucHV0KS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICBhZGRBcmlhUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoISh0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkpIHtcbiAgICAgICAgaWYgKGFkZEFyaWFQcmVzc2VkKSB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsICF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gIH1dLCBbe1xuICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2pRdWVyeUludGVyZmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgYXZvaWRUcmlnZ2VyQ2hhbmdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBCdXR0b24odGhpcyk7XG4gICAgICAgICAgJGVsZW1lbnQuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5zaG91bGRBdm9pZFRyaWdnZXJDaGFuZ2UgPSBhdm9pZFRyaWdnZXJDaGFuZ2U7XG4gICAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG4kKGRvY3VtZW50KS5vbihFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEVfQ0FSUk9ULCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGJ1dHRvbiA9IGV2ZW50LnRhcmdldDtcbiAgdmFyIGluaXRpYWxCdXR0b24gPSBidXR0b247XG4gIGlmICghJChidXR0b24pLmhhc0NsYXNzKENMQVNTX05BTUVfQlVUVE9OKSkge1xuICAgIGJ1dHRvbiA9ICQoYnV0dG9uKS5jbG9zZXN0KFNFTEVDVE9SX0JVVFRPTilbMF07XG4gIH1cbiAgaWYgKCFidXR0b24gfHwgYnV0dG9uLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBidXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gd29yayBhcm91bmQgRmlyZWZveCBidWcgIzE1NDA5OTVcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5wdXRCdG4gPSBidXR0b24ucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9JTlBVVCk7XG4gICAgaWYgKGlucHV0QnRuICYmIChpbnB1dEJ0bi5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgaW5wdXRCdG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gd29yayBhcm91bmQgRmlyZWZveCBidWcgIzE1NDA5OTVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxCdXR0b24udGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBidXR0b24udGFnTmFtZSAhPT0gJ0xBQkVMJykge1xuICAgICAgQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKGJ1dHRvbiksICd0b2dnbGUnLCBpbml0aWFsQnV0dG9uLnRhZ05hbWUgPT09ICdJTlBVVCcpO1xuICAgIH1cbiAgfVxufSkub24oRVZFTlRfRk9DVVNfQkxVUl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEVfQ0FSUk9ULCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNFTEVDVE9SX0JVVFRPTilbMF07XG4gICQoYnV0dG9uKS50b2dnbGVDbGFzcyhDTEFTU19OQU1FX0ZPQ1VTLCAvXmZvY3VzKGluKT8kLy50ZXN0KGV2ZW50LnR5cGUpKTtcbn0pO1xuJCh3aW5kb3cpLm9uKEVWRU5UX0xPQURfREFUQV9BUEksIGZ1bmN0aW9uICgpIHtcbiAgLy8gZW5zdXJlIGNvcnJlY3QgYWN0aXZlIGNsYXNzIGlzIHNldCB0byBtYXRjaCB0aGUgY29udHJvbHMnIGFjdHVhbCB2YWx1ZXMvc3RhdGVzXG5cbiAgLy8gZmluZCBhbGwgY2hlY2tib3hlcy9yZWFkaW8gYnV0dG9ucyBpbnNpZGUgZGF0YS10b2dnbGUgZ3JvdXBzXG4gIHZhciBidXR0b25zID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFU19CVVRUT05TKSk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidXR0b25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG4gICAgdmFyIGlucHV0ID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfSU5QVVQpO1xuICAgIGlmIChpbnB1dC5jaGVja2VkIHx8IGlucHV0Lmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGFsbCBidXR0b24gdG9nZ2xlc1xuICBidXR0b25zID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFKSk7XG4gIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IGJ1dHRvbnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICB2YXIgX2J1dHRvbiA9IGJ1dHRvbnNbX2ldO1xuICAgIGlmIChfYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJykgPT09ICd0cnVlJykge1xuICAgICAgX2J1dHRvbi5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbiQuZm5bTkFNRV0gPSBCdXR0b24uX2pRdWVyeUludGVyZmFjZTtcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBCdXR0b247XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gIHJldHVybiBCdXR0b24uX2pRdWVyeUludGVyZmFjZTtcbn07XG5leHBvcnQgZGVmYXVsdCBCdXR0b247IiwiZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4yKTogY29sbGFwc2UuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTkFNRSA9ICdjb2xsYXBzZSc7XG52YXIgVkVSU0lPTiA9ICc0LjYuMic7XG52YXIgREFUQV9LRVkgPSAnYnMuY29sbGFwc2UnO1xudmFyIEVWRU5UX0tFWSA9IFwiLlwiLmNvbmNhdChEQVRBX0tFWSk7XG52YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG52YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcbnZhciBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XG52YXIgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSc7XG52YXIgQ0xBU1NfTkFNRV9DT0xMQVBTSU5HID0gJ2NvbGxhcHNpbmcnO1xudmFyIENMQVNTX05BTUVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCc7XG52YXIgRElNRU5TSU9OX1dJRFRIID0gJ3dpZHRoJztcbnZhciBESU1FTlNJT05fSEVJR0hUID0gJ2hlaWdodCc7XG52YXIgRVZFTlRfU0hPVyA9IFwic2hvd1wiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX1NIT1dOID0gXCJzaG93blwiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX0hJREUgPSBcImhpZGVcIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9ISURERU4gPSBcImhpZGRlblwiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gXCJjbGlja1wiLmNvbmNhdChFVkVOVF9LRVkpLmNvbmNhdChEQVRBX0FQSV9LRVkpO1xudmFyIFNFTEVDVE9SX0FDVElWRVMgPSAnLnNob3csIC5jb2xsYXBzaW5nJztcbnZhciBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXSc7XG52YXIgRGVmYXVsdCA9IHtcbiAgdG9nZ2xlOiB0cnVlLFxuICBwYXJlbnQ6ICcnXG59O1xudmFyIERlZmF1bHRUeXBlID0ge1xuICB0b2dnbGU6ICdib29sZWFuJyxcbiAgcGFyZW50OiAnKHN0cmluZ3xlbGVtZW50KSdcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG52YXIgQ29sbGFwc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xsYXBzZShlbGVtZW50LCBjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGFwc2UpO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXVtocmVmPVxcXCIjXCIuY29uY2F0KGVsZW1lbnQuaWQsIFwiXFxcIl0sXCIpICsgXCJbZGF0YS10b2dnbGU9XFxcImNvbGxhcHNlXFxcIl1bZGF0YS10YXJnZXQ9XFxcIiNcIi5jb25jYXQoZWxlbWVudC5pZCwgXCJcXFwiXVwiKSkpO1xuICAgIHZhciB0b2dnbGVMaXN0ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFKSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBlbGVtID0gdG9nZ2xlTGlzdFtpXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtKTtcbiAgICAgIHZhciBmaWx0ZXJFbGVtZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkuZmlsdGVyKGZ1bmN0aW9uIChmb3VuZEVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kRWxlbSA9PT0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmIGZpbHRlckVsZW1lbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudCA/IHRoaXMuX2dldFBhcmVudCgpIDogbnVsbDtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ29sbGFwc2UsIFt7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8vIFB1YmxpY1xuICAgIGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVzO1xuICAgICAgdmFyIGFjdGl2ZXNEYXRhO1xuICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICBhY3RpdmVzID0gW10uc2xpY2UuY2FsbCh0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9BQ1RJVkVTKSkuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5fY29uZmlnLnBhcmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXJlbnQnKSA9PT0gX3RoaXMuX2NvbmZpZy5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0NPTExBUFNFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGFjdGl2ZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlcykge1xuICAgICAgICBhY3RpdmVzRGF0YSA9ICQoYWN0aXZlcykubm90KHRoaXMuX3NlbGVjdG9yKS5kYXRhKERBVEFfS0VZKTtcbiAgICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudChFVkVOVF9TSE9XKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcbiAgICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVzKSB7XG4gICAgICAgIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKGFjdGl2ZXMpLm5vdCh0aGlzLl9zZWxlY3RvciksICdoaWRlJyk7XG4gICAgICAgIGlmICghYWN0aXZlc0RhdGEpIHtcbiAgICAgICAgICAkKGFjdGl2ZXMpLmRhdGEoREFUQV9LRVksIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0UpLmFkZENsYXNzKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwO1xuICAgICAgaWYgKHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgJCh0aGlzLl90cmlnZ2VyQXJyYXkpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0VEKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcodHJ1ZSk7XG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgJChfdGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKS5hZGRDbGFzcyhcIlwiLmNvbmNhdChDTEFTU19OQU1FX0NPTExBUFNFLCBcIiBcIikuY29uY2F0KENMQVNTX05BTUVfU0hPVykpO1xuICAgICAgICBfdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgICAgIF90aGlzLnNldFRyYW5zaXRpb25pbmcoZmFsc2UpO1xuICAgICAgICAkKF90aGlzLl9lbGVtZW50KS50cmlnZ2VyKEVWRU5UX1NIT1dOKTtcbiAgICAgIH07XG4gICAgICB2YXIgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcbiAgICAgIHZhciBzY3JvbGxTaXplID0gXCJzY3JvbGxcIi5jb25jYXQoY2FwaXRhbGl6ZWREaW1lbnNpb24pO1xuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IFwiXCIuY29uY2F0KHRoaXMuX2VsZW1lbnRbc2Nyb2xsU2l6ZV0sIFwicHhcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudChFVkVOVF9ISURFKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcbiAgICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IFwiXCIuY29uY2F0KHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXSwgXCJweFwiKTtcbiAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNJTkcpLnJlbW92ZUNsYXNzKFwiXCIuY29uY2F0KENMQVNTX05BTUVfQ09MTEFQU0UsIFwiIFwiKS5jb25jYXQoQ0xBU1NfTkFNRV9TSE9XKSk7XG4gICAgICB2YXIgdHJpZ2dlckFycmF5TGVuZ3RoID0gdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICh0cmlnZ2VyQXJyYXlMZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJpZ2dlckFycmF5TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJBcnJheVtpXTtcbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodHJpZ2dlcik7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpKTtcbiAgICAgICAgICAgIGlmICghJGVsZW0uaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgICAgICAgICAkKHRyaWdnZXIpLmFkZENsYXNzKENMQVNTX05BTUVfQ09MTEFQU0VEKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpO1xuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIF90aGlzMi5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcbiAgICAgICAgJChfdGhpczIuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0lORykuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9DT0xMQVBTRSkudHJpZ2dlcihFVkVOVF9ISURERU4pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VHJhbnNpdGlvbmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gaXNUcmFuc2l0aW9uaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpO1xuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IG51bGw7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25maWcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIERlZmF1bHQpLCBjb25maWcpO1xuICAgICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaW1lbnNpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpbWVuc2lvbigpIHtcbiAgICAgIHZhciBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRElNRU5TSU9OX1dJRFRIKTtcbiAgICAgIHJldHVybiBoYXNXaWR0aCA/IERJTUVOU0lPTl9XSURUSCA6IERJTUVOU0lPTl9IRUlHSFQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFBhcmVudCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudDtcbiAgICAgIGlmIChVdGlsLmlzRWxlbWVudCh0aGlzLl9jb25maWcucGFyZW50KSkge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50O1xuXG4gICAgICAgIC8vIEl0J3MgYSBqUXVlcnkgb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnBhcmVudC5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudFswXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9jb25maWcucGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxlY3RvciA9IFwiW2RhdGEtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCJdW2RhdGEtcGFyZW50PVxcXCJcIi5jb25jYXQodGhpcy5fY29uZmlnLnBhcmVudCwgXCJcXFwiXVwiKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICQoY2hpbGRyZW4pLmVhY2goZnVuY3Rpb24gKGksIGVsZW1lbnQpIHtcbiAgICAgICAgX3RoaXMzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoQ29sbGFwc2UuX2dldFRhcmdldEZyb21FbGVtZW50KGVsZW1lbnQpLCBbZWxlbWVudF0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZWxlbWVudCwgdHJpZ2dlckFycmF5KSB7XG4gICAgICB2YXIgaXNPcGVuID0gJChlbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpO1xuICAgICAgaWYgKHRyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgJCh0cmlnZ2VyQXJyYXkpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgfV0sIFt7XG4gICAga2V5OiBcIlZFUlNJT05cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFRhcmdldEZyb21FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gc2VsZWN0b3IgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9qUXVlcnlJbnRlcmZhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBEZWZhdWx0KSwgJGVsZW1lbnQuZGF0YSgpKSwgX3R5cGVvZihjb25maWcpID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSk7XG4gICAgICAgIGlmICghZGF0YSAmJiBfY29uZmlnLnRvZ2dsZSAmJiB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyAmJiAvc2hvd3xoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJGVsZW1lbnQuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gbWV0aG9kIG5hbWVkIFxcXCJcIi5jb25jYXQoY29uZmlnLCBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cbiQoZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcbiAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICB2YXIgJHRyaWdnZXIgPSAkKHRoaXMpO1xuICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XG4gIHZhciBzZWxlY3RvcnMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgJChzZWxlY3RvcnMpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGFyZ2V0ID0gJCh0aGlzKTtcbiAgICB2YXIgZGF0YSA9ICR0YXJnZXQuZGF0YShEQVRBX0tFWSk7XG4gICAgdmFyIGNvbmZpZyA9IGRhdGEgPyAndG9nZ2xlJyA6ICR0cmlnZ2VyLmRhdGEoKTtcbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHRhcmdldCwgY29uZmlnKTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG4kLmZuW05BTUVdID0gQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZTtcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBDb2xsYXBzZTtcbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgcmV0dXJuIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2U7XG59O1xuZXhwb3J0IGRlZmF1bHQgQ29sbGFwc2U7IiwiLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xNi4xXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgdGltZW91dER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufSgpO1xuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWZlcmVuY2Ugbm9kZSBvZiB0aGUgcmVmZXJlbmNlIG9iamVjdCwgb3IgdGhlIHJlZmVyZW5jZSBvYmplY3QgaXRzZWxmLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA/IHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlIDogcmVmZXJlbmNlO1xufVxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIHZhciBub09mZnNldFBhcmVudCA9IGlzSUUoMTApID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IG51bGw7XG4gIC8vIFNraXAgaGlkZGVuIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gb2Zmc2V0UGFyZW50XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgPT09IG5vT2Zmc2V0UGFyZW50ICYmIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gKGVsZW1lbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykub2Zmc2V0UGFyZW50O1xuICB9XG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10pICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddKTtcbn1cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKGRvY3VtZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRSgxMCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiBjbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5oZWlnaHQ7XG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KTtcbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0cztcbn1cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBleGNsdWRlU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMocG9wcGVyLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgMDtcbiAgdmFyIGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgYm91bmRhcmllcy5sZWZ0ICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQgfHwgMDtcbiAgYm91bmRhcmllcy50b3AgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcudG9wIHx8IDA7XG4gIGJvdW5kYXJpZXMucmlnaHQgLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcucmlnaHQgfHwgMDtcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcuYm90dG9tIHx8IDA7XG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7XG4gICAgbGVmdDogJ3JpZ2h0JyxcbiAgICByaWdodDogJ2xlZnQnLFxuICAgIGJvdHRvbTogJ3RvcCcsXG4gICAgdG9wOiAnYm90dG9tJ1xuICB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0bHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwge1xuICAgIHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJ1xuICB9KTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcG9wcGVyJ3MgcG9zaXRpb24gb2Zmc2V0cyByb3VuZGVkXG4gKlxuICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAqIGdvb2QgYXMgaXQgY2FuIGJlIHdpdGhpbiByZWFzb24uXG4gKiBEaXNjdXNzaW9uIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL3B1bGwvNzE1XG4gKlxuICogTG93IERQSSBzY3JlZW5zIGNhdXNlIGEgcG9wcGVyIHRvIGJlIGJsdXJyeSBpZiBub3QgdXNpbmcgZnVsbCBwaXhlbHMgKFNhZmFyaVxuICogYXMgd2VsbCBvbiBIaWdoIERQSSBzY3JlZW5zKS5cbiAqXG4gKiBGaXJlZm94IHByZWZlcnMgbm8gcm91bmRpbmcgZm9yIHBvc2l0aW9uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGJsdXJyaW5lc3Mgb25cbiAqIGhpZ2ggRFBJIHNjcmVlbnMuXG4gKlxuICogT25seSBob3Jpem9udGFsIHBsYWNlbWVudCBhbmQgbGVmdC9yaWdodCB2YWx1ZXMgbmVlZCB0byBiZSBjb25zaWRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBub1JvdW5kID0gZnVuY3Rpb24gbm9Sb3VuZCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG4gIHZhciByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihkYXRhLnBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgaXNWYXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5pbmRleE9mKCctJykgIT09IC0xO1xuICB2YXIgc2FtZVdpZHRoUGFyaXR5ID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSBwb3BwZXJXaWR0aCAlIDI7XG4gIHZhciBib3RoT2RkV2lkdGggPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IDEgJiYgcG9wcGVyV2lkdGggJSAyID09PSAxO1xuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eSA/IHJvdW5kIDogZmxvb3I7XG4gIHZhciB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cbnZhciBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIgJiYgL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcbiAgdmFyIG9mZnNldHMgPSBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDIgfHwgIWlzRmlyZWZveCk7XG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0pO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10pO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiBwb3BwZXIgY29udGVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zQnlDb250ZW50ICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzQm90dG9tIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKTtcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9IGZsaXBwZWRWYXJpYXRpb25CeVJlZiB8fCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50O1xuICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgIC8vIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgZGF0YS5mbGlwcGVkID0gdHJ1ZTtcbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgLy8gdGhpcyBvYmplY3QgY29udGFpbnMgYHBvc2l0aW9uYCwgd2Ugd2FudCB0byBwcmVzZXJ2ZSBpdCBhbG9uZyB3aXRoXG4gICAgICAvLyBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0eSB3ZSBtYXkgYWRkIGluIHRoZSBmdXR1cmVcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5mdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIHZhciB2YWx1ZSA9ICtzcGxpdFsxXTtcbiAgdmFyIHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgIHRyYW5zZm9ybSA9IHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXTtcbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICB2YXIgc2lkZSA9IFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgY2hlY2tbc2lkZV0ocGxhY2VtZW50KSk7XG4gIH0pO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSksXG4gICAgICBlbmQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICB9O1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICB2YXIgcmVmUmVjdCA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAncHJldmVudE92ZXJmbG93JztcbiAgfSkuYm91bmRhcmllcztcbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9IHJlZmVyZW5jZVtiYXNlUGxhY2VtZW50XSAtIChzdWJ0cmFjdExlbmd0aCA/IHBvcHBlcltpc0hvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA6IDApO1xuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgYG9mZnNldGAgbW9kaWZpZXIgY2FuIHNoaWZ0IHlvdXIgcG9wcGVyIG9uIGJvdGggaXRzIGF4aXMuXG4gICAqXG4gICAqIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB1bml0czpcbiAgICogLSBgcHhgIG9yIHVuaXQtbGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgYGhlaWdodGAuXG4gICAqXG4gICAqIFlvdSBjYW4gcHJvdmlkZSBhIHNpbmdsZSB2YWx1ZSAoYXMgYE51bWJlcmAgb3IgYFN0cmluZ2ApLCBvciBhIHBhaXIgb2YgdmFsdWVzXG4gICAqIGFzIGBTdHJpbmdgIGRpdmlkZWQgYnkgYSBjb21tYSBvciBvbmUgKG9yIG1vcmUpIHdoaXRlIHNwYWNlcy48YnIgLz5cbiAgICogVGhlIGxhdHRlciBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZnVzaW9uIGFuZCB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaW4gdjIuPGJyIC8+XG4gICAqIEFkZGl0aW9uYWxseSwgaXQgYWNjZXB0cyBhZGRpdGlvbnMgYW5kIHN1YnRyYWN0aW9ucyBiZXR3ZWVuIGRpZmZlcmVudCB1bml0cy5cbiAgICogTm90ZSB0aGF0IG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zIGFyZW4ndCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIFZhbGlkIGV4YW1wbGVzIGFyZTpcbiAgICogYGBgXG4gICAqIDEwXG4gICAqICcxMCUnXG4gICAqICcxMCwgMTAnXG4gICAqICcxMCUsIDEwJ1xuICAgKiAnMTAgKyAxMCUnXG4gICAqICcxMCAtIDV2aCArIDMlJ1xuICAgKiAnLTEwcHggKyA1dmgsIDVweCAtIDYlJ1xuICAgKiBgYGBcbiAgICogPiAqKk5CKio6IElmIHlvdSBkZXNpcmUgdG8gYXBwbHkgb2Zmc2V0cyB0byB5b3VyIHBvcHBlcnMgaW4gYSB3YXkgdGhhdCBtYXkgbWFrZSB0aGVtIG92ZXJsYXBcbiAgICogPiB3aXRoIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50LCB1bmZvcnR1bmF0ZWx5LCB5b3Ugd2lsbCBoYXZlIHRvIGRpc2FibGUgdGhlIGBmbGlwYCBtb2RpZmllci5cbiAgICogPiBZb3UgY2FuIHJlYWQgbW9yZSBvbiB0aGlzIGF0IHRoaXMgW2lzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIG9mZnNldDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0yMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IG9mZnNldCxcbiAgICAvKiogQHByb3Age051bWJlcnxTdHJpbmd9IG9mZnNldD0wXG4gICAgICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgb2Zmc2V0OiAwXG4gIH0sXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaCBvdGhlclxuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMuIFlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG4gIC8qKlxuICAgKiBUaGlzIG1vZGlmaWVyIGlzIHVzZWQgdG8gbW92ZSB0aGUgYGFycm93RWxlbWVudGAgb2YgdGhlIHBvcHBlciB0byBtYWtlXG4gICAqIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZWxlbWVudCBhbmQgaXRzIHBvcHBlciBlbGVtZW50LlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIG91dGVyIHNpemUgb2YgdGhlIGBhcnJvd0VsZW1lbnRgIG5vZGUgdG8gZGV0ZWN0IGhvdyBtYW55XG4gICAqIHBpeGVscyBvZiBjb25qdW5jdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9ucz1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudCBvdmVybGFwcyBpdHMgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ6IGZhbHNlXG4gIH0sXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91ciBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgLyoqXG4gICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgcG9wcGVyIHRvIHBvc2l0aW9uIGl0IHNlbGYgaW4gJ2ZpeGVkJyBtb2RlXG4gICAqIEBwcm9wIHtCb29sZWFufSBwb3NpdGlvbkZpeGVkPWZhbHNlXG4gICAqL1xuICBwb3NpdGlvbkZpeGVkOiBmYWxzZSxcbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZS5cbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgLyBYTUwgZWxlbWVudCB1c2VkIGFzIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAxLjcsIHRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHlvdVxuICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAqXG4gICAgICogKipERVBSRUNBVElPTioqOiBUaGlzIHdheSB0byBhY2Nlc3MgUG9wcGVyVXRpbHMgaXMgZGVwcmVjYXRlZFxuICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICAgKiBndWFyYW50ZWUgdGhlbSB0byBmb2xsb3cgc2VtdmVyLiBVc2UgdGhlbSBhdCB5b3VyIG93biByaXNrIVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgKiBAbWVtYmVyIFV0aWxzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuZXhwb3J0IGRlZmF1bHQgUG9wcGVyOyIsImZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMik6IGRyb3Bkb3duLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJztcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE5BTUUgPSAnZHJvcGRvd24nO1xudmFyIFZFUlNJT04gPSAnNC42LjInO1xudmFyIERBVEFfS0VZID0gJ2JzLmRyb3Bkb3duJztcbnZhciBFVkVOVF9LRVkgPSBcIi5cIi5jb25jYXQoREFUQV9LRVkpO1xudmFyIERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknO1xudmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG52YXIgRVNDQVBFX0tFWUNPREUgPSAyNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxudmFyIFNQQUNFX0tFWUNPREUgPSAzMjsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3Igc3BhY2Uga2V5XG52YXIgVEFCX0tFWUNPREUgPSA5OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB0YWIga2V5XG52YXIgQVJST1dfVVBfS0VZQ09ERSA9IDM4OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB1cCBhcnJvdyBrZXlcbnZhciBBUlJPV19ET1dOX0tFWUNPREUgPSA0MDsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgZG93biBhcnJvdyBrZXlcbnZhciBSSUdIVF9NT1VTRV9CVVRUT05fV0hJQ0ggPSAzOyAvLyBNb3VzZUV2ZW50LndoaWNoIHZhbHVlIGZvciB0aGUgcmlnaHQgYnV0dG9uIChhc3N1bWluZyBhIHJpZ2h0LWhhbmRlZCBtb3VzZSlcbnZhciBSRUdFWFBfS0VZRE9XTiA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoQVJST1dfVVBfS0VZQ09ERSwgXCJ8XCIpLmNvbmNhdChBUlJPV19ET1dOX0tFWUNPREUsIFwifFwiKS5jb25jYXQoRVNDQVBFX0tFWUNPREUpKTtcbnZhciBDTEFTU19OQU1FX0RJU0FCTEVEID0gJ2Rpc2FibGVkJztcbnZhciBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XG52YXIgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJztcbnZhciBDTEFTU19OQU1FX0RST1BSSUdIVCA9ICdkcm9wcmlnaHQnO1xudmFyIENMQVNTX05BTUVfRFJPUExFRlQgPSAnZHJvcGxlZnQnO1xudmFyIENMQVNTX05BTUVfTUVOVVJJR0hUID0gJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnO1xudmFyIENMQVNTX05BTUVfUE9TSVRJT05fU1RBVElDID0gJ3Bvc2l0aW9uLXN0YXRpYyc7XG52YXIgRVZFTlRfSElERSA9IFwiaGlkZVwiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX0hJRERFTiA9IFwiaGlkZGVuXCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfU0hPVyA9IFwic2hvd1wiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX1NIT1dOID0gXCJzaG93blwiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX0NMSUNLID0gXCJjbGlja1wiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gXCJjbGlja1wiLmNvbmNhdChFVkVOVF9LRVkpLmNvbmNhdChEQVRBX0FQSV9LRVkpO1xudmFyIEVWRU5UX0tFWURPV05fREFUQV9BUEkgPSBcImtleWRvd25cIi5jb25jYXQoRVZFTlRfS0VZKS5jb25jYXQoREFUQV9BUElfS0VZKTtcbnZhciBFVkVOVF9LRVlVUF9EQVRBX0FQSSA9IFwia2V5dXBcIi5jb25jYXQoRVZFTlRfS0VZKS5jb25jYXQoREFUQV9BUElfS0VZKTtcbnZhciBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSc7XG52YXIgU0VMRUNUT1JfRk9STV9DSElMRCA9ICcuZHJvcGRvd24gZm9ybSc7XG52YXIgU0VMRUNUT1JfTUVOVSA9ICcuZHJvcGRvd24tbWVudSc7XG52YXIgU0VMRUNUT1JfTkFWQkFSX05BViA9ICcubmF2YmFyLW5hdic7XG52YXIgU0VMRUNUT1JfVklTSUJMRV9JVEVNUyA9ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XG52YXIgUExBQ0VNRU5UX1RPUCA9ICd0b3Atc3RhcnQnO1xudmFyIFBMQUNFTUVOVF9UT1BFTkQgPSAndG9wLWVuZCc7XG52YXIgUExBQ0VNRU5UX0JPVFRPTSA9ICdib3R0b20tc3RhcnQnO1xudmFyIFBMQUNFTUVOVF9CT1RUT01FTkQgPSAnYm90dG9tLWVuZCc7XG52YXIgUExBQ0VNRU5UX1JJR0hUID0gJ3JpZ2h0LXN0YXJ0JztcbnZhciBQTEFDRU1FTlRfTEVGVCA9ICdsZWZ0LXN0YXJ0JztcbnZhciBEZWZhdWx0ID0ge1xuICBvZmZzZXQ6IDAsXG4gIGZsaXA6IHRydWUsXG4gIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcbiAgcmVmZXJlbmNlOiAndG9nZ2xlJyxcbiAgZGlzcGxheTogJ2R5bmFtaWMnLFxuICBwb3BwZXJDb25maWc6IG51bGxcbn07XG52YXIgRGVmYXVsdFR5cGUgPSB7XG4gIG9mZnNldDogJyhudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGZsaXA6ICdib29sZWFuJyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIGRpc3BsYXk6ICdzdHJpbmcnLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3QpJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cbnZhciBEcm9wZG93biA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERyb3Bkb3duKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bik7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9tZW51ID0gdGhpcy5fZ2V0TWVudUVsZW1lbnQoKTtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRHJvcGRvd24sIFt7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8vIFB1YmxpY1xuICAgIGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LmRpc2FibGVkIHx8ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGlzQWN0aXZlID0gJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpO1xuICAgICAgRHJvcGRvd24uX2NsZWFyTWVudXMoKTtcbiAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNob3codHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciB1c2VQb3BwZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0RJU0FCTEVEKSB8fCAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudChFVkVOVF9TSE9XLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAkKHBhcmVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRvdGFsbHkgZGlzYWJsZSBQb3BwZXIgZm9yIERyb3Bkb3ducyBpbiBOYXZiYXJcbiAgICAgIGlmICghdGhpcy5faW5OYXZiYXIgJiYgdXNlUG9wcGVyKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBQb3BwZXIgZGVwZW5kZW5jeVxuICAgICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChVdGlsLmlzRWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xuICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBqUXVlcnkgZWxlbWVudFxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZS5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZVswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBib3VuZGFyeSBpcyBub3QgYHNjcm9sbFBhcmVudGAsIHRoZW4gc2V0IHBvc2l0aW9uIHRvIGBzdGF0aWNgXG4gICAgICAgIC8vIHRvIGFsbG93IHRoZSBtZW51IHRvIFwiZXNjYXBlXCIgdGhlIHNjcm9sbCBwYXJlbnQncyBib3VuZGFyaWVzXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMjQyNTFcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5ib3VuZGFyeSAhPT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgICAgICAkKHBhcmVudCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9QT1NJVElPTl9TVEFUSUMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG5ldyBQb3BwZXIocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAkKHBhcmVudCkuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVJfTkFWKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9uKCdtb3VzZW92ZXInLCBudWxsLCAkLm5vb3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICAgICQodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICAgICQocGFyZW50KS50b2dnbGVDbGFzcyhDTEFTU19OQU1FX1NIT1cpLnRyaWdnZXIoJC5FdmVudChFVkVOVF9TSE9XTiwgcmVsYXRlZFRhcmdldCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRElTQUJMRUQpIHx8ICEkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudChFVkVOVF9ISURFLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAkKHBhcmVudCkudHJpZ2dlcihoaWRlRXZlbnQpO1xuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICAkKHRoaXMuX21lbnUpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICAkKHBhcmVudCkudG9nZ2xlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKS50cmlnZ2VyKCQuRXZlbnQoRVZFTlRfSElEREVOLCByZWxhdGVkVGFyZ2V0KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9LRVkpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9tZW51ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgfSwge1xuICAgIGtleTogXCJfYWRkRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRVZFTlRfQ0xJQ0ssIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgX3RoaXMudG9nZ2xlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCksICQodGhpcy5fZWxlbWVudCkuZGF0YSgpKSwgY29uZmlnKTtcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TWVudUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE1lbnVFbGVtZW50KCkge1xuICAgICAgaWYgKCF0aGlzLl9tZW51KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLl9tZW51ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfTUVOVSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9tZW51O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0UGxhY2VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQbGFjZW1lbnQoKSB7XG4gICAgICB2YXIgJHBhcmVudERyb3Bkb3duID0gJCh0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUpO1xuICAgICAgdmFyIHBsYWNlbWVudCA9IFBMQUNFTUVOVF9CT1RUT007XG5cbiAgICAgIC8vIEhhbmRsZSBkcm9wdXBcbiAgICAgIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XG4gICAgICAgIHBsYWNlbWVudCA9ICQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9NRU5VUklHSFQpID8gUExBQ0VNRU5UX1RPUEVORCA6IFBMQUNFTUVOVF9UT1A7XG4gICAgICB9IGVsc2UgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDTEFTU19OQU1FX0RST1BSSUdIVCkpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gUExBQ0VNRU5UX1JJR0hUO1xuICAgICAgfSBlbHNlIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QTEVGVCkpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gUExBQ0VNRU5UX0xFRlQ7XG4gICAgICB9IGVsc2UgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9NRU5VUklHSFQpKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IFBMQUNFTUVOVF9CT1RUT01FTkQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGxhY2VtZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZWN0TmF2YmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgICByZXR1cm4gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KCcubmF2YmFyJykubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0T2Zmc2V0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgb2Zmc2V0ID0ge307XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2Zmc2V0LmZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkYXRhLm9mZnNldHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRhdGEub2Zmc2V0cyksIF90aGlzMi5fY29uZmlnLm9mZnNldChkYXRhLm9mZnNldHMsIF90aGlzMi5fZWxlbWVudCkpO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Lm9mZnNldCA9IHRoaXMuX2NvbmZpZy5vZmZzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0UG9wcGVyQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgICB2YXIgcG9wcGVyQ29uZmlnID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpLFxuICAgICAgICAgIGZsaXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuX2NvbmZpZy5mbGlwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIERpc2FibGUgUG9wcGVyIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSAnc3RhdGljJykge1xuICAgICAgICBwb3BwZXJDb25maWcubW9kaWZpZXJzLmFwcGx5U3R5bGUgPSB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcHBlckNvbmZpZyksIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcpO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICB9XSwgW3tcbiAgICBrZXk6IFwiVkVSU0lPTlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkRlZmF1bHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJEZWZhdWx0VHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfalF1ZXJ5SW50ZXJmYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9IF90eXBlb2YoY29uZmlnKSA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gbWV0aG9kIG5hbWVkIFxcXCJcIi5jb25jYXQoY29uZmlnLCBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhck1lbnVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhck1lbnVzKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQgJiYgKGV2ZW50LndoaWNoID09PSBSSUdIVF9NT1VTRV9CVVRUT05fV0hJQ0ggfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCAhPT0gVEFCX0tFWUNPREUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0b2dnbGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFKSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9nZ2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRvZ2dsZXNbaV0pO1xuICAgICAgICB2YXIgY29udGV4dCA9ICQodG9nZ2xlc1tpXSkuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRvZ2dsZXNbaV1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJvcGRvd25NZW51ID0gY29udGV4dC5fbWVudTtcbiAgICAgICAgaWYgKCEkKHBhcmVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSB8fCBldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LndoaWNoID09PSBUQUJfS0VZQ09ERSkgJiYgJC5jb250YWlucyhwYXJlbnQsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudChFVkVOVF9ISURFLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgJChwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcbiAgICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlc1tpXS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgaWYgKGNvbnRleHQuX3BvcHBlcikge1xuICAgICAgICAgIGNvbnRleHQuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgJChkcm9wZG93bk1lbnUpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICAgICQocGFyZW50KS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX1NIT1cpLnRyaWdnZXIoJC5FdmVudChFVkVOVF9ISURERU4sIHJlbGF0ZWRUYXJnZXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFBhcmVudEZyb21FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQYXJlbnRGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgcGFyZW50O1xuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudCB8fCBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgfSwge1xuICAgIGtleTogXCJfZGF0YUFwaUtleWRvd25IYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIC8vIElmIG5vdCBpbnB1dC90ZXh0YXJlYTpcbiAgICAgIC8vICAtIEFuZCBub3QgYSBrZXkgaW4gUkVHRVhQX0tFWURPV04gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgICAgLy8gSWYgaW5wdXQvdGV4dGFyZWE6XG4gICAgICAvLyAgLSBJZiBzcGFjZSBrZXkgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgICAgLy8gIC0gSWYga2V5IGlzIG90aGVyIHRoYW4gZXNjYXBlXG4gICAgICAvLyAgICAtIElmIGtleSBpcyBub3QgdXAgb3IgZG93biA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgICAvLyAgICAtIElmIHRyaWdnZXIgaW5zaWRlIHRoZSBtZW51ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSA/IGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoICE9PSBFU0NBUEVfS0VZQ09ERSAmJiAoZXZlbnQud2hpY2ggIT09IEFSUk9XX0RPV05fS0VZQ09ERSAmJiBldmVudC53aGljaCAhPT0gQVJST1dfVVBfS0VZQ09ERSB8fCAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChTRUxFQ1RPUl9NRU5VKS5sZW5ndGgpIDogIVJFR0VYUF9LRVlET1dOLnRlc3QoZXZlbnQud2hpY2gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICQodGhpcykuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzKTtcbiAgICAgIHZhciBpc0FjdGl2ZSA9ICQocGFyZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpO1xuICAgICAgaWYgKCFpc0FjdGl2ZSAmJiBldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKCFpc0FjdGl2ZSB8fCBldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUgfHwgZXZlbnQud2hpY2ggPT09IFNQQUNFX0tFWUNPREUpIHtcbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgICQocGFyZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfREFUQV9UT0dHTEUpKS50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9XG4gICAgICAgICQodGhpcykudHJpZ2dlcignY2xpY2snKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZW1zID0gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TKSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiAkKGl0ZW0pLmlzKCc6dmlzaWJsZScpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZXZlbnQudGFyZ2V0KTtcbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfVVBfS0VZQ09ERSAmJiBpbmRleCA+IDApIHtcbiAgICAgICAgLy8gVXBcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBEb3duXG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIGl0ZW1zW2luZGV4XS5mb2N1cygpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG4kKGRvY3VtZW50KS5vbihFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcikub24oRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfTUVOVSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcikub24oXCJcIi5jb25jYXQoRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFwiIFwiKS5jb25jYXQoRVZFTlRfS0VZVVBfREFUQV9BUEkpLCBEcm9wZG93bi5fY2xlYXJNZW51cykub24oRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRoaXMpLCAndG9nZ2xlJyk7XG59KS5vbihFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfRk9STV9DSElMRCwgZnVuY3Rpb24gKGUpIHtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbn0pO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbiQuZm5bTkFNRV0gPSBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlO1xuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IERyb3Bkb3duO1xuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICByZXR1cm4gRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZTtcbn07XG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bjsiLCJmdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjIpOiBtb2RhbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBOQU1FID0gJ21vZGFsJztcbnZhciBWRVJTSU9OID0gJzQuNi4yJztcbnZhciBEQVRBX0tFWSA9ICdicy5tb2RhbCc7XG52YXIgRVZFTlRfS0VZID0gXCIuXCIuY29uY2F0KERBVEFfS0VZKTtcbnZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbnZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xudmFyIEVTQ0FQRV9LRVlDT0RFID0gMjc7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcblxudmFyIENMQVNTX05BTUVfU0NST0xMQUJMRSA9ICdtb2RhbC1kaWFsb2ctc2Nyb2xsYWJsZSc7XG52YXIgQ0xBU1NfTkFNRV9TQ1JPTExCQVJfTUVBU1VSRVIgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnO1xudmFyIENMQVNTX05BTUVfQkFDS0RST1AgPSAnbW9kYWwtYmFja2Ryb3AnO1xudmFyIENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJztcbnZhciBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG52YXIgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xudmFyIENMQVNTX05BTUVfU1RBVElDID0gJ21vZGFsLXN0YXRpYyc7XG52YXIgRVZFTlRfSElERSA9IFwiaGlkZVwiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX0hJREVfUFJFVkVOVEVEID0gXCJoaWRlUHJldmVudGVkXCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfSElEREVOID0gXCJoaWRkZW5cIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9TSE9XID0gXCJzaG93XCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfU0hPV04gPSBcInNob3duXCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfRk9DVVNJTiA9IFwiZm9jdXNpblwiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX1JFU0laRSA9IFwicmVzaXplXCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IFwiY2xpY2suZGlzbWlzc1wiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX0tFWURPV05fRElTTUlTUyA9IFwia2V5ZG93bi5kaXNtaXNzXCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfTU9VU0VVUF9ESVNNSVNTID0gXCJtb3VzZXVwLmRpc21pc3NcIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IFwibW91c2Vkb3duLmRpc21pc3NcIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9DTElDS19EQVRBX0FQSSA9IFwiY2xpY2tcIi5jb25jYXQoRVZFTlRfS0VZKS5jb25jYXQoREFUQV9BUElfS0VZKTtcbnZhciBTRUxFQ1RPUl9ESUFMT0cgPSAnLm1vZGFsLWRpYWxvZyc7XG52YXIgU0VMRUNUT1JfTU9EQUxfQk9EWSA9ICcubW9kYWwtYm9keSc7XG52YXIgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nO1xudmFyIFNFTEVDVE9SX0RBVEFfRElTTUlTUyA9ICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nO1xudmFyIFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XG52YXIgU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQgPSAnLnN0aWNreS10b3AnO1xudmFyIERlZmF1bHQgPSB7XG4gIGJhY2tkcm9wOiB0cnVlLFxuICBrZXlib2FyZDogdHJ1ZSxcbiAgZm9jdXM6IHRydWUsXG4gIHNob3c6IHRydWVcbn07XG52YXIgRGVmYXVsdFR5cGUgPSB7XG4gIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gIGZvY3VzOiAnYm9vbGVhbicsXG4gIHNob3c6ICdib29sZWFuJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cbnZhciBNb2RhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vZGFsKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbCk7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fZGlhbG9nID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0RJQUxPRyk7XG4gICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsO1xuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IDA7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTW9kYWwsIFt7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8vIFB1YmxpY1xuICAgIGZ1bmN0aW9uIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudChFVkVOVF9TSE9XLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pO1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudCk7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgICAgaWYgKCQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKSkge1xuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2hlY2tTY3JvbGxiYXIoKTtcbiAgICAgIHRoaXMuX3NldFNjcm9sbGJhcigpO1xuICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gICAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpO1xuICAgICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRVZFTlRfQ0xJQ0tfRElTTUlTUywgU0VMRUNUT1JfREFUQV9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhpZGUoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICAkKHRoaXMuX2RpYWxvZykub24oRVZFTlRfTU9VU0VET1dOX0RJU01JU1MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJChfdGhpcy5fZWxlbWVudCkub25lKEVWRU5UX01PVVNFVVBfRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyhfdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgICAgIF90aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zaG93QmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZShldmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoRVZFTlRfSElERSk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSk7XG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcbiAgICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCk7XG4gICAgICAkKGRvY3VtZW50KS5vZmYoRVZFTlRfRk9DVVNJTik7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9DTElDS19ESVNNSVNTKTtcbiAgICAgICQodGhpcy5fZGlhbG9nKS5vZmYoRVZFTlRfTU9VU0VET1dOX0RJU01JU1MpO1xuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX2hpZGVNb2RhbChldmVudCk7XG4gICAgICAgIH0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9oaWRlTW9kYWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgW3dpbmRvdywgdGhpcy5fZWxlbWVudCwgdGhpcy5fZGlhbG9nXS5mb3JFYWNoKGZ1bmN0aW9uIChodG1sRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gJChodG1sRWxlbWVudCkub2ZmKEVWRU5UX0tFWSk7XG4gICAgICB9KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBgZG9jdW1lbnRgIGhhcyAyIGV2ZW50cyBgRVZFTlRfRk9DVVNJTmAgYW5kIGBFVkVOVF9DTElDS19EQVRBX0FQSWBcbiAgICAgICAqIERvIG5vdCBtb3ZlIGBkb2N1bWVudGAgaW4gYGh0bWxFbGVtZW50c2AgYXJyYXlcbiAgICAgICAqIEl0IHdpbGwgcmVtb3ZlIGBFVkVOVF9DTElDS19EQVRBX0FQSWAgZXZlbnQgdGhhdCBzaG91bGQgcmVtYWluXG4gICAgICAgKi9cbiAgICAgICQoZG9jdW1lbnQpLm9mZihFVkVOVF9GT0NVU0lOKTtcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSk7XG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9kaWFsb2cgPSBudWxsO1xuICAgICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsO1xuICAgICAgdGhpcy5faXNTaG93biA9IG51bGw7XG4gICAgICB0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyA9IG51bGw7XG4gICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVVcGRhdGUoKSB7XG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBEZWZhdWx0KSwgY29uZmlnKTtcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBoaWRlRXZlbnRQcmV2ZW50ZWQgPSAkLkV2ZW50KEVWRU5UX0hJREVfUFJFVkVOVEVEKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihoaWRlRXZlbnRQcmV2ZW50ZWQpO1xuICAgICAgaWYgKGhpZGVFdmVudFByZXZlbnRlZC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKCFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NUQVRJQyk7XG4gICAgICB2YXIgbW9kYWxUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZyk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihVdGlsLlRSQU5TSVRJT05fRU5EKTtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpO1xuICAgICAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICAgICQoX3RoaXMzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICcnO1xuICAgICAgICAgIH0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKF90aGlzMy5fZWxlbWVudCwgbW9kYWxUcmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbFRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zaG93RWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKTtcbiAgICAgIHZhciBtb2RhbEJvZHkgPSB0aGlzLl9kaWFsb2cgPyB0aGlzLl9kaWFsb2cucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9NT0RBTF9CT0RZKSA6IG51bGw7XG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIC8vIERvbid0IG1vdmUgbW9kYWwncyBET00gcG9zaXRpb25cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICAgIGlmICgkKHRoaXMuX2RpYWxvZykuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TQ1JPTExBQkxFKSAmJiBtb2RhbEJvZHkpIHtcbiAgICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgICQodGhpcy5fZWxlbWVudCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgdGhpcy5fZW5mb3JjZUZvY3VzKCk7XG4gICAgICB9XG4gICAgICB2YXIgc2hvd25FdmVudCA9ICQuRXZlbnQoRVZFTlRfU0hPV04sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG4gICAgICB2YXIgdHJhbnNpdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gdHJhbnNpdGlvbkNvbXBsZXRlKCkge1xuICAgICAgICBpZiAoX3RoaXM0Ll9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgICBfdGhpczQuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczQuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICAkKF90aGlzNC5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KTtcbiAgICAgIH07XG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9kaWFsb2cpO1xuICAgICAgICAkKHRoaXMuX2RpYWxvZykub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIHRyYW5zaXRpb25Db21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW5mb3JjZUZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbmZvcmNlRm9jdXMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgICQoZG9jdW1lbnQpLm9mZihFVkVOVF9GT0NVU0lOKSAvLyBHdWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbihFVkVOVF9GT0NVU0lOLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50ICE9PSBldmVudC50YXJnZXQgJiYgX3RoaXM1Ll9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiYgJChfdGhpczUuX2VsZW1lbnQpLmhhcyhldmVudC50YXJnZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIF90aGlzNS5fZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEVzY2FwZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRFc2NhcGVFdmVudCgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9LRVlET1dOX0RJU01JU1MsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmIChfdGhpczYuX2NvbmZpZy5rZXlib2FyZCAmJiBldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpczYuaGlkZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIV90aGlzNi5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgICAgX3RoaXM2Ll90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfS0VZRE9XTl9ESVNNSVNTKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFJlc2l6ZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRSZXNpemVFdmVudCgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgJCh3aW5kb3cpLm9uKEVWRU5UX1JFU0laRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNy5oYW5kbGVVcGRhdGUoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQod2luZG93KS5vZmYoRVZFTlRfUkVTSVpFKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVNb2RhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZU1vZGFsKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9zaG93QmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfT1BFTik7XG4gICAgICAgIF90aGlzOC5fcmVzZXRBZGp1c3RtZW50cygpO1xuICAgICAgICBfdGhpczguX3Jlc2V0U2Nyb2xsYmFyKCk7XG4gICAgICAgICQoX3RoaXM4Ll9lbGVtZW50KS50cmlnZ2VyKEVWRU5UX0hJRERFTik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUJhY2tkcm9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVCYWNrZHJvcCgpIHtcbiAgICAgIGlmICh0aGlzLl9iYWNrZHJvcCkge1xuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2hvd0JhY2tkcm9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93QmFja2Ryb3AoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgdmFyIGFuaW1hdGUgPSAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkgPyBDTEFTU19OQU1FX0ZBREUgOiAnJztcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICB0aGlzLl9iYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcC5jbGFzc05hbWUgPSBDTEFTU19OQU1FX0JBQ0tEUk9QO1xuICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTGlzdC5hZGQoYW5pbWF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub24oRVZFTlRfQ0xJQ0tfRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzOS5faWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgICAgX3RoaXM5Ll9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzOS5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgX3RoaXM5Ll90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzOS5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICBVdGlsLnJlZmxvdyh0aGlzLl9iYWNrZHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFuaW1hdGUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2JhY2tkcm9wKTtcbiAgICAgICAgJCh0aGlzLl9iYWNrZHJvcCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNhbGxiYWNrKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChiYWNrZHJvcFRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1Nob3duICYmIHRoaXMuX2JhY2tkcm9wKSB7XG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uIGNhbGxiYWNrUmVtb3ZlKCkge1xuICAgICAgICAgIF90aGlzOS5fcmVtb3ZlQmFja2Ryb3AoKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUpKSB7XG4gICAgICAgICAgdmFyIF9iYWNrZHJvcFRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fYmFja2Ryb3ApO1xuICAgICAgICAgICQodGhpcy5fYmFja2Ryb3ApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFja1JlbW92ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoX2JhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFja1JlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gICAgLy8gdG9kbyAoZmF0KTogdGhlc2Ugc2hvdWxkIHByb2JhYmx5IGJlIHJlZmFjdG9yZWQgb3V0IG9mIG1vZGFsLmpzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB9LCB7XG4gICAga2V5OiBcIl9hZGp1c3REaWFsb2dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkanVzdERpYWxvZygpIHtcbiAgICAgIHZhciBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAoIXRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCJcIi5jb25jYXQodGhpcy5fc2Nyb2xsYmFyV2lkdGgsIFwicHhcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuX3Njcm9sbGJhcldpZHRoLCBcInB4XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzZXRBZGp1c3RtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSAnJztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja1Njcm9sbGJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tTY3JvbGxiYXIoKSB7XG4gICAgICB2YXIgcmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyA9IE1hdGgucm91bmQocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgPCB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gdGhpcy5fZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFNjcm9sbGJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2Nyb2xsYmFyKCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKSB7XG4gICAgICAgIC8vIE5vdGU6IERPTU5vZGUuc3R5bGUucGFkZGluZ1JpZ2h0IHJldHVybnMgdGhlIGFjdHVhbCB2YWx1ZSBvciAnJyBpZiBub3Qgc2V0XG4gICAgICAgIC8vICAgd2hpbGUgJChET01Ob2RlKS5jc3MoJ3BhZGRpbmctcmlnaHQnKSByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHZhbHVlIG9yIDAgaWYgbm90IHNldFxuICAgICAgICB2YXIgZml4ZWRDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQpKTtcbiAgICAgICAgdmFyIHN0aWNreUNvbnRlbnQgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQpKTtcblxuICAgICAgICAvLyBBZGp1c3QgZml4ZWQgY29udGVudCBwYWRkaW5nXG4gICAgICAgICQoZml4ZWRDb250ZW50KS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgIHZhciBhY3R1YWxQYWRkaW5nID0gZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQYWRkaW5nID0gJChlbGVtZW50KS5jc3MoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgICAkKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBcIlwiLmNvbmNhdChwYXJzZUZsb2F0KGNhbGN1bGF0ZWRQYWRkaW5nKSArIF90aGlzMTAuX3Njcm9sbGJhcldpZHRoLCBcInB4XCIpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRqdXN0IHN0aWNreSBjb250ZW50IG1hcmdpblxuICAgICAgICAkKHN0aWNreUNvbnRlbnQpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGFjdHVhbE1hcmdpbiA9IGVsZW1lbnQuc3R5bGUubWFyZ2luUmlnaHQ7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRNYXJnaW4gPSAkKGVsZW1lbnQpLmNzcygnbWFyZ2luLXJpZ2h0Jyk7XG4gICAgICAgICAgJChlbGVtZW50KS5kYXRhKCdtYXJnaW4tcmlnaHQnLCBhY3R1YWxNYXJnaW4pLmNzcygnbWFyZ2luLXJpZ2h0JywgXCJcIi5jb25jYXQocGFyc2VGbG9hdChjYWxjdWxhdGVkTWFyZ2luKSAtIF90aGlzMTAuX3Njcm9sbGJhcldpZHRoLCBcInB4XCIpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRqdXN0IGJvZHkgcGFkZGluZ1xuICAgICAgICB2YXIgYWN0dWFsUGFkZGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICB2YXIgY2FsY3VsYXRlZFBhZGRpbmcgPSAkKGRvY3VtZW50LmJvZHkpLmNzcygncGFkZGluZy1yaWdodCcpO1xuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmRhdGEoJ3BhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBcIlwiLmNvbmNhdChwYXJzZUZsb2F0KGNhbGN1bGF0ZWRQYWRkaW5nKSArIHRoaXMuX3Njcm9sbGJhcldpZHRoLCBcInB4XCIpKTtcbiAgICAgIH1cbiAgICAgICQoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9PUEVOKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2V0U2Nyb2xsYmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldFNjcm9sbGJhcigpIHtcbiAgICAgIC8vIFJlc3RvcmUgZml4ZWQgY29udGVudCBwYWRkaW5nXG4gICAgICB2YXIgZml4ZWRDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQpKTtcbiAgICAgICQoZml4ZWRDb250ZW50KS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgcGFkZGluZyA9ICQoZWxlbWVudCkuZGF0YSgncGFkZGluZy1yaWdodCcpO1xuICAgICAgICAkKGVsZW1lbnQpLnJlbW92ZURhdGEoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nID8gcGFkZGluZyA6ICcnO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlc3RvcmUgc3RpY2t5IGNvbnRlbnRcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIlwiLmNvbmNhdChTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCkpKTtcbiAgICAgICQoZWxlbWVudHMpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBtYXJnaW4gPSAkKGVsZW1lbnQpLmRhdGEoJ21hcmdpbi1yaWdodCcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcmdpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAkKGVsZW1lbnQpLmNzcygnbWFyZ2luLXJpZ2h0JywgbWFyZ2luKS5yZW1vdmVEYXRhKCdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYm9keSBwYWRkaW5nXG4gICAgICB2YXIgcGFkZGluZyA9ICQoZG9jdW1lbnQuYm9keSkuZGF0YSgncGFkZGluZy1yaWdodCcpO1xuICAgICAgJChkb2N1bWVudC5ib2R5KS5yZW1vdmVEYXRhKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHBhZGRpbmcgPyBwYWRkaW5nIDogJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTY3JvbGxiYXJXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAvLyB0aHggZC53YWxzaFxuICAgICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IENMQVNTX05BTUVfU0NST0xMQkFSX01FQVNVUkVSO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgdmFyIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICB9XSwgW3tcbiAgICBrZXk6IFwiVkVSU0lPTlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkRlZmF1bHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfalF1ZXJ5SW50ZXJmYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpO1xuICAgICAgICB2YXIgX2NvbmZpZyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBEZWZhdWx0KSwgJCh0aGlzKS5kYXRhKCkpLCBfdHlwZW9mKGNvbmZpZykgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIuY29uY2F0KGNvbmZpZywgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb25maWcuc2hvdykge1xuICAgICAgICAgIGRhdGEuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cbiQoZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBfdGhpczExID0gdGhpcztcbiAgdmFyIHRhcmdldDtcbiAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpO1xuICBpZiAoc2VsZWN0b3IpIHtcbiAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfVxuICB2YXIgY29uZmlnID0gJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkpID8gJ3RvZ2dsZScgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sICQodGFyZ2V0KS5kYXRhKCkpLCAkKHRoaXMpLmRhdGEoKSk7XG4gIGlmICh0aGlzLnRhZ05hbWUgPT09ICdBJyB8fCB0aGlzLnRhZ05hbWUgPT09ICdBUkVBJykge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgdmFyICR0YXJnZXQgPSAkKHRhcmdldCkub25lKEVWRU5UX1NIT1csIGZ1bmN0aW9uIChzaG93RXZlbnQpIHtcbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAvLyBPbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICR0YXJnZXQub25lKEVWRU5UX0hJRERFTiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCQoX3RoaXMxMSkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgX3RoaXMxMS5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgTW9kYWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnLCB0aGlzKTtcbn0pO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbiQuZm5bTkFNRV0gPSBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IE1vZGFsO1xuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICByZXR1cm4gTW9kYWwuX2pRdWVyeUludGVyZmFjZTtcbn07XG5leHBvcnQgZGVmYXVsdCBNb2RhbDsiLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMik6IHRvb2xzL3Nhbml0aXplci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciB1cmlBdHRycyA9IFsnYmFja2dyb3VuZCcsICdjaXRlJywgJ2hyZWYnLCAnaXRlbXR5cGUnLCAnbG9uZ2Rlc2MnLCAncG9zdGVyJywgJ3NyYycsICd4bGluazpocmVmJ107XG52YXIgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pO1xuZXhwb3J0IHZhciBEZWZhdWx0V2hpdGVsaXN0ID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxuICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRpdjogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbJ3NyYycsICdzcmNzZXQnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59O1xuXG4vKipcbiAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cbiAqXG4gKiBTaG91dG91dCB0byBBbmd1bGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi8xMi4yLngvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAqL1xudmFyIFNBRkVfVVJMX1BBVFRFUk4gPSAvXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlfHNtcyk6fFteIyYvOj9dKig/OlsjLz9dfCQpKS9pO1xuXG4vKipcbiAqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBkYXRhIFVSTHMuIE9ubHkgbWF0Y2hlcyBpbWFnZSwgdmlkZW8gYW5kIGF1ZGlvIHR5cGVzLlxuICpcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIueC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG52YXIgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFtcXGQrL2Etel0rPSokL2k7XG5mdW5jdGlvbiBhbGxvd2VkQXR0cmlidXRlKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSB7XG4gIHZhciBhdHRyTmFtZSA9IGF0dHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluZGV4T2YoYXR0ck5hbWUpICE9PSAtMSkge1xuICAgIGlmICh1cmlBdHRycy5pbmRleE9mKGF0dHJOYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKFNBRkVfVVJMX1BBVFRFUk4udGVzdChhdHRyLm5vZGVWYWx1ZSkgfHwgREFUQV9VUkxfUEFUVEVSTi50ZXN0KGF0dHIubm9kZVZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciByZWdFeHAgPSBhbGxvd2VkQXR0cmlidXRlTGlzdC5maWx0ZXIoZnVuY3Rpb24gKGF0dHJSZWdleCkge1xuICAgIHJldHVybiBhdHRyUmVnZXggaW5zdGFuY2VvZiBSZWdFeHA7XG4gIH0pO1xuXG4gIC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVnRXhwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHJlZ0V4cFtpXS50ZXN0KGF0dHJOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgd2hpdGVMaXN0LCBzYW5pdGl6ZUZuKSB7XG4gIGlmICh1bnNhZmVIdG1sLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bnNhZmVIdG1sO1xuICB9XG4gIGlmIChzYW5pdGl6ZUZuICYmIHR5cGVvZiBzYW5pdGl6ZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNhbml0aXplRm4odW5zYWZlSHRtbCk7XG4gIH1cbiAgdmFyIGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XG4gIHZhciBjcmVhdGVkRG9jdW1lbnQgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHVuc2FmZUh0bWwsICd0ZXh0L2h0bWwnKTtcbiAgdmFyIHdoaXRlbGlzdEtleXMgPSBPYmplY3Qua2V5cyh3aGl0ZUxpc3QpO1xuICB2YXIgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGNyZWF0ZWREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuICAgIHZhciBlbE5hbWUgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh3aGl0ZWxpc3RLZXlzLmluZGV4T2YoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIHJldHVybiAxOyAvLyBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgYXR0cmlidXRlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZWwuYXR0cmlidXRlcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLXNwcmVhZFxuICAgIHZhciB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQod2hpdGVMaXN0WycqJ10gfHwgW10sIHdoaXRlTGlzdFtlbE5hbWVdIHx8IFtdKTtcbiAgICBhdHRyaWJ1dGVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyLCB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKF9sb29wKCkpIGNvbnRpbnVlO1xuICB9XG4gIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUw7XG59IiwiZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4yKTogdG9vbHRpcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7IERlZmF1bHRXaGl0ZWxpc3QsIHNhbml0aXplSHRtbCB9IGZyb20gJy4vdG9vbHMvc2FuaXRpemVyJztcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgUG9wcGVyIGZyb20gJ3BvcHBlci5qcyc7XG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBOQU1FID0gJ3Rvb2x0aXAnO1xudmFyIFZFUlNJT04gPSAnNC42LjInO1xudmFyIERBVEFfS0VZID0gJ2JzLnRvb2x0aXAnO1xudmFyIEVWRU5UX0tFWSA9IFwiLlwiLmNvbmNhdChEQVRBX0tFWSk7XG52YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcbnZhciBDTEFTU19QUkVGSVggPSAnYnMtdG9vbHRpcCc7XG52YXIgQlNDTFNfUFJFRklYX1JFR0VYID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiLmNvbmNhdChDTEFTU19QUkVGSVgsIFwiXFxcXFMrXCIpLCAnZycpO1xudmFyIERJU0FMTE9XRURfQVRUUklCVVRFUyA9IFsnc2FuaXRpemUnLCAnd2hpdGVMaXN0JywgJ3Nhbml0aXplRm4nXTtcbnZhciBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG52YXIgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xudmFyIEhPVkVSX1NUQVRFX1NIT1cgPSAnc2hvdyc7XG52YXIgSE9WRVJfU1RBVEVfT1VUID0gJ291dCc7XG52YXIgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcic7XG52YXIgU0VMRUNUT1JfQVJST1cgPSAnLmFycm93JztcbnZhciBUUklHR0VSX0hPVkVSID0gJ2hvdmVyJztcbnZhciBUUklHR0VSX0ZPQ1VTID0gJ2ZvY3VzJztcbnZhciBUUklHR0VSX0NMSUNLID0gJ2NsaWNrJztcbnZhciBUUklHR0VSX01BTlVBTCA9ICdtYW51YWwnO1xudmFyIEF0dGFjaG1lbnRNYXAgPSB7XG4gIEFVVE86ICdhdXRvJyxcbiAgVE9QOiAndG9wJyxcbiAgUklHSFQ6ICdyaWdodCcsXG4gIEJPVFRPTTogJ2JvdHRvbScsXG4gIExFRlQ6ICdsZWZ0J1xufTtcbnZhciBEZWZhdWx0ID0ge1xuICBhbmltYXRpb246IHRydWUsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsXG4gIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gIHRpdGxlOiAnJyxcbiAgZGVsYXk6IDAsXG4gIGh0bWw6IGZhbHNlLFxuICBzZWxlY3RvcjogZmFsc2UsXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIG9mZnNldDogMCxcbiAgY29udGFpbmVyOiBmYWxzZSxcbiAgZmFsbGJhY2tQbGFjZW1lbnQ6ICdmbGlwJyxcbiAgYm91bmRhcnk6ICdzY3JvbGxQYXJlbnQnLFxuICBjdXN0b21DbGFzczogJycsXG4gIHNhbml0aXplOiB0cnVlLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICB3aGl0ZUxpc3Q6IERlZmF1bHRXaGl0ZWxpc3QsXG4gIHBvcHBlckNvbmZpZzogbnVsbFxufTtcbnZhciBEZWZhdWx0VHlwZSA9IHtcbiAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gIHRlbXBsYXRlOiAnc3RyaW5nJyxcbiAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcbiAgdHJpZ2dlcjogJ3N0cmluZycsXG4gIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcbiAgaHRtbDogJ2Jvb2xlYW4nLFxuICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIG9mZnNldDogJyhudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gIGZhbGxiYWNrUGxhY2VtZW50OiAnKHN0cmluZ3xhcnJheSknLFxuICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICBjdXN0b21DbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXG4gIHdoaXRlTGlzdDogJ29iamVjdCcsXG4gIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdCknXG59O1xudmFyIEV2ZW50ID0ge1xuICBISURFOiBcImhpZGVcIi5jb25jYXQoRVZFTlRfS0VZKSxcbiAgSElEREVOOiBcImhpZGRlblwiLmNvbmNhdChFVkVOVF9LRVkpLFxuICBTSE9XOiBcInNob3dcIi5jb25jYXQoRVZFTlRfS0VZKSxcbiAgU0hPV046IFwic2hvd25cIi5jb25jYXQoRVZFTlRfS0VZKSxcbiAgSU5TRVJURUQ6IFwiaW5zZXJ0ZWRcIi5jb25jYXQoRVZFTlRfS0VZKSxcbiAgQ0xJQ0s6IFwiY2xpY2tcIi5jb25jYXQoRVZFTlRfS0VZKSxcbiAgRk9DVVNJTjogXCJmb2N1c2luXCIuY29uY2F0KEVWRU5UX0tFWSksXG4gIEZPQ1VTT1VUOiBcImZvY3Vzb3V0XCIuY29uY2F0KEVWRU5UX0tFWSksXG4gIE1PVVNFRU5URVI6IFwibW91c2VlbnRlclwiLmNvbmNhdChFVkVOVF9LRVkpLFxuICBNT1VTRUxFQVZFOiBcIm1vdXNlbGVhdmVcIi5jb25jYXQoRVZFTlRfS0VZKVxufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cbnZhciBUb29sdGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9vbHRpcChlbGVtZW50LCBjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG4gICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5fdGltZW91dCA9IDA7XG4gICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuXG4gICAgLy8gUHJvdGVjdGVkXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMudGlwID0gbnVsbDtcbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xuICAgIGtleTogXCJlbmFibGVcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBQdWJsaWNcbiAgICBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlRW5hYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVFbmFibGVkKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShldmVudCkge1xuICAgICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIHZhciBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihldmVudC5jdXJyZW50VGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuICAgICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgICAgY29udGV4dC5fZW50ZXIobnVsbCwgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5fbGVhdmUobnVsbCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VudGVyKG51bGwsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcbiAgICAgICQodGhpcy5lbGVtZW50KS5vZmYodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLmNsb3Nlc3QoJy5tb2RhbCcpLm9mZignaGlkZS5icy5tb2RhbCcsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuICAgICAgaWYgKHRoaXMudGlwKSB7XG4gICAgICAgICQodGhpcy50aXApLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNFbmFibGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy50aXAgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKCQodGhpcy5lbGVtZW50KS5jc3MoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKTtcbiAgICAgIH1cbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPVyk7XG4gICAgICBpZiAodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudCk7XG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gVXRpbC5maW5kU2hhZG93Um9vdCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB2YXIgaXNJblRoZURvbSA9ICQuY29udGFpbnMoc2hhZG93Um9vdCAhPT0gbnVsbCA/IHNoYWRvd1Jvb3QgOiB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgIWlzSW5UaGVEb20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgICB2YXIgdGlwSWQgPSBVdGlsLmdldFVJRCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO1xuICAgICAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcElkKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZW50KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgICAkKHRpcCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuY29uZmlnLnBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5lbGVtZW50KSA6IHRoaXMuY29uZmlnLnBsYWNlbWVudDtcbiAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGlzLl9nZXRBdHRhY2htZW50KHBsYWNlbWVudCk7XG4gICAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICQodGlwKS5kYXRhKHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpO1xuICAgICAgICBpZiAoISQuY29udGFpbnModGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLnRpcCkpIHtcbiAgICAgICAgICAkKHRpcCkuYXBwZW5kVG8oY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKTtcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbmV3IFBvcHBlcih0aGlzLmVsZW1lbnQsIHRpcCwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpKTtcbiAgICAgICAgJCh0aXApLmFkZENsYXNzKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICAgICQodGlwKS5hZGRDbGFzcyh0aGlzLmNvbmZpZy5jdXN0b21DbGFzcyk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vbignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgX3RoaXMuX2ZpeFRyYW5zaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByZXZIb3ZlclN0YXRlID0gX3RoaXMuX2hvdmVyU3RhdGU7XG4gICAgICAgICAgX3RoaXMuX2hvdmVyU3RhdGUgPSBudWxsO1xuICAgICAgICAgICQoX3RoaXMuZWxlbWVudCkudHJpZ2dlcihfdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTik7XG4gICAgICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9PVVQpIHtcbiAgICAgICAgICAgIF90aGlzLl9sZWF2ZShudWxsLCBfdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKSkge1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMudGlwKTtcbiAgICAgICAgICAkKHRoaXMudGlwKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKTtcbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBpZiAoX3RoaXMyLl9ob3ZlclN0YXRlICE9PSBIT1ZFUl9TVEFURV9TSE9XICYmIHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlwKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczIuX2NsZWFuVGlwQ2xhc3MoKTtcbiAgICAgICAgX3RoaXMyLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICAgICQoX3RoaXMyLmVsZW1lbnQpLnRyaWdnZXIoX3RoaXMyLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTik7XG4gICAgICAgIGlmIChfdGhpczIuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMi5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcbiAgICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgJCh0aXApLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVyk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub2ZmKCdtb3VzZW92ZXInLCBudWxsLCAkLm5vb3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0ZPQ1VTXSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0hPVkVSXSA9IGZhbHNlO1xuICAgICAgaWYgKCQodGhpcy50aXApLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGlwKTtcbiAgICAgICAgJCh0aXApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3RlY3RlZFxuICB9LCB7XG4gICAga2V5OiBcImlzV2l0aENvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNXaXRoQ29udGVudCgpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0VGl0bGUoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEF0dGFjaG1lbnRDbGFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xuICAgICAgJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoXCJcIi5jb25jYXQoQ0xBU1NfUFJFRklYLCBcIi1cIikuY29uY2F0KGF0dGFjaG1lbnQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGlwRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXBFbGVtZW50KCkge1xuICAgICAgdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZW50KCkge1xuICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkKHRpcC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIpKSwgdGhpcy5nZXRUaXRsZSgpKTtcbiAgICAgICQodGlwKS5yZW1vdmVDbGFzcyhcIlwiLmNvbmNhdChDTEFTU19OQU1FX0ZBREUsIFwiIFwiKS5jb25jYXQoQ0xBU1NfTkFNRV9TSE9XKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEVsZW1lbnRDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEVsZW1lbnRDb250ZW50KCRlbGVtZW50LCBjb250ZW50KSB7XG4gICAgICBpZiAoX3R5cGVvZihjb250ZW50KSA9PT0gJ29iamVjdCcgJiYgKGNvbnRlbnQubm9kZVR5cGUgfHwgY29udGVudC5qcXVlcnkpKSB7XG4gICAgICAgIC8vIENvbnRlbnQgaXMgYSBET00gbm9kZSBvciBhIGpRdWVyeVxuICAgICAgICBpZiAodGhpcy5jb25maWcuaHRtbCkge1xuICAgICAgICAgIGlmICghJChjb250ZW50KS5wYXJlbnQoKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAgICRlbGVtZW50LmVtcHR5KCkuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWxlbWVudC50ZXh0KCQoY29udGVudCkudGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25maWcuaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuc2FuaXRpemUpIHtcbiAgICAgICAgICBjb250ZW50ID0gc2FuaXRpemVIdG1sKGNvbnRlbnQsIHRoaXMuY29uZmlnLndoaXRlTGlzdCwgdGhpcy5jb25maWcuc2FuaXRpemVGbik7XG4gICAgICAgIH1cbiAgICAgICAgJGVsZW1lbnQuaHRtbChjb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRlbGVtZW50LnRleHQoY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpdGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpdGxlKCkge1xuICAgICAgdmFyIHRpdGxlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICB0aXRsZSA9IHR5cGVvZiB0aGlzLmNvbmZpZy50aXRsZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLnRpdGxlLmNhbGwodGhpcy5lbGVtZW50KSA6IHRoaXMuY29uZmlnLnRpdGxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgfSwge1xuICAgIGtleTogXCJfZ2V0UG9wcGVyQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgZGVmYXVsdEJzQ29uZmlnID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IGF0dGFjaG1lbnQsXG4gICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KCksXG4gICAgICAgICAgZmxpcDoge1xuICAgICAgICAgICAgYmVoYXZpb3I6IHRoaXMuY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcnJvdzoge1xuICAgICAgICAgICAgZWxlbWVudDogU0VMRUNUT1JfQVJST1dcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgICAgYm91bmRhcmllc0VsZW1lbnQ6IHRoaXMuY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhLm9yaWdpbmFsUGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgX3RoaXMzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRCc0NvbmZpZyksIHRoaXMuY29uZmlnLnBvcHBlckNvbmZpZyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE9mZnNldCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIG9mZnNldCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2Zmc2V0LmZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkYXRhLm9mZnNldHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRhdGEub2Zmc2V0cyksIF90aGlzNC5jb25maWcub2Zmc2V0KGRhdGEub2Zmc2V0cywgX3RoaXM0LmVsZW1lbnQpKTtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldC5vZmZzZXQgPSB0aGlzLmNvbmZpZy5vZmZzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q29udGFpbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb250YWluZXIoKSB7XG4gICAgICBpZiAodGhpcy5jb25maWcuY29udGFpbmVyID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICAgIH1cbiAgICAgIGlmIChVdGlsLmlzRWxlbWVudCh0aGlzLmNvbmZpZy5jb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMuY29uZmlnLmNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gJChkb2N1bWVudCkuZmluZCh0aGlzLmNvbmZpZy5jb250YWluZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QXR0YWNobWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLmNvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XG4gICAgICB0cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgJChfdGhpczUuZWxlbWVudCkub24oX3RoaXM1LmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLCBfdGhpczUuY29uZmlnLnNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczUudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICAgIHZhciBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IF90aGlzNS5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSIDogX3RoaXM1LmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTSU47XG4gICAgICAgICAgdmFyIGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IF90aGlzNS5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogX3RoaXM1LmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO1xuICAgICAgICAgICQoX3RoaXM1LmVsZW1lbnQpLm9uKGV2ZW50SW4sIF90aGlzNS5jb25maWcuc2VsZWN0b3IsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5fZW50ZXIoZXZlbnQpO1xuICAgICAgICAgIH0pLm9uKGV2ZW50T3V0LCBfdGhpczUuY29uZmlnLnNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczUuX2xlYXZlKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXM1LmVsZW1lbnQpIHtcbiAgICAgICAgICBfdGhpczUuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLmNsb3Nlc3QoJy5tb2RhbCcpLm9uKCdoaWRlLmJzLm1vZGFsJywgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XG4gICAgICBpZiAodGhpcy5jb25maWcuc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29uZmlnKSwge30sIHtcbiAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICBzZWxlY3RvcjogJydcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maXhUaXRsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZml4VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeFRpdGxlKCkge1xuICAgICAgdmFyIHRpdGxlVHlwZSA9IF90eXBlb2YodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpKTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IHRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgJycpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnRlcihldmVudCwgY29udGV4dCkge1xuICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpO1xuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihldmVudC5jdXJyZW50VGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgkKGNvbnRleHQuZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpIHx8IGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX1NIT1cpIHtcbiAgICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KTtcbiAgICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIT1ZFUl9TVEFURV9TSE9XO1xuICAgICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgICBjb250ZXh0LnNob3coKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgICAgIGNvbnRleHQuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5zaG93KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2xlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sZWF2ZShldmVudCwgY29udGV4dCkge1xuICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpO1xuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihldmVudC5jdXJyZW50VGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dCk7XG4gICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSE9WRVJfU1RBVEVfT1VUO1xuICAgICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSkge1xuICAgICAgICBjb250ZXh0LmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfT1VUKSB7XG4gICAgICAgICAgY29udGV4dC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNXaXRoQWN0aXZlVHJpZ2dlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICAgIGZvciAodmFyIHRyaWdnZXIgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcikge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVHJpZ2dlclt0cmlnZ2VyXSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIHZhciBkYXRhQXR0cmlidXRlcyA9ICQodGhpcy5lbGVtZW50KS5kYXRhKCk7XG4gICAgICBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUF0dHIpIHtcbiAgICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5pbmRleE9mKGRhdGFBdHRyKSAhPT0gLTEpIHtcbiAgICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQpLCBkYXRhQXR0cmlidXRlcyksIF90eXBlb2YoY29uZmlnKSA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgICBzaG93OiBjb25maWcuZGVsYXksXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpO1xuICAgICAgaWYgKGNvbmZpZy5zYW5pdGl6ZSkge1xuICAgICAgICBjb25maWcudGVtcGxhdGUgPSBzYW5pdGl6ZUh0bWwoY29uZmlnLnRlbXBsYXRlLCBjb25maWcud2hpdGVMaXN0LCBjb25maWcuc2FuaXRpemVGbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGVsZWdhdGVDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgICAgaWYgKHRoaXMuY29uZmlnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbmZpZykge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRba2V5XSAhPT0gdGhpcy5jb25maWdba2V5XSkge1xuICAgICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLmNvbmZpZ1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFuVGlwQ2xhc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgICB2YXIgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpO1xuICAgICAgdmFyIHRhYkNsYXNzID0gJHRpcC5hdHRyKCdjbGFzcycpLm1hdGNoKEJTQ0xTX1BSRUZJWF9SRUdFWCk7XG4gICAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoKSB7XG4gICAgICAgICR0aXAucmVtb3ZlQ2xhc3ModGFiQ2xhc3Muam9pbignJykpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UocG9wcGVyRGF0YSkge1xuICAgICAgdGhpcy50aXAgPSBwb3BwZXJEYXRhLmluc3RhbmNlLnBvcHBlcjtcbiAgICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKTtcbiAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQocG9wcGVyRGF0YS5wbGFjZW1lbnQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpeFRyYW5zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeFRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XG4gICAgICB2YXIgaW5pdENvbmZpZ0FuaW1hdGlvbiA9IHRoaXMuY29uZmlnLmFuaW1hdGlvbjtcbiAgICAgIGlmICh0aXAuZ2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcpICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgICQodGlwKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0ZBREUpO1xuICAgICAgdGhpcy5jb25maWcuYW5pbWF0aW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgdGhpcy5jb25maWcuYW5pbWF0aW9uID0gaW5pdENvbmZpZ0FuaW1hdGlvbjtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgfV0sIFt7XG4gICAga2V5OiBcIlZFUlNJT05cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiTkFNRVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIE5BTUU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkRBVEFfS0VZXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFUQV9LRVk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkV2ZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gRXZlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkVWRU5UX0tFWVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEVWRU5UX0tFWTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiRGVmYXVsdFR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2pRdWVyeUludGVyZmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyk7XG4gICAgICAgIHZhciBkYXRhID0gJGVsZW1lbnQuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gX3R5cGVvZihjb25maWcpID09PSAnb2JqZWN0JyAmJiBjb25maWc7XG4gICAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIuY29uY2F0KGNvbmZpZywgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyoqXG4gKiBqUXVlcnlcbiAqL1xuJC5mbltOQU1FXSA9IFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZTtcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBUb29sdGlwO1xuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICByZXR1cm4gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlO1xufTtcbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXA7IiwiZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMik6IHBvcG92ZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IFRvb2x0aXAgZnJvbSAnLi90b29sdGlwJztcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTkFNRSA9ICdwb3BvdmVyJztcbnZhciBWRVJTSU9OID0gJzQuNi4yJztcbnZhciBEQVRBX0tFWSA9ICdicy5wb3BvdmVyJztcbnZhciBFVkVOVF9LRVkgPSBcIi5cIi5jb25jYXQoREFUQV9LRVkpO1xudmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG52YXIgQ0xBU1NfUFJFRklYID0gJ2JzLXBvcG92ZXInO1xudmFyIEJTQ0xTX1BSRUZJWF9SRUdFWCA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIi5jb25jYXQoQ0xBU1NfUFJFRklYLCBcIlxcXFxTK1wiKSwgJ2cnKTtcbnZhciBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG52YXIgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xudmFyIFNFTEVDVE9SX1RJVExFID0gJy5wb3BvdmVyLWhlYWRlcic7XG52YXIgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5JztcbnZhciBEZWZhdWx0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBUb29sdGlwLkRlZmF1bHQpLCB7fSwge1xuICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gIHRyaWdnZXI6ICdjbGljaycsXG4gIGNvbnRlbnQ6ICcnLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicgKyAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PjwvZGl2Pidcbn0pO1xudmFyIERlZmF1bHRUeXBlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBUb29sdGlwLkRlZmF1bHRUeXBlKSwge30sIHtcbiAgY29udGVudDogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG59KTtcbnZhciBFdmVudCA9IHtcbiAgSElERTogXCJoaWRlXCIuY29uY2F0KEVWRU5UX0tFWSksXG4gIEhJRERFTjogXCJoaWRkZW5cIi5jb25jYXQoRVZFTlRfS0VZKSxcbiAgU0hPVzogXCJzaG93XCIuY29uY2F0KEVWRU5UX0tFWSksXG4gIFNIT1dOOiBcInNob3duXCIuY29uY2F0KEVWRU5UX0tFWSksXG4gIElOU0VSVEVEOiBcImluc2VydGVkXCIuY29uY2F0KEVWRU5UX0tFWSksXG4gIENMSUNLOiBcImNsaWNrXCIuY29uY2F0KEVWRU5UX0tFWSksXG4gIEZPQ1VTSU46IFwiZm9jdXNpblwiLmNvbmNhdChFVkVOVF9LRVkpLFxuICBGT0NVU09VVDogXCJmb2N1c291dFwiLmNvbmNhdChFVkVOVF9LRVkpLFxuICBNT1VTRUVOVEVSOiBcIm1vdXNlZW50ZXJcIi5jb25jYXQoRVZFTlRfS0VZKSxcbiAgTU9VU0VMRUFWRTogXCJtb3VzZWxlYXZlXCIuY29uY2F0KEVWRU5UX0tFWSlcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG52YXIgUG9wb3ZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Rvb2x0aXApIHtcbiAgZnVuY3Rpb24gUG9wb3ZlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wb3Zlcik7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgUG9wb3ZlciwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoUG9wb3ZlciwgX1Rvb2x0aXApO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFBvcG92ZXIsIFt7XG4gICAga2V5OiBcImlzV2l0aENvbnRlbnRcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBPdmVycmlkZXNcbiAgICBmdW5jdGlvbiBpc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEF0dGFjaG1lbnRDbGFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xuICAgICAgJCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoXCJcIi5jb25jYXQoQ0xBU1NfUFJFRklYLCBcIi1cIikuY29uY2F0KGF0dGFjaG1lbnQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGlwRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXBFbGVtZW50KCkge1xuICAgICAgdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZW50KCkge1xuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcblxuICAgICAgLy8gV2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkdGlwLmZpbmQoU0VMRUNUT1JfVElUTEUpLCB0aGlzLmdldFRpdGxlKCkpO1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9nZXRDb250ZW50KCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuY2FsbCh0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkdGlwLmZpbmQoU0VMRUNUT1JfQ09OVEVOVCksIGNvbnRlbnQpO1xuICAgICAgJHRpcC5yZW1vdmVDbGFzcyhcIlwiLmNvbmNhdChDTEFTU19OQU1FX0ZBREUsIFwiIFwiKS5jb25jYXQoQ0xBU1NfTkFNRV9TSE9XKSk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29udGVudCcpIHx8IHRoaXMuY29uZmlnLmNvbnRlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblRpcENsYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhblRpcENsYXNzKCkge1xuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcbiAgICAgIHZhciB0YWJDbGFzcyA9ICR0aXAuYXR0cignY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgpO1xuICAgICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHRpcC5yZW1vdmVDbGFzcyh0YWJDbGFzcy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gIH1dLCBbe1xuICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgZ2V0OlxuICAgIC8vIEdldHRlcnNcbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiRGVmYXVsdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIk5BTUVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBOQU1FO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJEQVRBX0tFWVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEFfS0VZO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJFdmVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEV2ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJFVkVOVF9LRVlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBFVkVOVF9LRVk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkRlZmF1bHRUeXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9qUXVlcnlJbnRlcmZhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gX3R5cGVvZihjb25maWcpID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGw7XG4gICAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gbWV0aG9kIG5hbWVkIFxcXCJcIi5jb25jYXQoY29uZmlnLCBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG59KFRvb2x0aXApO1xuLyoqXG4gKiBqUXVlcnlcbiAqL1xuJC5mbltOQU1FXSA9IFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZTtcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBQb3BvdmVyO1xuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICByZXR1cm4gUG9wb3Zlci5falF1ZXJ5SW50ZXJmYWNlO1xufTtcbmV4cG9ydCBkZWZhdWx0IFBvcG92ZXI7IiwiZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4yKTogdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE5BTUUgPSAndGFiJztcbnZhciBWRVJTSU9OID0gJzQuNi4yJztcbnZhciBEQVRBX0tFWSA9ICdicy50YWInO1xudmFyIEVWRU5UX0tFWSA9IFwiLlwiLmNvbmNhdChEQVRBX0tFWSk7XG52YXIgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG52YXIgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXTtcbnZhciBDTEFTU19OQU1FX0RST1BET1dOX01FTlUgPSAnZHJvcGRvd24tbWVudSc7XG52YXIgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJztcbnZhciBDTEFTU19OQU1FX0RJU0FCTEVEID0gJ2Rpc2FibGVkJztcbnZhciBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG52YXIgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xudmFyIEVWRU5UX0hJREUgPSBcImhpZGVcIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9ISURERU4gPSBcImhpZGRlblwiLmNvbmNhdChFVkVOVF9LRVkpO1xudmFyIEVWRU5UX1NIT1cgPSBcInNob3dcIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9TSE9XTiA9IFwic2hvd25cIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9DTElDS19EQVRBX0FQSSA9IFwiY2xpY2tcIi5jb25jYXQoRVZFTlRfS0VZKS5jb25jYXQoREFUQV9BUElfS0VZKTtcbnZhciBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nO1xudmFyIFNFTEVDVE9SX05BVl9MSVNUX0dST1VQID0gJy5uYXYsIC5saXN0LWdyb3VwJztcbnZhciBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSc7XG52YXIgU0VMRUNUT1JfQUNUSVZFX1VMID0gJz4gbGkgPiAuYWN0aXZlJztcbnZhciBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLXRvZ2dsZT1cImxpc3RcIl0nO1xudmFyIFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcbnZhciBTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQgPSAnPiAuZHJvcGRvd24tbWVudSAuYWN0aXZlJztcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cbnZhciBUYWIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUYWIoZWxlbWVudCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWIpO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFRhYiwgW3tcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOlxuICAgIC8vIFB1YmxpY1xuICAgIGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpIHx8ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9ESVNBQkxFRCkgfHwgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldDtcbiAgICAgIHZhciBwcmV2aW91cztcbiAgICAgIHZhciBsaXN0RWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdChTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUClbMF07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICBpZiAobGlzdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGl0ZW1TZWxlY3RvciA9IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnVUwnIHx8IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnT0wnID8gU0VMRUNUT1JfQUNUSVZFX1VMIDogU0VMRUNUT1JfQUNUSVZFO1xuICAgICAgICBwcmV2aW91cyA9ICQubWFrZUFycmF5KCQobGlzdEVsZW1lbnQpLmZpbmQoaXRlbVNlbGVjdG9yKSk7XG4gICAgICAgIHByZXZpb3VzID0gcHJldmlvdXNbcHJldmlvdXMubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudChFVkVOVF9ISURFLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pO1xuICAgICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoRVZFTlRfU0hPVywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgICAgfSk7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgJChwcmV2aW91cykudHJpZ2dlcihoaWRlRXZlbnQpO1xuICAgICAgfVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudCk7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmF0ZSh0aGlzLl9lbGVtZW50LCBsaXN0RWxlbWVudCk7XG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgdmFyIGhpZGRlbkV2ZW50ID0gJC5FdmVudChFVkVOVF9ISURERU4sIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBfdGhpcy5fZWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNob3duRXZlbnQgPSAkLkV2ZW50KEVWRU5UX1NIT1dOLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICAgICAgfSk7XG4gICAgICAgICQocHJldmlvdXMpLnRyaWdnZXIoaGlkZGVuRXZlbnQpO1xuICAgICAgICAkKF90aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpO1xuICAgICAgfTtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0LCB0YXJnZXQucGFyZW50Tm9kZSwgY29tcGxldGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgfSwge1xuICAgIGtleTogXCJfYWN0aXZhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FjdGl2YXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGFjdGl2ZUVsZW1lbnRzID0gY29udGFpbmVyICYmIChjb250YWluZXIubm9kZU5hbWUgPT09ICdVTCcgfHwgY29udGFpbmVyLm5vZGVOYW1lID09PSAnT0wnKSA/ICQoY29udGFpbmVyKS5maW5kKFNFTEVDVE9SX0FDVElWRV9VTCkgOiAkKGNvbnRhaW5lcikuY2hpbGRyZW4oU0VMRUNUT1JfQUNUSVZFKTtcbiAgICAgIHZhciBhY3RpdmUgPSBhY3RpdmVFbGVtZW50c1swXTtcbiAgICAgIHZhciBpc1RyYW5zaXRpb25pbmcgPSBjYWxsYmFjayAmJiBhY3RpdmUgJiYgJChhY3RpdmUpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSk7XG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5fdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgY2FsbGJhY2spO1xuICAgICAgfTtcbiAgICAgIGlmIChhY3RpdmUgJiYgaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGFjdGl2ZSk7XG4gICAgICAgICQoYWN0aXZlKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX1NIT1cpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90cmFuc2l0aW9uQ29tcGxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zaXRpb25Db21wbGV0ZShlbGVtZW50LCBhY3RpdmUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICQoYWN0aXZlKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICAgIHZhciBkcm9wZG93bkNoaWxkID0gJChhY3RpdmUucGFyZW50Tm9kZSkuZmluZChTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQpWzBdO1xuICAgICAgICBpZiAoZHJvcGRvd25DaGlsZCkge1xuICAgICAgICAgICQoZHJvcGRvd25DaGlsZCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICAgICAgYWN0aXZlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJChlbGVtZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIFV0aWwucmVmbG93KGVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUgPT09ICdMSScpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICYmICQocGFyZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0RST1BET1dOX01FTlUpKSB7XG4gICAgICAgIHZhciBkcm9wZG93bkVsZW1lbnQgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoU0VMRUNUT1JfRFJPUERPV04pWzBdO1xuICAgICAgICBpZiAoZHJvcGRvd25FbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGRyb3Bkb3duVG9nZ2xlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZHJvcGRvd25FbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFKSk7XG4gICAgICAgICAgJChkcm9wZG93blRvZ2dsZUxpc3QpLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gIH1dLCBbe1xuICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2pRdWVyeUludGVyZmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgIHZhciBkYXRhID0gJHRoaXMuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgVGFiKHRoaXMpO1xuICAgICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIuY29uY2F0KGNvbmZpZywgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG4kKGRvY3VtZW50KS5vbihFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBUYWIuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICdzaG93Jyk7XG59KTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG4kLmZuW05BTUVdID0gVGFiLl9qUXVlcnlJbnRlcmZhY2U7XG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVGFiO1xuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICByZXR1cm4gVGFiLl9qUXVlcnlJbnRlcmZhY2U7XG59O1xuZXhwb3J0IGRlZmF1bHQgVGFiOyIsImZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMik6IHRvYXN0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE5BTUUgPSAndG9hc3QnO1xudmFyIFZFUlNJT04gPSAnNC42LjInO1xudmFyIERBVEFfS0VZID0gJ2JzLnRvYXN0JztcbnZhciBFVkVOVF9LRVkgPSBcIi5cIi5jb25jYXQoREFUQV9LRVkpO1xudmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV07XG52YXIgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnO1xudmFyIENMQVNTX05BTUVfSElERSA9ICdoaWRlJztcbnZhciBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XG52YXIgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnO1xudmFyIEVWRU5UX0NMSUNLX0RJU01JU1MgPSBcImNsaWNrLmRpc21pc3NcIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9ISURFID0gXCJoaWRlXCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfSElEREVOID0gXCJoaWRkZW5cIi5jb25jYXQoRVZFTlRfS0VZKTtcbnZhciBFVkVOVF9TSE9XID0gXCJzaG93XCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgRVZFTlRfU0hPV04gPSBcInNob3duXCIuY29uY2F0KEVWRU5UX0tFWSk7XG52YXIgU0VMRUNUT1JfREFUQV9ESVNNSVNTID0gJ1tkYXRhLWRpc21pc3M9XCJ0b2FzdFwiXSc7XG52YXIgRGVmYXVsdCA9IHtcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICBhdXRvaGlkZTogdHJ1ZSxcbiAgZGVsYXk6IDUwMFxufTtcbnZhciBEZWZhdWx0VHlwZSA9IHtcbiAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gIGF1dG9oaWRlOiAnYm9vbGVhbicsXG4gIGRlbGF5OiAnbnVtYmVyJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cbnZhciBUb2FzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvYXN0KGVsZW1lbnQsIGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2FzdCk7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVG9hc3QsIFt7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBQdWJsaWNcbiAgICBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KEVWRU5UX1NIT1cpO1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudCk7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSk7XG4gICAgICB9XG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgX3RoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgICAgICBfdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICAgICQoX3RoaXMuX2VsZW1lbnQpLnRyaWdnZXIoRVZFTlRfU0hPV04pO1xuICAgICAgICBpZiAoX3RoaXMuX2NvbmZpZy5hdXRvaGlkZSkge1xuICAgICAgICAgIF90aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgfSwgX3RoaXMuX2NvbmZpZy5kZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9ISURFKTtcbiAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyk7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoRVZFTlRfSElERSk7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcbiAgICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICAgIH1cbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0NMSUNLX0RJU01JU1MpO1xuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIERlZmF1bHQpLCAkKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSksIF90eXBlb2YoY29uZmlnKSA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pO1xuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9DTElDS19ESVNNSVNTLCBTRUxFQ1RPUl9EQVRBX0RJU01JU1MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Nsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIF90aGlzMy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElERSk7XG4gICAgICAgICQoX3RoaXMzLl9lbGVtZW50KS50cmlnZ2VyKEVWRU5UX0hJRERFTik7XG4gICAgICB9O1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyk7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYXJUaW1lb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgfV0sIFt7XG4gICAga2V5OiBcIlZFUlNJT05cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJEZWZhdWx0VHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2pRdWVyeUludGVyZmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyk7XG4gICAgICAgIHZhciBkYXRhID0gJGVsZW1lbnQuZGF0YShEQVRBX0tFWSk7XG4gICAgICAgIHZhciBfY29uZmlnID0gX3R5cGVvZihjb25maWcpID09PSAnb2JqZWN0JyAmJiBjb25maWc7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgVG9hc3QodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJGVsZW1lbnQuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gbWV0aG9kIG5hbWVkIFxcXCJcIi5jb25jYXQoY29uZmlnLCBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyoqXG4gKiBqUXVlcnlcbiAqL1xuJC5mbltOQU1FXSA9IFRvYXN0Ll9qUXVlcnlJbnRlcmZhY2U7XG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVG9hc3Q7XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gIHJldHVybiBUb2FzdC5falF1ZXJ5SW50ZXJmYWNlO1xufTtcbmV4cG9ydCBkZWZhdWx0IFRvYXN0OyIsImZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xudmFyIFNsaWNrU2xpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2xpY2tTbGlkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNsaWNrU2xpZGVyKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNsaWNrU2xpZGVyLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAkKCdbZGF0YS1zbGlja10nKS5ub3QoJy5zbGljay1pbml0aWFsaXplZCcpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyk7XG4gICAgICAgIGlmIChzZWxmLmRhdGEoJ2NvdW50JykgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zbGljayh7XG4gICAgICAgICAgcHJldkFycm93OiBcIjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rIHNsaWNrLXByZXYgc2xpY2stYXJyb3dcXFwiPjxpIGNsYXNzPVxcXCJtYXRlcmlhbC1pY29ucyBsZWZ0XFxcIj4mI3hFMzE0OzwvaT48L2J1dHRvbj5cIixcbiAgICAgICAgICBuZXh0QXJyb3c6IFwiPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmsgc2xpY2stbmV4dCBzbGljay1hcnJvd1xcXCI+PGkgY2xhc3M9XFxcIm1hdGVyaWFsLWljb25zIHJpZ2h0XFxcIj4mI3hFMzE1OzwvaT48L2J1dHRvbj5cIlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuZXhwb3J0IHsgU2xpY2tTbGlkZXIgYXMgZGVmYXVsdCB9OyIsInZhciBfX1dFQlBBQ0tfTkFNRVNQQUNFX09CSkVDVF9fID0gcHJlc3Rhc2hvcDsiLCIvKipcbiAqIDIwMDctMjAxNyBQcmVzdGFTaG9wXG4gKlxuICogTk9USUNFIE9GIExJQ0VOU0VcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIHN1YmplY3QgdG8gdGhlIEFjYWRlbWljIEZyZWUgTGljZW5zZSAzLjAgKEFGTC0zLjApXG4gKiB0aGF0IGlzIGJ1bmRsZWQgd2l0aCB0aGlzIHBhY2thZ2UgaW4gdGhlIGZpbGUgTElDRU5TRS50eHQuXG4gKiBJdCBpcyBhbHNvIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSB3b3JsZC13aWRlLXdlYiBhdCB0aGlzIFVSTDpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQUZMLTMuMFxuICogSWYgeW91IGRpZCBub3QgcmVjZWl2ZSBhIGNvcHkgb2YgdGhlIGxpY2Vuc2UgYW5kIGFyZSB1bmFibGUgdG9cbiAqIG9idGFpbiBpdCB0aHJvdWdoIHRoZSB3b3JsZC13aWRlLXdlYiwgcGxlYXNlIHNlbmQgYW4gZW1haWxcbiAqIHRvIGxpY2Vuc2VAcHJlc3Rhc2hvcC5jb20gc28gd2UgY2FuIHNlbmQgeW91IGEgY29weSBpbW1lZGlhdGVseS5cbiAqXG4gKiBESVNDTEFJTUVSXG4gKlxuICogRG8gbm90IGVkaXQgb3IgYWRkIHRvIHRoaXMgZmlsZSBpZiB5b3Ugd2lzaCB0byB1cGdyYWRlIFByZXN0YVNob3AgdG8gbmV3ZXJcbiAqIHZlcnNpb25zIGluIHRoZSBmdXR1cmUuIElmIHlvdSB3aXNoIHRvIGN1c3RvbWl6ZSBQcmVzdGFTaG9wIGZvciB5b3VyXG4gKiBuZWVkcyBwbGVhc2UgcmVmZXIgdG8gaHR0cDovL3d3dy5wcmVzdGFzaG9wLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAYXV0aG9yICAgIFByZXN0YVNob3AgU0EgPGNvbnRhY3RAcHJlc3Rhc2hvcC5jb20+XG4gKiBAY29weXJpZ2h0IDIwMDctMjAxNyBQcmVzdGFTaG9wIFNBXG4gKiBAbGljZW5zZSAgIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQUZMLTMuMCBBY2FkZW1pYyBGcmVlIExpY2Vuc2UgMy4wIChBRkwtMy4wKVxuICogSW50ZXJuYXRpb25hbCBSZWdpc3RlcmVkIFRyYWRlbWFyayAmIFByb3BlcnR5IG9mIFByZXN0YVNob3AgU0FcbiAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBwcmVzdGFzaG9wIGZyb20gJ3ByZXN0YXNob3AnO1xucHJlc3Rhc2hvcC5yZXNwb25zaXZlID0gcHJlc3Rhc2hvcC5yZXNwb25zaXZlIHx8IHt9O1xucHJlc3Rhc2hvcC5yZXNwb25zaXZlLmN1cnJlbnRfd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbnByZXN0YXNob3AucmVzcG9uc2l2ZS5taW5fd2lkdGggPSA5OTI7XG5wcmVzdGFzaG9wLnJlc3BvbnNpdmUubW9iaWxlID0gcHJlc3Rhc2hvcC5yZXNwb25zaXZlLmN1cnJlbnRfd2lkdGggPCBwcmVzdGFzaG9wLnJlc3BvbnNpdmUubWluX3dpZHRoO1xuZnVuY3Rpb24gc3dhcENoaWxkcmVuKG9iajEsIG9iajIpIHtcbiAgdmFyIHRlbXAgPSBvYmoyLmNoaWxkcmVuKCkuZGV0YWNoKCk7XG4gIG9iajIuZW1wdHkoKS5hcHBlbmQob2JqMS5jaGlsZHJlbigpLmRldGFjaCgpKTtcbiAgb2JqMS5hcHBlbmQodGVtcCk7XG59XG5mdW5jdGlvbiB0b2dnbGVNb2JpbGVTdHlsZXMoKSB7XG4gIGlmIChwcmVzdGFzaG9wLnJlc3BvbnNpdmUubW9iaWxlKSB7XG4gICAgJChcIipbaWRePSdfZGVza3RvcF8nXVwiKS5lYWNoKGZ1bmN0aW9uIChpZHgsIGVsKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gJCgnIycgKyBlbC5pZC5yZXBsYWNlKCdfZGVza3RvcF8nLCAnX21vYmlsZV8nKSk7XG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICBzd2FwQ2hpbGRyZW4oJChlbCksIHRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgJCgnW2RhdGEtY29sbGFwc2UtaGlkZS1tb2JpbGVdJykuY29sbGFwc2UoJ2hpZGUnKTtcbiAgfSBlbHNlIHtcbiAgICAkKFwiKltpZF49J19tb2JpbGVfJ11cIikuZWFjaChmdW5jdGlvbiAoaWR4LCBlbCkge1xuICAgICAgdmFyIHRhcmdldCA9ICQoJyMnICsgZWwuaWQucmVwbGFjZSgnX21vYmlsZV8nLCAnX2Rlc2t0b3BfJykpO1xuICAgICAgaWYgKHRhcmdldC5sZW5ndGgpIHtcbiAgICAgICAgc3dhcENoaWxkcmVuKCQoZWwpLCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgICQoJ1tkYXRhLWNvbGxhcHNlLWhpZGUtbW9iaWxlXScpLm5vdCgnLnNob3cnKS5jb2xsYXBzZSgnc2hvdycpO1xuICAgICQoJ1tkYXRhLW1vZGFsLWhpZGUtbW9iaWxlXS5zaG93JykubW9kYWwoJ2hpZGUnKTtcbiAgfVxuICBwcmVzdGFzaG9wLmVtaXQoJ3Jlc3BvbnNpdmUgdXBkYXRlJywge1xuICAgIG1vYmlsZTogcHJlc3Rhc2hvcC5yZXNwb25zaXZlLm1vYmlsZVxuICB9KTtcbn1cbiQod2luZG93KS5vbigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICB2YXIgX2N3ID0gcHJlc3Rhc2hvcC5yZXNwb25zaXZlLmN1cnJlbnRfd2lkdGg7XG4gIHZhciBfbXcgPSBwcmVzdGFzaG9wLnJlc3BvbnNpdmUubWluX3dpZHRoO1xuICB2YXIgX3cgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgdmFyIF90b2dnbGUgPSBfY3cgPj0gX213ICYmIF93IDwgX213IHx8IF9jdyA8IF9tdyAmJiBfdyA+PSBfbXc7XG4gIHByZXN0YXNob3AucmVzcG9uc2l2ZS5jdXJyZW50X3dpZHRoID0gX3c7XG4gIHByZXN0YXNob3AucmVzcG9uc2l2ZS5tb2JpbGUgPSBwcmVzdGFzaG9wLnJlc3BvbnNpdmUuY3VycmVudF93aWR0aCA8IHByZXN0YXNob3AucmVzcG9uc2l2ZS5taW5fd2lkdGg7XG4gIGlmIChfdG9nZ2xlKSB7XG4gICAgdG9nZ2xlTW9iaWxlU3R5bGVzKCk7XG4gIH1cbn0pO1xuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICBpZiAocHJlc3Rhc2hvcC5yZXNwb25zaXZlLm1vYmlsZSkge1xuICAgIHRvZ2dsZU1vYmlsZVN0eWxlcygpO1xuICB9XG59KTsiLCJ2YXIgX3RoaXMgPSB0aGlzO1xuLyoqXG4gKiAyMDA3LTIwMTcgUHJlc3RhU2hvcFxuICpcbiAqIE5PVElDRSBPRiBMSUNFTlNFXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBzdWJqZWN0IHRvIHRoZSBBY2FkZW1pYyBGcmVlIExpY2Vuc2UgMy4wIChBRkwtMy4wKVxuICogdGhhdCBpcyBidW5kbGVkIHdpdGggdGhpcyBwYWNrYWdlIGluIHRoZSBmaWxlIExJQ0VOU0UudHh0LlxuICogSXQgaXMgYWxzbyBhdmFpbGFibGUgdGhyb3VnaCB0aGUgd29ybGQtd2lkZS13ZWIgYXQgdGhpcyBVUkw6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0FGTC0zLjBcbiAqIElmIHlvdSBkaWQgbm90IHJlY2VpdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIGFuZCBhcmUgdW5hYmxlIHRvXG4gKiBvYnRhaW4gaXQgdGhyb3VnaCB0aGUgd29ybGQtd2lkZS13ZWIsIHBsZWFzZSBzZW5kIGFuIGVtYWlsXG4gKiB0byBsaWNlbnNlQHByZXN0YXNob3AuY29tIHNvIHdlIGNhbiBzZW5kIHlvdSBhIGNvcHkgaW1tZWRpYXRlbHkuXG4gKlxuICogRElTQ0xBSU1FUlxuICpcbiAqIERvIG5vdCBlZGl0IG9yIGFkZCB0byB0aGlzIGZpbGUgaWYgeW91IHdpc2ggdG8gdXBncmFkZSBQcmVzdGFTaG9wIHRvIG5ld2VyXG4gKiB2ZXJzaW9ucyBpbiB0aGUgZnV0dXJlLiBJZiB5b3Ugd2lzaCB0byBjdXN0b21pemUgUHJlc3RhU2hvcCBmb3IgeW91clxuICogbmVlZHMgcGxlYXNlIHJlZmVyIHRvIGh0dHA6Ly93d3cucHJlc3Rhc2hvcC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGF1dGhvciAgICBQcmVzdGFTaG9wIFNBIDxjb250YWN0QHByZXN0YXNob3AuY29tPlxuICogQGNvcHlyaWdodCAyMDA3LTIwMTcgUHJlc3RhU2hvcCBTQVxuICogQGxpY2Vuc2UgICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0FGTC0zLjAgQWNhZGVtaWMgRnJlZSBMaWNlbnNlIDMuMCAoQUZMLTMuMClcbiAqIEludGVybmF0aW9uYWwgUmVnaXN0ZXJlZCBUcmFkZW1hcmsgJiBQcm9wZXJ0eSBvZiBQcmVzdGFTaG9wIFNBXG4gKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgcHJlc3Rhc2hvcCBmcm9tICdwcmVzdGFzaG9wJztcbmZ1bmN0aW9uIHNldFVwQ2hlY2tvdXQoKSB7XG4gICQoJy5qcy10ZXJtcyBhJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdXJsID0gJChldmVudC50YXJnZXQpLmF0dHIoJ2hyZWYnKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICAvLyBUT0RPOiBIYW5kbGUgcmVxdWVzdCBpZiBubyBwcmV0dHkgVVJMXG4gICAgICB1cmwgKz0gXCI/Y29udGVudF9vbmx5PTFcIjtcbiAgICAgICQuZ2V0KHVybCwgZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgJCgnI21vZGFsJykuZmluZCgnLmpzLW1vZGFsLWNvbnRlbnQnKS5odG1sKCQoY29udGVudCkuZmluZCgnLnBhZ2UtY29udGVudC0tY21zJykuY29udGVudHMoKSk7XG4gICAgICB9KS5mYWlsKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgIHByZXN0YXNob3AuZW1pdCgnaGFuZGxlRXJyb3InLCB7XG4gICAgICAgICAgZXZlbnRUeXBlOiAnY2xpY2tUZXJtcycsXG4gICAgICAgICAgcmVzcDogcmVzcFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAkKCcjbW9kYWwnKS5tb2RhbCgnc2hvdycpO1xuICB9KTtcbiAgJCgnLmpzLWdpZnQtY2hlY2tib3gnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAkKCcjZ2lmdCcpLmNvbGxhcHNlKCd0b2dnbGUnKTtcbiAgfSk7XG59XG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gIGlmICgkKCdib2R5I2NoZWNrb3V0JykubGVuZ3RoID09PSAxKSB7XG4gICAgc2V0VXBDaGVja291dCgpO1xuICB9XG4gIHByZXN0YXNob3Aub24oJ3VwZGF0ZWREZWxpdmVyeUZvcm0nLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuZGVsaXZlcnlPcHRpb24gPT09ICd1bmRlZmluZWQnIHx8IDAgPT09IHBhcmFtcy5kZWxpdmVyeU9wdGlvbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSGlkZSBhbGwgY2FycmllciBleHRyYSBjb250ZW50IC4uLlxuICAgICQoXCIuY2Fycmllci1leHRyYS1jb250ZW50XCIpLmhpZGUoKTtcbiAgICAvLyBhbmQgc2hvdyB0aGUgb25lIHJlbGF0ZWQgdG8gdGhlIHNlbGVjdGVkIGNhcnJpZXJcbiAgICBwYXJhbXMuZGVsaXZlcnlPcHRpb24ubmV4dChcIi5jYXJyaWVyLWV4dHJhLWNvbnRlbnRcIikuc2xpZGVEb3duKCk7XG4gIH0pO1xuICBwcmVzdGFzaG9wLm9uKCdjaGFuZ2VkQ2hlY2tvdXRTdGVwJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLmV2ZW50LmN1cnJlbnRUYXJnZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAkKCcuY29sbGFwc2UnLCBwYXJhbXMuZXZlbnQuY3VycmVudFRhcmdldCkubm90KCcuc2hvdycpLm5vdCgnLmNvbGxhcHNlIC5jb2xsYXBzZScpLmNvbGxhcHNlKCdzaG93Jyk7XG4gICAgfVxuICB9KTtcbn0pO1xuJChkb2N1bWVudCkub24oJ2NoYW5nZScsICcuanMtaW5wdXQtZGVsaXZlcnk6Y2hlY2tlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAkKCcuanMtbGFiZWwtZGVsaXZlcnkuc2VsZWN0ZWQnKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgJCgnI2pzLScgKyAkKF90aGlzKS5hdHRyKCdpZCcpKS5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbn0pO1xuJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5qcy1jaGVja291dC1zdGVwLWhlYWRlcicsIGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc3RlcElkZW50aWZpZXIgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2lkZW50aWZpZXInKTtcbiAgJCgnIycgKyBzdGVwSWRlbnRpZmllcikuYWRkQ2xhc3MoJy1jdXJyZW50Jyk7XG4gICQoJyNjb250ZW50LScgKyBzdGVwSWRlbnRpZmllcikuY29sbGFwc2UoJ3Nob3cnKS5zY3JvbGxUb3AoKTtcbn0pOyIsIi8qKlxuICogMjAwNy0yMDE3IFByZXN0YVNob3BcbiAqXG4gKiBOT1RJQ0UgT0YgTElDRU5TRVxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgc3ViamVjdCB0byB0aGUgQWNhZGVtaWMgRnJlZSBMaWNlbnNlIDMuMCAoQUZMLTMuMClcbiAqIHRoYXQgaXMgYnVuZGxlZCB3aXRoIHRoaXMgcGFja2FnZSBpbiB0aGUgZmlsZSBMSUNFTlNFLnR4dC5cbiAqIEl0IGlzIGFsc28gYXZhaWxhYmxlIHRocm91Z2ggdGhlIHdvcmxkLXdpZGUtd2ViIGF0IHRoaXMgVVJMOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9BRkwtMy4wXG4gKiBJZiB5b3UgZGlkIG5vdCByZWNlaXZlIGEgY29weSBvZiB0aGUgbGljZW5zZSBhbmQgYXJlIHVuYWJsZSB0b1xuICogb2J0YWluIGl0IHRocm91Z2ggdGhlIHdvcmxkLXdpZGUtd2ViLCBwbGVhc2Ugc2VuZCBhbiBlbWFpbFxuICogdG8gbGljZW5zZUBwcmVzdGFzaG9wLmNvbSBzbyB3ZSBjYW4gc2VuZCB5b3UgYSBjb3B5IGltbWVkaWF0ZWx5LlxuICpcbiAqIERJU0NMQUlNRVJcbiAqXG4gKiBEbyBub3QgZWRpdCBvciBhZGQgdG8gdGhpcyBmaWxlIGlmIHlvdSB3aXNoIHRvIHVwZ3JhZGUgUHJlc3RhU2hvcCB0byBuZXdlclxuICogdmVyc2lvbnMgaW4gdGhlIGZ1dHVyZS4gSWYgeW91IHdpc2ggdG8gY3VzdG9taXplIFByZXN0YVNob3AgZm9yIHlvdXJcbiAqIG5lZWRzIHBsZWFzZSByZWZlciB0byBodHRwOi8vd3d3LnByZXN0YXNob3AuY29tIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBhdXRob3IgICAgUHJlc3RhU2hvcCBTQSA8Y29udGFjdEBwcmVzdGFzaG9wLmNvbT5cbiAqIEBjb3B5cmlnaHQgMjAwNy0yMDE3IFByZXN0YVNob3AgU0FcbiAqIEBsaWNlbnNlICAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9BRkwtMy4wIEFjYWRlbWljIEZyZWUgTGljZW5zZSAzLjAgKEFGTC0zLjApXG4gKiBJbnRlcm5hdGlvbmFsIFJlZ2lzdGVyZWQgVHJhZGVtYXJrICYgUHJvcGVydHkgb2YgUHJlc3RhU2hvcCBTQVxuICovXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuZnVuY3Rpb24gaW5pdFJtYUl0ZW1TZWxlY3RvcigpIHtcbiAgJCgnI29yZGVyLXJldHVybi1mb3JtIHRhYmxlIHRoZWFkIGlucHV0W3R5cGU9Y2hlY2tib3hdJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGVja2VkID0gJCh0aGlzKS5wcm9wKCdjaGVja2VkJyk7XG4gICAgJCgnI29yZGVyLXJldHVybi1mb3JtIHRhYmxlIHRib2R5IGlucHV0W3R5cGU9Y2hlY2tib3hdJykuZWFjaChmdW5jdGlvbiAoXywgY2hlY2tib3gpIHtcbiAgICAgICQoY2hlY2tib3gpLnByb3AoJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXR1cEN1c3RvbWVyU2NyaXB0cygpIHtcbiAgaWYgKCQoJ2JvZHkjb3JkZXItZGV0YWlsJykpIHtcbiAgICBpbml0Um1hSXRlbVNlbGVjdG9yKCk7XG4gIH1cbn1cbiQoZG9jdW1lbnQpLnJlYWR5KHNldHVwQ3VzdG9tZXJTY3JpcHRzKTsiLCIvKipcbiAqIDIwMDctMjAxNyBQcmVzdGFTaG9wXG4gKlxuICogTk9USUNFIE9GIExJQ0VOU0VcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIHN1YmplY3QgdG8gdGhlIEFjYWRlbWljIEZyZWUgTGljZW5zZSAzLjAgKEFGTC0zLjApXG4gKiB0aGF0IGlzIGJ1bmRsZWQgd2l0aCB0aGlzIHBhY2thZ2UgaW4gdGhlIGZpbGUgTElDRU5TRS50eHQuXG4gKiBJdCBpcyBhbHNvIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSB3b3JsZC13aWRlLXdlYiBhdCB0aGlzIFVSTDpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQUZMLTMuMFxuICogSWYgeW91IGRpZCBub3QgcmVjZWl2ZSBhIGNvcHkgb2YgdGhlIGxpY2Vuc2UgYW5kIGFyZSB1bmFibGUgdG9cbiAqIG9idGFpbiBpdCB0aHJvdWdoIHRoZSB3b3JsZC13aWRlLXdlYiwgcGxlYXNlIHNlbmQgYW4gZW1haWxcbiAqIHRvIGxpY2Vuc2VAcHJlc3Rhc2hvcC5jb20gc28gd2UgY2FuIHNlbmQgeW91IGEgY29weSBpbW1lZGlhdGVseS5cbiAqXG4gKiBESVNDTEFJTUVSXG4gKlxuICogRG8gbm90IGVkaXQgb3IgYWRkIHRvIHRoaXMgZmlsZSBpZiB5b3Ugd2lzaCB0byB1cGdyYWRlIFByZXN0YVNob3AgdG8gbmV3ZXJcbiAqIHZlcnNpb25zIGluIHRoZSBmdXR1cmUuIElmIHlvdSB3aXNoIHRvIGN1c3RvbWl6ZSBQcmVzdGFTaG9wIGZvciB5b3VyXG4gKiBuZWVkcyBwbGVhc2UgcmVmZXIgdG8gaHR0cDovL3d3dy5wcmVzdGFzaG9wLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAYXV0aG9yICAgIFByZXN0YVNob3AgU0EgPGNvbnRhY3RAcHJlc3Rhc2hvcC5jb20+XG4gKiBAY29weXJpZ2h0IDIwMDctMjAxNyBQcmVzdGFTaG9wIFNBXG4gKiBAbGljZW5zZSAgIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQUZMLTMuMCBBY2FkZW1pYyBGcmVlIExpY2Vuc2UgMy4wIChBRkwtMy4wKVxuICogSW50ZXJuYXRpb25hbCBSZWdpc3RlcmVkIFRyYWRlbWFyayAmIFByb3BlcnR5IG9mIFByZXN0YVNob3AgU0FcbiAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBwcmVzdGFzaG9wIGZyb20gJ3ByZXN0YXNob3AnO1xuaW1wb3J0IFNsaWNrU2xpZGVyIGZyb20gXCIuL2NvbXBvbmVudHMvc2xpY2tcIjtcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgcHJlc3Rhc2hvcC5vbignY2xpY2tRdWlja1ZpZXcnLCBmdW5jdGlvbiAoZWxtKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAnYWN0aW9uJzogJ3F1aWNrdmlldycsXG4gICAgICAnaWRfcHJvZHVjdCc6IGVsbS5kYXRhc2V0LmlkUHJvZHVjdCxcbiAgICAgICdpZF9wcm9kdWN0X2F0dHJpYnV0ZSc6IGVsbS5kYXRhc2V0LmlkUHJvZHVjdEF0dHJpYnV0ZVxuICAgIH07XG4gICAgJC5wb3N0KHByZXN0YXNob3AudXJscy5wYWdlcy5wcm9kdWN0LCBkYXRhLCBudWxsLCAnanNvbicpLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICQoJ2JvZHknKS5hcHBlbmQocmVzcC5xdWlja3ZpZXdfaHRtbCk7XG4gICAgICB2YXIgcHJvZHVjdE1vZGFsID0gJChcIiNxdWlja3ZpZXctbW9kYWwtXCIuY29uY2F0KHJlc3AucHJvZHVjdC5pZCwgXCItXCIpLmNvbmNhdChyZXNwLnByb2R1Y3QuaWRfcHJvZHVjdF9hdHRyaWJ1dGUpKTtcbiAgICAgIHByb2R1Y3RNb2RhbC5tb2RhbCgnc2hvdycpO1xuICAgICAgcHJvZHVjdE1vZGFsLm9uKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb2R1Y3RNb2RhbC5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgcHJvZHVjdE1vZGFsLm9uKCdzaG93bi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvZHVjdENvbmZpZyhwcm9kdWN0TW9kYWwpO1xuICAgICAgfSk7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAocmVzcCkge1xuICAgICAgcHJlc3Rhc2hvcC5lbWl0KCdoYW5kbGVFcnJvcicsIHtcbiAgICAgICAgZXZlbnRUeXBlOiAnY2xpY2tRdWlja1ZpZXcnLFxuICAgICAgICByZXNwOiByZXNwXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBwcm9kdWN0Q29uZmlnID0gZnVuY3Rpb24gcHJvZHVjdENvbmZpZyhxdikge1xuICAgIHZhciBzbGlja1NsaWRlciA9IG5ldyBTbGlja1NsaWRlcigpO1xuICAgIHNsaWNrU2xpZGVyLmluaXQoKTtcbiAgICBxdi5maW5kKCcjcXVhbnRpdHlfd2FudGVkJykuVG91Y2hTcGluKHtcbiAgICAgIGJ1dHRvbmRvd25fY2xhc3M6ICdidG4ganMtdG91Y2hzcGluJyxcbiAgICAgIGJ1dHRvbnVwX2NsYXNzOiAnYnRuIGpzLXRvdWNoc3BpbicsXG4gICAgICBtaW46IDEsXG4gICAgICBtYXg6IDEwMDAwMDBcbiAgICB9KTtcbiAgfTtcbiAgdmFyIHBhcnNlU2VhcmNoVXJsID0gZnVuY3Rpb24gcGFyc2VTZWFyY2hVcmwoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmRhdGFzZXQuc2VhcmNoVXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmVudC50YXJnZXQuZGF0YXNldC5zZWFyY2hVcmw7XG4gICAgfVxuICAgIGlmICgkKGV2ZW50LnRhcmdldCkucGFyZW50KClbMF0uZGF0YXNldC5zZWFyY2hVcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHBhcnNlIHNlYXJjaCBVUkwnKTtcbiAgICB9XG4gICAgcmV0dXJuICQoZXZlbnQudGFyZ2V0KS5wYXJlbnQoKVswXS5kYXRhc2V0LnNlYXJjaFVybDtcbiAgfTtcbiAgJCgnYm9keScpLm9uKCdjaGFuZ2UnLCAnI3NlYXJjaF9maWx0ZXJzIGlucHV0W2RhdGEtc2VhcmNoLXVybF0nLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBwcmVzdGFzaG9wLmVtaXQoJ3VwZGF0ZUZhY2V0cycsIHBhcnNlU2VhcmNoVXJsKGV2ZW50KSk7XG4gIH0pO1xuICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5qcy1zZWFyY2gtZmlsdGVycy1jbGVhci1hbGwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBwcmVzdGFzaG9wLmVtaXQoJ3VwZGF0ZUZhY2V0cycsIHBhcnNlU2VhcmNoVXJsKGV2ZW50KSk7XG4gIH0pO1xuICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5qcy1zZWFyY2gtbGluaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcHJlc3Rhc2hvcC5lbWl0KCd1cGRhdGVGYWNldHMnLCAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCgnYScpLmdldCgwKS5ocmVmKTtcbiAgfSk7XG4gICQoJ2JvZHknKS5vbignY2hhbmdlJywgJyNzZWxlY3Qtc29ydC1vcmRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXJsc2VhcmNoID0gJCh0aGlzKS52YWwoKTtcbiAgICBwcmVzdGFzaG9wLmVtaXQoJ3VwZGF0ZUZhY2V0cycsIHVybHNlYXJjaCk7XG4gIH0pO1xuICAkKCdib2R5Jykub24oJ2NoYW5nZScsICcjc2VhcmNoX2ZpbHRlcnMgc2VsZWN0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHVybHNlYXJjaCA9ICQodGhpcykudmFsKCk7XG4gICAgcHJlc3Rhc2hvcC5lbWl0KCd1cGRhdGVGYWNldHMnLCB1cmxzZWFyY2gpO1xuICB9KTtcbiAgcHJlc3Rhc2hvcC5vbigndXBkYXRlUHJvZHVjdExpc3QnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHVwZGF0ZVByb2R1Y3RMaXN0RE9NKGRhdGEpO1xuICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgfSk7XG59KTtcbmZ1bmN0aW9uIHVwZGF0ZVByb2R1Y3RMaXN0RE9NKGRhdGEpIHtcbiAgJCgnI3NlYXJjaF9maWx0ZXJzJykucmVwbGFjZVdpdGgoZGF0YS5yZW5kZXJlZF9mYWNldHMpO1xuICAkKCcjanMtYWN0aXZlLXNlYXJjaC1maWx0ZXJzJykucmVwbGFjZVdpdGgoZGF0YS5yZW5kZXJlZF9hY3RpdmVfZmlsdGVycyk7XG4gICQoJyNqcy1wcm9kdWN0LWxpc3QtdG9wJykucmVwbGFjZVdpdGgoZGF0YS5yZW5kZXJlZF9wcm9kdWN0c190b3ApO1xuICAkKCcjanMtcHJvZHVjdC1saXN0JykucmVwbGFjZVdpdGgoZGF0YS5yZW5kZXJlZF9wcm9kdWN0cyk7XG4gICQoJyNqcy1wcm9kdWN0LWxpc3QtYm90dG9tJykucmVwbGFjZVdpdGgoZGF0YS5yZW5kZXJlZF9wcm9kdWN0c19ib3R0b20pO1xuICBpZiAodHlwZW9mIGRhdGEucmVuZGVyZWRfcHJvZHVjdHNfaGVhZGVyICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhLnJlbmRlcmVkX3Byb2R1Y3RzX2hlYWRlcikge1xuICAgICQoJyNqcy1wcm9kdWN0LWxpc3QtaGVhZGVyJykucmVwbGFjZVdpdGgoZGF0YS5yZW5kZXJlZF9wcm9kdWN0c19oZWFkZXIpO1xuICB9XG59IiwiLyoqXG4gKiAyMDA3LTIwMTcgUHJlc3RhU2hvcFxuICpcbiAqIE5PVElDRSBPRiBMSUNFTlNFXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBzdWJqZWN0IHRvIHRoZSBBY2FkZW1pYyBGcmVlIExpY2Vuc2UgMy4wIChBRkwtMy4wKVxuICogdGhhdCBpcyBidW5kbGVkIHdpdGggdGhpcyBwYWNrYWdlIGluIHRoZSBmaWxlIExJQ0VOU0UudHh0LlxuICogSXQgaXMgYWxzbyBhdmFpbGFibGUgdGhyb3VnaCB0aGUgd29ybGQtd2lkZS13ZWIgYXQgdGhpcyBVUkw6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0FGTC0zLjBcbiAqIElmIHlvdSBkaWQgbm90IHJlY2VpdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIGFuZCBhcmUgdW5hYmxlIHRvXG4gKiBvYnRhaW4gaXQgdGhyb3VnaCB0aGUgd29ybGQtd2lkZS13ZWIsIHBsZWFzZSBzZW5kIGFuIGVtYWlsXG4gKiB0byBsaWNlbnNlQHByZXN0YXNob3AuY29tIHNvIHdlIGNhbiBzZW5kIHlvdSBhIGNvcHkgaW1tZWRpYXRlbHkuXG4gKlxuICogRElTQ0xBSU1FUlxuICpcbiAqIERvIG5vdCBlZGl0IG9yIGFkZCB0byB0aGlzIGZpbGUgaWYgeW91IHdpc2ggdG8gdXBncmFkZSBQcmVzdGFTaG9wIHRvIG5ld2VyXG4gKiB2ZXJzaW9ucyBpbiB0aGUgZnV0dXJlLiBJZiB5b3Ugd2lzaCB0byBjdXN0b21pemUgUHJlc3RhU2hvcCBmb3IgeW91clxuICogbmVlZHMgcGxlYXNlIHJlZmVyIHRvIGh0dHA6Ly93d3cucHJlc3Rhc2hvcC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGF1dGhvciAgICBQcmVzdGFTaG9wIFNBIDxjb250YWN0QHByZXN0YXNob3AuY29tPlxuICogQGNvcHlyaWdodCAyMDA3LTIwMTcgUHJlc3RhU2hvcCBTQVxuICogQGxpY2Vuc2UgICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0FGTC0zLjAgQWNhZGVtaWMgRnJlZSBMaWNlbnNlIDMuMCAoQUZMLTMuMClcbiAqIEludGVybmF0aW9uYWwgUmVnaXN0ZXJlZCBUcmFkZW1hcmsgJiBQcm9wZXJ0eSBvZiBQcmVzdGFTaG9wIFNBXG4gKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgcHJlc3Rhc2hvcCBmcm9tICdwcmVzdGFzaG9wJztcbmltcG9ydCBTbGlja1NsaWRlciBmcm9tICcuL2NvbXBvbmVudHMvc2xpY2snO1xuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLmxvZygncmVhZHkgcHJvZHVjdCcpO1xuICBjcmVhdGVQcm9kdWN0U3BpbigpO1xuICBjcmVhdGVJbnB1dEZpbGUoKTtcbiAgLy9sZXQgc2xpY2tTbGlkZXIgPSBuZXcgU2xpY2tTbGlkZXIoKTtcbiAgc2xpY2tTbGlkZXJQcm9kdWN0SW5pdCgpO1xuICBpZiAocHJlc3Rhc2hvcC5yZXNwb25zaXZlLm1vYmlsZSkge1xuICAgIC8vJChcIi5idG4tem9vbVwiKS5oaWRlKCk7XG4gICAgY29uc29sZS5sb2coJ3pvb20nKTtcbiAgICAvLyQoXCIucHJvZHVjdC1pbWcgaW1nXCIpLnBhcmVudCgpLnpvb20oKTtcbiAgICAkKFwiI3Byb2R1Y3QtbW9kYWwgaW1nXCIpLnBhcmVudCgpLnpvb20oe1xuICAgICAgbWFnbmlmeTogMC44XG4gICAgfSk7XG4gIH1cbiAgcHJlc3Rhc2hvcC5vbigndXBkYXRlZFByb2R1Y3QnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZygndXBkYXRlZFByb2R1Y3QnKTtcbiAgICBjcmVhdGVJbnB1dEZpbGUoKTtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQucHJvZHVjdF9taW5pbWFsX3F1YW50aXR5KSB7XG4gICAgICB2YXIgbWluaW1hbFByb2R1Y3RRdWFudGl0eSA9IHBhcnNlSW50KGV2ZW50LnByb2R1Y3RfbWluaW1hbF9xdWFudGl0eSwgMTApO1xuICAgICAgdmFyIHF1YW50aXR5SW5wdXRTZWxlY3RvciA9ICcjcXVhbnRpdHlfd2FudGVkJztcbiAgICAgIHZhciBxdWFudGl0eUlucHV0ID0gJChxdWFudGl0eUlucHV0U2VsZWN0b3IpO1xuXG4gICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudmlydHVvc29mdC5ldS9jb2RlL2Jvb3RzdHJhcC10b3VjaHNwaW4vIGFib3V0IEJvb3RzdHJhcCBUb3VjaFNwaW5cbiAgICAgIHF1YW50aXR5SW5wdXQudHJpZ2dlcigndG91Y2hzcGluLnVwZGF0ZXNldHRpbmdzJywge1xuICAgICAgICBtaW46IG1pbmltYWxQcm9kdWN0UXVhbnRpdHlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAkKCQoJy50YWJzIC5uYXYtbGluay5hY3RpdmUnKS5hdHRyKCdocmVmJykpLmFkZENsYXNzKCdhY3RpdmUnKS5yZW1vdmVDbGFzcygnZmFkZScpO1xuICAgICQoJy5qcy1wcm9kdWN0LWltYWdlcy1tb2RhbCcpLnJlcGxhY2VXaXRoKGV2ZW50LnByb2R1Y3RfaW1hZ2VzX21vZGFsKTtcbiAgICAvLyBzbGlja1NsaWRlci5pbml0KCk7XG4gICAgc2xpY2tTbGlkZXJQcm9kdWN0SW5pdCgpO1xuICB9KTtcbiAgZnVuY3Rpb24gc2xpY2tTbGlkZXJQcm9kdWN0SW5pdCgpIHtcbiAgICBjb25zb2xlLmxvZygnc2xpY2tTbGlkZXJQcm9kdWN0SW5pdCcpO1xuICAgICQoJy5wcm9kdWN0LXRodW1icycpLnNsaWNrKHtcbiAgICAgIGFzTmF2Rm9yOiAnLnByb2R1Y3RzLWltYWdlc2NvdmVyJyxcbiAgICAgIHByZXZBcnJvdzogJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1saW5rIHNsaWNrLXByZXYgc2xpY2stYXJyb3dcIj48aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+ZXhwYW5kX2xlc3M8L2k+PC9idXR0b24+JyxcbiAgICAgIG5leHRBcnJvdzogJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1saW5rIHNsaWNrLW5leHQgc2xpY2stYXJyb3dcIj48aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+ZXhwYW5kX21vcmU8L2k+PC9idXR0b24+JyxcbiAgICAgIGRvdHM6IGZhbHNlLFxuICAgICAgaW5maW5pdGU6IHRydWUsXG4gICAgICBzcGVlZDogMzAwLFxuICAgICAgcm93czogMCxcbiAgICAgIHNsaWRlc1RvU2hvdzogNixcbiAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgICAgXCJmb2N1c09uU2VsZWN0XCI6IHRydWUsXG4gICAgICB2ZXJ0aWNhbDogdHJ1ZSxcbiAgICAgIHZlcnRpY2FsU3dpcGluZzogdHJ1ZSxcbiAgICAgIHJlc3BvbnNpdmU6IFt7XG4gICAgICAgIGJyZWFrcG9pbnQ6IDEwMjQsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgc2xpZGVzVG9TaG93OiA0LFxuICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAyLFxuICAgICAgICAgIHZlcnRpY2FsOiBmYWxzZSxcbiAgICAgICAgICB2ZXJ0aWNhbFN3aXBpbmc6IGZhbHNlLFxuICAgICAgICAgIHByZXZBcnJvdzogJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1saW5rIHNsaWNrLXByZXYgc2xpY2stYXJyb3dcIj48aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+Y2hldnJvbl9sZWZ0PC9pPjwvYnV0dG9uPicsXG4gICAgICAgICAgbmV4dEFycm93OiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmsgc2xpY2stbmV4dCBzbGljay1hcnJvd1wiPjxpIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5jaGV2cm9uX3JpZ2h0PC9pPjwvYnV0dG9uPidcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBicmVha3BvaW50OiA0ODAsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgc2xpZGVzVG9TaG93OiAzLFxuICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgICAgICAgIHZlcnRpY2FsOiBmYWxzZSxcbiAgICAgICAgICB2ZXJ0aWNhbFN3aXBpbmc6IGZhbHNlLFxuICAgICAgICAgIHByZXZBcnJvdzogJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1saW5rIHNsaWNrLXByZXYgc2xpY2stYXJyb3dcIj48aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+Y2hldnJvbl9sZWZ0PC9pPjwvYnV0dG9uPicsXG4gICAgICAgICAgbmV4dEFycm93OiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmsgc2xpY2stbmV4dCBzbGljay1hcnJvd1wiPjxpIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5jaGV2cm9uX3JpZ2h0PC9pPjwvYnV0dG9uPidcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9KTtcbiAgICAkKCcucHJvZHVjdHMtaW1hZ2VzY292ZXInKS5zbGljayh7XG4gICAgICBhc05hdkZvcjogJy5wcm9kdWN0LXRodW1icycsXG4gICAgICBwcmV2QXJyb3c6ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tbGluayBzbGljay1wcmV2IHNsaWNrLWFycm93XCI+PGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmNoZXZyb25fbGVmdDwvaT48L2J1dHRvbj4nLFxuICAgICAgbmV4dEFycm93OiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmsgc2xpY2stbmV4dCBzbGljay1hcnJvd1wiPjxpIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5jaGV2cm9uX3JpZ2h0PC9pPjwvYnV0dG9uPicsXG4gICAgICBkb3RzOiBmYWxzZSxcbiAgICAgIGluZmluaXRlOiB0cnVlLFxuICAgICAgc3BlZWQ6IDMwMCxcbiAgICAgIHJvd3M6IDAsXG4gICAgICBzbGlkZXNUb1Nob3c6IDEsXG4gICAgICBzbGlkZXNUb1Njcm9sbDogMSxcbiAgICAgIHZlcnRpY2FsOiBmYWxzZSxcbiAgICAgIHZlcnRpY2FsU3dpcGluZzogZmFsc2VcbiAgICB9KTtcbiAgICAkKCcjanMtc2xpY2stcHJvZHVjdCcpLnNsaWNrKHtcbiAgICAgIGFzTmF2Rm9yOiAnLnByb2R1Y3QtdGh1bWJzLCAucHJvZHVjdHMtaW1hZ2VzY292ZXInLFxuICAgICAgcHJldkFycm93OiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmsgc2xpY2stcHJldiBzbGljay1hcnJvdyBkLW5vbmUgZC1tZC1mbGV4XCI+PGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmNoZXZyb25fbGVmdDwvaT48L2J1dHRvbj4nLFxuICAgICAgbmV4dEFycm93OiAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmsgc2xpY2stbmV4dCBzbGljay1hcnJvdyBkLW5vbmUgZC1tZC1mbGV4XCI+PGkgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmNoZXZyb25fcmlnaHQ8L2k+PC9idXR0b24+JyxcbiAgICAgIGRvdHM6IGZhbHNlLFxuICAgICAgaW5maW5pdGU6IHRydWUsXG4gICAgICBzcGVlZDogMzAwLFxuICAgICAgcm93czogMCxcbiAgICAgIHNsaWRlc1RvU2hvdzogMSxcbiAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxuICAgICAgdmVydGljYWw6IGZhbHNlLFxuICAgICAgdmVydGljYWxTd2lwaW5nOiBmYWxzZSxcbiAgICAgIHN3aXBlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgLy8gT24gYmVmb3JlIHNsaWRlIGNoYW5nZVxuICAgIC8qXG4gICAgICQoJyNqcy1zbGljay1wcm9kdWN0Jykub24oJ2JlZm9yZUNoYW5nZScsIGZ1bmN0aW9uIChldmVudCwgc2xpY2ssIGN1cnJlbnRTbGlkZSwgbmV4dFNsaWRlKSB7XG4gICAgIGNvbnNvbGUubG9nKG5leHRTbGlkZSk7XG4gICAgIC8vJCgnLnByb2R1Y3RzLWltYWdlc2NvdmVyJykuc2xpY2soJ3NsaWNrR29UbycsIG5leHRTbGlkZSk7XG4gICAgIC8vJCgnLnByb2R1Y3QtdGh1bWJzJykuc2xpY2soJ3NsaWNrR29UbycsIG5leHRTbGlkZSk7XG4gICAgIFxuICAgICB9KTsqL1xuXG4gICAgJCgnLmJ0bi16b29tJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc29sZS5sb2coJ2J0bi16b29tIGNsaWNrJyk7XG4gICAgICBpZEltYWdlID0gJCh0aGlzKS5kYXRhKCdpZC1pbWFnZScpO1xuICAgICAgbnVtSW1hZ2UgPSAkKHRoaXMpLmRhdGEoJ251bS1pbWFnZScpO1xuICAgICAgbnVtU2xpZGUgPSAkKHRoaXMpLnBhcmVudCgpLmRhdGEoJ3NsaWNrLWluZGV4Jyk7XG4gICAgICAkKCcjanMtc2xpY2stcHJvZHVjdCcpLnNsaWNrKCdzbGlja0dvVG8nLCBudW1TbGlkZSk7XG4gICAgICBjb25zb2xlLmxvZygnbnVtSW1hZ2UgOiAnICsgbnVtSW1hZ2UpO1xuICAgICAgY29uc29sZS5sb2coJ251bVNsaWRlIDogJyArIG51bVNsaWRlKTtcbiAgICAgIC8qICAkKFwiI3Byb2R1Y3QtbW9kYWwgaW1nLmltZy1mbHVpZFwiKS5hZGRDbGFzcygnZC1ub25lJykucmVtb3ZlQ2xhc3MoJ2N1cnJlbnQnKTtcbiAgICAgICAkKFwiI3Byb2R1Y3QtbW9kYWwgaW1nI2ltYWdlLVwiICsgaWRJbWFnZSkucmVtb3ZlQ2xhc3MoJ2Qtbm9uZScpLmFkZENsYXNzKCdjdXJyZW50Jyk7Ki9cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJbnB1dEZpbGUoKSB7XG4gICAgJCgnLmpzLWZpbGUtaW5wdXQnKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0LCBmaWxlO1xuICAgICAgaWYgKCh0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpWzBdKSAmJiAoZmlsZSA9IHRhcmdldC5maWxlc1swXSkpIHtcbiAgICAgICAgJCh0YXJnZXQpLnByZXYoKS50ZXh0KGZpbGUubmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUHJvZHVjdFNwaW4oKSB7XG4gICAgdmFyICRxdWFudGl0eUlucHV0ID0gJCgnI3F1YW50aXR5X3dhbnRlZCcpO1xuICAgICRxdWFudGl0eUlucHV0LlRvdWNoU3Bpbih7XG4gICAgICBidXR0b25kb3duX2NsYXNzOiAnYnRuIGpzLXRvdWNoc3BpbicsXG4gICAgICBidXR0b251cF9jbGFzczogJ2J0biBqcy10b3VjaHNwaW4nLFxuICAgICAgbWluOiBwYXJzZUludCgkcXVhbnRpdHlJbnB1dC5hdHRyKCdtaW4nKSwgMTApLFxuICAgICAgbWF4OiAxMDAwMDAwXG4gICAgfSk7XG4gICAgJCgnYm9keScpLm9uKCdjaGFuZ2Uga2V5dXAnLCAnI3F1YW50aXR5X3dhbnRlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAkKGUuY3VycmVudFRhcmdldCkudHJpZ2dlcigndG91Y2hzcGluLnN0b3BzcGluJyk7XG4gICAgICBwcmVzdGFzaG9wLmVtaXQoJ3VwZGF0ZVByb2R1Y3QnLCB7XG4gICAgICAgIGV2ZW50VHlwZTogJ3VwZGF0ZWRQcm9kdWN0UXVhbnRpdHknLFxuICAgICAgICBldmVudDogZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xudmFyIGlkSW1hZ2UgPSAwO1xudmFyIG51bUltYWdlID0gMDtcbnZhciBudW1TbGlkZSA9IDA7XG4kKGRvY3VtZW50KS5vbignc2hvd24uYnMubW9kYWwnLCAnI3Byb2R1Y3QtbW9kYWwnLCBmdW5jdGlvbiAoZSkge1xuICBjb25zb2xlLmxvZygnc2hvd24gI3Byb2R1Y3QtbW9kYWwnKTtcbiAgY29uc29sZS5sb2coJ251bUltYWdlIDogJyArIG51bUltYWdlKTtcbiAgJCgnI2pzLXNsaWNrLXByb2R1Y3QnKS5yZXNpemUoKTtcbn0pO1xuJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5uZXh0LWltYWdlLW1vZGFsJywgZnVuY3Rpb24gKGUpIHtcbiAgY29uc29sZS5sb2coJ25leHQtaW1hZ2UtbW9kYWwgY2xpY2snKTtcbiAgJCgnI2pzLXNsaWNrLXByb2R1Y3QnKS5zbGljaygnc2xpY2tOZXh0Jyk7XG59KTtcbiQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcucHJldi1pbWFnZS1tb2RhbCcsIGZ1bmN0aW9uIChlKSB7XG4gIGNvbnNvbGUubG9nKCdwcmV2LWltYWdlLW1vZGFsIGNsaWNrJyk7XG4gICQoJyNqcy1zbGljay1wcm9kdWN0Jykuc2xpY2soJ3NsaWNrUHJldicpO1xufSk7XG5cbi8vYWRkIHRvIGNhcnQgbG9hZGVyXG4kKGRvY3VtZW50KS5vbignY2xpY2snLCAnLmpzLWFkZC10by1jYXJ0OmVuYWJsZWQ6bm90KC5pcy0tbG9hZGluZyknLCBmdW5jdGlvbiAoKSB7XG4gICQodGhpcykuYWRkQ2xhc3MoJ2lzLS1sb2FkaW5nJykuYXR0cihcImRpc2FibGVkXCIsIHRydWUpO1xufSk7XG4vKlxucHJlc3Rhc2hvcC5vbigndXBkYXRlQ2FydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJlbW92ZUFkZFRvQ2FydExvYWRlcigpO1xuXG59KTtcbnByZXN0YXNob3Aub24oJ2hhbmRsZUVycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmVtb3ZlQWRkVG9DYXJ0TG9hZGVyKCk7XG4gICAgJCgnLmpzLWFkZC10by1jYXJ0JykuYXR0cihcImRpc2FibGVkXCIsIGZhbHNlKTtcblxufSk7XG5mdW5jdGlvbiByZW1vdmVBZGRUb0NhcnRMb2FkZXIoKSB7XG4gICAgJCgnLmpzLWFkZC10by1jYXJ0LmlzLS1sb2FkaW5nJykucmVtb3ZlQ2xhc3MoJ2lzLS1sb2FkaW5nJyk7XG5cbn0qLyIsImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgcHJlc3Rhc2hvcCBmcm9tICdwcmVzdGFzaG9wJztcbnByZXN0YXNob3AuY2FydCA9IHByZXN0YXNob3AuY2FydCB8fCB7fTtcbnByZXN0YXNob3AuY2FydC5hY3RpdmVfaW5wdXRzID0gbnVsbDtcbnZhciBzcGlubmVyU2VsZWN0b3IgPSAnaW5wdXRbbmFtZT1cInByb2R1Y3QtcXVhbnRpdHktc3BpblwiXSc7XG52YXIgaGFzRXJyb3IgPSBmYWxzZTtcbnZhciBpc1VwZGF0ZU9wZXJhdGlvbiA9IGZhbHNlO1xudmFyIGVycm9yTXNnID0gJyc7XG5cbi8qKlxuICogQXR0YWNoIEJvb3RzdHJhcCBUb3VjaFNwaW4gZXZlbnQgaGFuZGxlcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3BpbigpIHtcbiAgJC5lYWNoKCQoc3Bpbm5lclNlbGVjdG9yKSwgZnVuY3Rpb24gKGluZGV4LCBzcGlubmVyKSB7XG4gICAgJChzcGlubmVyKS5Ub3VjaFNwaW4oe1xuICAgICAgYnV0dG9uZG93bl9jbGFzczogJ2J0biBqcy10b3VjaHNwaW4nLFxuICAgICAgYnV0dG9udXBfY2xhc3M6ICdidG4ganMtdG91Y2hzcGluJyxcbiAgICAgIG1pbjogcGFyc2VJbnQoJChzcGlubmVyKS5hdHRyKCdtaW4nKSwgMTApLFxuICAgICAgbWF4OiAxMDAwMDAwXG4gICAgfSk7XG4gIH0pO1xuICBDaGVja1VwZGF0ZVF1YW50aXR5T3BlcmF0aW9ucy5zd2l0Y2hFcnJvclN0YXQoKTtcbn1cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb2R1Y3RMaW5lSW5DYXJ0U2VsZWN0b3IgPSAnLmpzLWNhcnQtbGluZS1wcm9kdWN0LXF1YW50aXR5JztcbiAgdmFyIHByb21pc2VzID0gW107XG4gIHByZXN0YXNob3Aub24oJ3VwZGF0ZUNhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLnF1aWNrdmlldycpLm1vZGFsKCdoaWRlJyk7XG4gICAgJCgnLmpzLWNhcnRfX2NhcmQtYm9keScpLmFkZENsYXNzKCdpcy0tbG9hZGluZycpO1xuICB9KTtcbiAgcHJlc3Rhc2hvcC5vbigndXBkYXRlZENhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgY3JlYXRlU3BpbigpO1xuICAgICQoJy5qcy1jYXJ0X19jYXJkLWJvZHkuaXMtLWxvYWRpbmcnKS5yZW1vdmVDbGFzcygnaXMtLWxvYWRpbmcnKTtcbiAgfSk7XG4gIHByZXN0YXNob3Aub24oJ2hhbmRsZUVycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgJCgnLmpzLWNhcnRfX2NhcmQtYm9keS5pcy0tbG9hZGluZycpLnJlbW92ZUNsYXNzKCdpcy0tbG9hZGluZycpO1xuICB9KTtcbiAgY3JlYXRlU3BpbigpO1xuICB2YXIgJGJvZHkgPSAkKCdib2R5Jyk7XG4gIGZ1bmN0aW9uIGlzVG91Y2hTcGluKG5hbWVzcGFjZSkge1xuICAgIHJldHVybiBuYW1lc3BhY2UgPT09ICdvbi5zdGFydHVwc3BpbicgfHwgbmFtZXNwYWNlID09PSAnb24uc3RhcnRkb3duc3Bpbic7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkSW5jcmVhc2VQcm9kdWN0UXVhbnRpdHkobmFtZXNwYWNlKSB7XG4gICAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gJ29uLnN0YXJ0dXBzcGluJztcbiAgfVxuICBmdW5jdGlvbiBmaW5kQ2FydExpbmVQcm9kdWN0UXVhbnRpdHlJbnB1dCgkdGFyZ2V0KSB7XG4gICAgdmFyICRpbnB1dCA9ICR0YXJnZXQucGFyZW50cygnLmJvb3RzdHJhcC10b3VjaHNwaW4nKS5maW5kKHByb2R1Y3RMaW5lSW5DYXJ0U2VsZWN0b3IpO1xuICAgIGlmICgkaW5wdXQuaXMoJzpmb2N1cycpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICRpbnB1dDtcbiAgfVxuICBmdW5jdGlvbiBjYW1lbGl6ZShzdWJqZWN0KSB7XG4gICAgdmFyIGFjdGlvblR5cGVQYXJ0cyA9IHN1YmplY3Quc3BsaXQoJy0nKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgcGFydDtcbiAgICB2YXIgY2FtZWxpemVkU3ViamVjdCA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhY3Rpb25UeXBlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnQgPSBhY3Rpb25UeXBlUGFydHNbaV07XG4gICAgICBpZiAoMCAhPT0gaSkge1xuICAgICAgICBwYXJ0ID0gcGFydC5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIHBhcnQuc3Vic3RyaW5nKDEpO1xuICAgICAgfVxuICAgICAgY2FtZWxpemVkU3ViamVjdCA9IGNhbWVsaXplZFN1YmplY3QgKyBwYXJ0O1xuICAgIH1cbiAgICByZXR1cm4gY2FtZWxpemVkU3ViamVjdDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUNhcnRBY3Rpb24oJHRhcmdldCwgbmFtZXNwYWNlKSB7XG4gICAgaWYgKCFpc1RvdWNoU3BpbihuYW1lc3BhY2UpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6ICR0YXJnZXQuYXR0cignaHJlZicpLFxuICAgICAgICB0eXBlOiBjYW1lbGl6ZSgkdGFyZ2V0LmRhdGEoJ2xpbmstYWN0aW9uJykpXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgJGlucHV0ID0gZmluZENhcnRMaW5lUHJvZHVjdFF1YW50aXR5SW5wdXQoJHRhcmdldCk7XG4gICAgaWYgKCEkaW5wdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhcnRBY3Rpb24gPSB7fTtcbiAgICBpZiAoc2hvdWxkSW5jcmVhc2VQcm9kdWN0UXVhbnRpdHkobmFtZXNwYWNlKSkge1xuICAgICAgY2FydEFjdGlvbiA9IHtcbiAgICAgICAgdXJsOiAkaW5wdXQuZGF0YSgndXAtdXJsJyksXG4gICAgICAgIHR5cGU6ICdpbmNyZWFzZVByb2R1Y3RRdWFudGl0eSdcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnRBY3Rpb24gPSB7XG4gICAgICAgIHVybDogJGlucHV0LmRhdGEoJ2Rvd24tdXJsJyksXG4gICAgICAgIHR5cGU6ICdkZWNyZWFzZVByb2R1Y3RRdWFudGl0eSdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjYXJ0QWN0aW9uO1xuICB9XG4gIHZhciBhYm9ydFByZXZpb3VzUmVxdWVzdHMgPSBmdW5jdGlvbiBhYm9ydFByZXZpb3VzUmVxdWVzdHMoKSB7XG4gICAgdmFyIHByb21pc2U7XG4gICAgd2hpbGUgKHByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlcy5wb3AoKTtcbiAgICAgIHByb21pc2UuYWJvcnQoKTtcbiAgICB9XG4gIH07XG4gIHZhciBnZXRUb3VjaFNwaW5JbnB1dCA9IGZ1bmN0aW9uIGdldFRvdWNoU3BpbklucHV0KCRidXR0b24pIHtcbiAgICByZXR1cm4gJCgkYnV0dG9uLnBhcmVudHMoJy5ib290c3RyYXAtdG91Y2hzcGluJykuZmluZCgnaW5wdXQnKSk7XG4gIH07XG4gIHZhciBoYW5kbGVDYXJ0QWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlQ2FydEFjdGlvbihldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciBkYXRhc2V0ID0gZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0O1xuICAgIHZhciBjYXJ0QWN0aW9uID0gcGFyc2VDYXJ0QWN0aW9uKCR0YXJnZXQsIGV2ZW50Lm5hbWVzcGFjZSk7XG4gICAgdmFyIHJlcXVlc3REYXRhID0ge1xuICAgICAgYWpheDogJzEnLFxuICAgICAgYWN0aW9uOiAndXBkYXRlJ1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBjYXJ0QWN0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhYm9ydFByZXZpb3VzUmVxdWVzdHMoKTtcbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiBjYXJ0QWN0aW9uLnVybCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZGF0YTogcmVxdWVzdERhdGEsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gYmVmb3JlU2VuZChqcVhIUikge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGpxWEhSKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICBDaGVja1VwZGF0ZVF1YW50aXR5T3BlcmF0aW9ucy5jaGVja1VwZGF0ZU9wZXJ0YXRpb24ocmVzcCk7XG4gICAgICB2YXIgJHF1YW50aXR5SW5wdXQgPSBnZXRUb3VjaFNwaW5JbnB1dCgkdGFyZ2V0KTtcbiAgICAgICRxdWFudGl0eUlucHV0LnZhbChyZXNwLnF1YW50aXR5KTtcblxuICAgICAgLy8gUmVmcmVzaCBjYXJ0IHByZXZpZXdcbiAgICAgIHByZXN0YXNob3AuZW1pdCgndXBkYXRlQ2FydCcsIHtcbiAgICAgICAgcmVhc29uOiBkYXRhc2V0LFxuICAgICAgICByZXNwOiByZXNwXG4gICAgICB9KTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICBwcmVzdGFzaG9wLmVtaXQoJ2hhbmRsZUVycm9yJywge1xuICAgICAgICBldmVudFR5cGU6ICd1cGRhdGVQcm9kdWN0SW5DYXJ0JyxcbiAgICAgICAgcmVzcDogcmVzcCxcbiAgICAgICAgY2FydEFjdGlvbjogY2FydEFjdGlvbi50eXBlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgJGJvZHkub24oJ2NsaWNrJywgJ1tkYXRhLWxpbmstYWN0aW9uPVwiZGVsZXRlLWZyb20tY2FydFwiXSwgW2RhdGEtbGluay1hY3Rpb249XCJyZW1vdmUtdm91Y2hlclwiXScsIGhhbmRsZUNhcnRBY3Rpb24pO1xuICAkYm9keS5vbigndG91Y2hzcGluLm9uLnN0YXJ0ZG93bnNwaW4nLCBzcGlubmVyU2VsZWN0b3IsIGhhbmRsZUNhcnRBY3Rpb24pO1xuICAkYm9keS5vbigndG91Y2hzcGluLm9uLnN0YXJ0dXBzcGluJywgc3Bpbm5lclNlbGVjdG9yLCBoYW5kbGVDYXJ0QWN0aW9uKTtcbiAgZnVuY3Rpb24gc2VuZFVwZGF0ZVF1YW50aXR5SW5DYXJ0UmVxdWVzdCh1cGRhdGVRdWFudGl0eUluQ2FydFVybCwgcmVxdWVzdERhdGEsICR0YXJnZXQpIHtcbiAgICBhYm9ydFByZXZpb3VzUmVxdWVzdHMoKTtcbiAgICByZXR1cm4gJC5hamF4KHtcbiAgICAgIHVybDogdXBkYXRlUXVhbnRpdHlJbkNhcnRVcmwsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGRhdGE6IHJlcXVlc3REYXRhLFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uIGJlZm9yZVNlbmQoanFYSFIpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChqcVhIUik7XG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgQ2hlY2tVcGRhdGVRdWFudGl0eU9wZXJhdGlvbnMuY2hlY2tVcGRhdGVPcGVydGF0aW9uKHJlc3ApO1xuICAgICAgJHRhcmdldC52YWwocmVzcC5xdWFudGl0eSk7XG4gICAgICB2YXIgZGF0YXNldDtcbiAgICAgIGlmICgkdGFyZ2V0ICYmICR0YXJnZXQuZGF0YXNldCkge1xuICAgICAgICBkYXRhc2V0ID0gJHRhcmdldC5kYXRhc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YXNldCA9IHJlc3A7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZnJlc2ggY2FydCBwcmV2aWV3XG4gICAgICBwcmVzdGFzaG9wLmVtaXQoJ3VwZGF0ZUNhcnQnLCB7XG4gICAgICAgIHJlYXNvbjogZGF0YXNldCxcbiAgICAgICAgcmVzcDogcmVzcFxuICAgICAgfSk7XG4gICAgfSkuZmFpbChmdW5jdGlvbiAocmVzcCkge1xuICAgICAgcHJlc3Rhc2hvcC5lbWl0KCdoYW5kbGVFcnJvcicsIHtcbiAgICAgICAgZXZlbnRUeXBlOiAndXBkYXRlUHJvZHVjdFF1YW50aXR5SW5DYXJ0JyxcbiAgICAgICAgcmVzcDogcmVzcFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVxdWVzdERhdGEocXVhbnRpdHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWpheDogJzEnLFxuICAgICAgcXR5OiBNYXRoLmFicyhxdWFudGl0eSksXG4gICAgICBhY3Rpb246ICd1cGRhdGUnLFxuICAgICAgb3A6IGdldFF1YW50aXR5Q2hhbmdlVHlwZShxdWFudGl0eSlcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFF1YW50aXR5Q2hhbmdlVHlwZSgkcXVhbnRpdHkpIHtcbiAgICByZXR1cm4gJHF1YW50aXR5ID4gMCA/ICd1cCcgOiAnZG93bic7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUHJvZHVjdFF1YW50aXR5SW5DYXJ0KGV2ZW50KSB7XG4gICAgdmFyICR0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciB1cGRhdGVRdWFudGl0eUluQ2FydFVybCA9ICR0YXJnZXQuZGF0YSgndXBkYXRlLXVybCcpO1xuICAgIHZhciBiYXNlVmFsdWUgPSAkdGFyZ2V0LmF0dHIoJ3ZhbHVlJyk7XG5cbiAgICAvLyBUaGVyZSBzaG91bGQgYmUgYSB2YWxpZCBwcm9kdWN0IHF1YW50aXR5IGluIGNhcnRcbiAgICB2YXIgdGFyZ2V0VmFsdWUgPSAkdGFyZ2V0LnZhbCgpO1xuICAgIGlmICh0YXJnZXRWYWx1ZSAhPSBwYXJzZUludCh0YXJnZXRWYWx1ZSkgfHwgdGFyZ2V0VmFsdWUgPCAwIHx8IGlzTmFOKHRhcmdldFZhbHVlKSkge1xuICAgICAgJHRhcmdldC52YWwoYmFzZVZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGVyZSBzaG91bGQgYmUgYSBuZXcgcHJvZHVjdCBxdWFudGl0eSBpbiBjYXJ0XG4gICAgdmFyIHF0eSA9IHRhcmdldFZhbHVlIC0gYmFzZVZhbHVlO1xuICAgIGlmIChxdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgJHRhcmdldC5hdHRyKCd2YWx1ZScsIHRhcmdldFZhbHVlKTtcbiAgICBzZW5kVXBkYXRlUXVhbnRpdHlJbkNhcnRSZXF1ZXN0KHVwZGF0ZVF1YW50aXR5SW5DYXJ0VXJsLCBnZXRSZXF1ZXN0RGF0YShxdHkpLCAkdGFyZ2V0KTtcbiAgfVxuICAkYm9keS5vbignZm9jdXNvdXQga2V5dXAnLCBwcm9kdWN0TGluZUluQ2FydFNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHVwZGF0ZVByb2R1Y3RRdWFudGl0eUluQ2FydChldmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZVByb2R1Y3RRdWFudGl0eUluQ2FydChldmVudCk7XG4gIH0pO1xuICAkYm9keS5vbignY2xpY2snLCAnLmpzLWRpc2NvdW50IC5jb2RlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdmFyICRjb2RlID0gJChldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICB2YXIgJGRpc2NvdW50SW5wdXQgPSAkKCdbbmFtZT1kaXNjb3VudF9uYW1lXScpO1xuICAgICRkaXNjb3VudElucHV0LnZhbCgkY29kZS50ZXh0KCkpO1xuICAgICQoJyNwcm9tby1jb2RlJykuY29sbGFwc2UoJ3Nob3cnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufSk7XG52YXIgQ2hlY2tVcGRhdGVRdWFudGl0eU9wZXJhdGlvbnMgPSB7XG4gICdzd2l0Y2hFcnJvclN0YXQnOiBmdW5jdGlvbiBzd2l0Y2hFcnJvclN0YXQoKSB7XG4gICAgLyoqXG4gICAgICogcmVzcC5oYXNFcnJvciBjYW4gYmUgbm90IGRlZmluZWQgYnV0IHJlc3AuZXJyb3JzIG5vdCBlbXB0eTogcXVhbnRpdHkgaXMgdXBkYXRlZCBidXQgb3JkZXIgY2Fubm90IGJlIHBsYWNlZFxuICAgICAqIHdoZW4gcmVzcC5oYXNFcnJvcj10cnVlLCBxdWFudGl0eSBpcyBub3QgdXBkYXRlZFxuICAgICAqL1xuICAgIHZhciAkY2hlY2tvdXRCdG4gPSAkKCcuY2hlY2tvdXQgYScpO1xuICAgIGlmICgkKFwiI25vdGlmaWNhdGlvbnMgYXJ0aWNsZS5hbGVydC1kYW5nZXJcIikubGVuZ3RoIHx8ICcnICE9PSBlcnJvck1zZyAmJiAhaGFzRXJyb3IpIHtcbiAgICAgICRjaGVja291dEJ0bi5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgaWYgKCcnICE9PSBlcnJvck1zZykge1xuICAgICAgdmFyIHN0ckVycm9yID0gJyA8YXJ0aWNsZSBjbGFzcz1cImFsZXJ0IGFsZXJ0LWRhbmdlclwiIHJvbGU9XCJhbGVydFwiIGRhdGEtYWxlcnQ9XCJkYW5nZXJcIj48dWw+PGxpPicgKyBlcnJvck1zZyArICc8L2xpPjwvdWw+PC9hcnRpY2xlPic7XG4gICAgICAkKCcjbm90aWZpY2F0aW9ucy5ub3RpZmljYXRpb25zLWNvbnRhaW5lcicpLmh0bWwoc3RyRXJyb3IpO1xuICAgICAgZXJyb3JNc2cgPSAnJztcbiAgICAgIGlzVXBkYXRlT3BlcmF0aW9uID0gZmFsc2U7XG4gICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgLy8gaWYgaGFzRXJyb3IgaXMgdHJ1ZSwgcXVhbnRpdHkgd2FzIG5vdCB1cGRhdGVkIDogYWxsb3cgY2hlY2tvdXRcbiAgICAgICAgJGNoZWNrb3V0QnRuLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWhhc0Vycm9yICYmIGlzVXBkYXRlT3BlcmF0aW9uKSB7XG4gICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgaXNVcGRhdGVPcGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICQoJyNub3RpZmljYXRpb25zLm5vdGlmaWNhdGlvbnMtY29udGFpbmVyJykuaHRtbCgnJyk7XG4gICAgICAkY2hlY2tvdXRCdG4ucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgfVxuICB9LFxuICAnY2hlY2tVcGRhdGVPcGVydGF0aW9uJzogZnVuY3Rpb24gY2hlY2tVcGRhdGVPcGVydGF0aW9uKHJlc3ApIHtcbiAgICAvKipcbiAgICAgKiByZXNwLmhhc0Vycm9yIGNhbiBiZSBub3QgZGVmaW5lZCBidXQgcmVzcC5lcnJvcnMgbm90IGVtcHR5OiBxdWFudGl0eSBpcyB1cGRhdGVkIGJ1dCBvcmRlciBjYW5ub3QgYmUgcGxhY2VkXG4gICAgICogd2hlbiByZXNwLmhhc0Vycm9yPXRydWUsIHF1YW50aXR5IGlzIG5vdCB1cGRhdGVkXG4gICAgICovXG4gICAgaGFzRXJyb3IgPSByZXNwLmhhc093blByb3BlcnR5KCdoYXNFcnJvcicpO1xuICAgIHZhciBlcnJvcnMgPSByZXNwLmVycm9ycyB8fCBcIlwiO1xuICAgIC8vIDEuNy4yLnggcmV0dXJucyBlcnJvcnMgYXMgc3RyaW5nLCAxLjcuMy54IHJldHVybnMgYXJyYXlcbiAgICBpZiAoZXJyb3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGVycm9yTXNnID0gZXJyb3JzLmpvaW4oXCIgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvck1zZyA9IGVycm9ycztcbiAgICB9XG4gICAgaXNVcGRhdGVPcGVyYXRpb24gPSB0cnVlO1xuICB9XG59OyIsImZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIDIwMDctMjAxNyBQcmVzdGFTaG9wXG4gKlxuICogTk9USUNFIE9GIExJQ0VOU0VcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIHN1YmplY3QgdG8gdGhlIEFjYWRlbWljIEZyZWUgTGljZW5zZSAzLjAgKEFGTC0zLjApXG4gKiB0aGF0IGlzIGJ1bmRsZWQgd2l0aCB0aGlzIHBhY2thZ2UgaW4gdGhlIGZpbGUgTElDRU5TRS50eHQuXG4gKiBJdCBpcyBhbHNvIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSB3b3JsZC13aWRlLXdlYiBhdCB0aGlzIFVSTDpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQUZMLTMuMFxuICogSWYgeW91IGRpZCBub3QgcmVjZWl2ZSBhIGNvcHkgb2YgdGhlIGxpY2Vuc2UgYW5kIGFyZSB1bmFibGUgdG9cbiAqIG9idGFpbiBpdCB0aHJvdWdoIHRoZSB3b3JsZC13aWRlLXdlYiwgcGxlYXNlIHNlbmQgYW4gZW1haWxcbiAqIHRvIGxpY2Vuc2VAcHJlc3Rhc2hvcC5jb20gc28gd2UgY2FuIHNlbmQgeW91IGEgY29weSBpbW1lZGlhdGVseS5cbiAqXG4gKiBESVNDTEFJTUVSXG4gKlxuICogRG8gbm90IGVkaXQgb3IgYWRkIHRvIHRoaXMgZmlsZSBpZiB5b3Ugd2lzaCB0byB1cGdyYWRlIFByZXN0YVNob3AgdG8gbmV3ZXJcbiAqIHZlcnNpb25zIGluIHRoZSBmdXR1cmUuIElmIHlvdSB3aXNoIHRvIGN1c3RvbWl6ZSBQcmVzdGFTaG9wIGZvciB5b3VyXG4gKiBuZWVkcyBwbGVhc2UgcmVmZXIgdG8gaHR0cDovL3d3dy5wcmVzdGFzaG9wLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAYXV0aG9yICAgIFByZXN0YVNob3AgU0EgPGNvbnRhY3RAcHJlc3Rhc2hvcC5jb20+XG4gKiBAY29weXJpZ2h0IDIwMDctMjAxNyBQcmVzdGFTaG9wIFNBXG4gKiBAbGljZW5zZSAgIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQUZMLTMuMCBBY2FkZW1pYyBGcmVlIExpY2Vuc2UgMy4wIChBRkwtMy4wKVxuICogSW50ZXJuYXRpb25hbCBSZWdpc3RlcmVkIFRyYWRlbWFyayAmIFByb3BlcnR5IG9mIFByZXN0YVNob3AgU0FcbiAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbnZhciBGb3JtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9ybSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhGb3JtLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnBhcmVudEZvY3VzKCk7XG4gICAgICB0aGlzLnRvZ2dsZVBhc3N3b3JkVmlzaWJpbGl0eSgpO1xuICAgICAgdGhpcy5mb3JtVmFsaWRhdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJlbnRGb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJlbnRGb2N1cygpIHtcbiAgICAgICQoJy5qcy1jaGlsZC1mb2N1cycpLmZvY3VzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcuanMtcGFyZW50LWZvY3VzJykuYWRkQ2xhc3MoJ2ZvY3VzJyk7XG4gICAgICB9KTtcbiAgICAgICQoJy5qcy1jaGlsZC1mb2N1cycpLmZvY3Vzb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcuanMtcGFyZW50LWZvY3VzJykucmVtb3ZlQ2xhc3MoJ2ZvY3VzJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlUGFzc3dvcmRWaXNpYmlsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVBhc3N3b3JkVmlzaWJpbGl0eSgpIHtcbiAgICAgICQoJ2J1dHRvbltkYXRhLWFjdGlvbj1cInNob3ctcGFzc3dvcmRcIl0nKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbG0gPSAkKHRoaXMpLmNsb3Nlc3QoJy5pbnB1dC1ncm91cCcpLmNoaWxkcmVuKCdpbnB1dC5qcy12aXNpYmxlLXBhc3N3b3JkJyk7XG4gICAgICAgIGlmIChlbG0uYXR0cigndHlwZScpID09PSAncGFzc3dvcmQnKSB7XG4gICAgICAgICAgZWxtLmF0dHIoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICAgICQodGhpcykudGV4dCgkKHRoaXMpLmRhdGEoJ3RleHRIaWRlJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbS5hdHRyKCd0eXBlJywgJ3Bhc3N3b3JkJyk7XG4gICAgICAgICAgJCh0aGlzKS50ZXh0KCQodGhpcykuZGF0YSgndGV4dFNob3cnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtVmFsaWRhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtVmFsaWRhdGlvbigpIHtcbiAgICAgIC8vIEZldGNoIGFsbCB0aGUgZm9ybXMgd2Ugd2FudCB0byBhcHBseSBjdXN0b20gQm9vdHN0cmFwIHZhbGlkYXRpb24gc3R5bGVzIHRvXG4gICAgICB2YXIgZm9ybXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCduZWVkcy12YWxpZGF0aW9uJyk7XG4gICAgICBpZiAoZm9ybXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhzdXBwb3J0ZWRWYWxpZGl0eSgpKTtcbiAgICAgICAgaWYgKCFzdXBwb3J0ZWRWYWxpZGl0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGVtIGFuZCBwcmV2ZW50IHN1Ym1pc3Npb25cbiAgICAgICAgdmFyIGRpdlRvU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIHZhciB2YWxpZGF0aW9uID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGZvcm1zLCBmdW5jdGlvbiAoZm9ybSkge1xuICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZm9ybS5jaGVja1ZhbGlkaXR5KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAkKCdpbnB1dDppbnZhbGlkLHNlbGVjdDppbnZhbGlkLHRleHRhcmVhOmludmFsaWQnLCBmb3JtKS5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfZmllbGQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgX3BhcmVudCA9IF9maWVsZC5wYXJlbnRzKCcuZm9ybS1ncm91cCcpLmZpcnN0KCk7XG4gICAgICAgICAgICAgICAgJCgnLmpzLWludmFsaWQtZmVlZGJhY2stYnJvd3NlcicsIF9wYXJlbnQpLnRleHQoX2ZpZWxkWzBdLnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpdlRvU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICBkaXZUb1Njcm9sbCA9IF9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgJCgnYnV0dG9uW3R5cGU9XCJzdWJtaXRcIl0nLCBmb3JtKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcm0uY2xhc3NMaXN0LmFkZCgnd2FzLXZhbGlkYXRlZCcpO1xuICAgICAgICAgICAgaWYgKGRpdlRvU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IGRpdlRvU2Nyb2xsLm9mZnNldCgpLnRvcFxuICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICBkaXZUb1Njcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5leHBvcnQgeyBGb3JtIGFzIGRlZmF1bHQgfTtcbnZhciBzdXBwb3J0ZWRWYWxpZGl0eSA9IGZ1bmN0aW9uIHN1cHBvcnRlZFZhbGlkaXR5KCkge1xuICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICByZXR1cm4gJ3ZhbGlkaXR5JyBpbiBpbnB1dCAmJiAnYmFkSW5wdXQnIGluIGlucHV0LnZhbGlkaXR5ICYmICdwYXR0ZXJuTWlzbWF0Y2gnIGluIGlucHV0LnZhbGlkaXR5ICYmICdyYW5nZU92ZXJmbG93JyBpbiBpbnB1dC52YWxpZGl0eSAmJiAncmFuZ2VVbmRlcmZsb3cnIGluIGlucHV0LnZhbGlkaXR5ICYmICd0b29Mb25nJyBpbiBpbnB1dC52YWxpZGl0eSAmJiAndG9vU2hvcnQnIGluIGlucHV0LnZhbGlkaXR5ICYmICd0eXBlTWlzbWF0Y2gnIGluIGlucHV0LnZhbGlkaXR5ICYmICd2YWxpZCcgaW4gaW5wdXQudmFsaWRpdHkgJiYgJ3ZhbHVlTWlzc2luZycgaW4gaW5wdXQudmFsaWRpdHk7XG59OyIsImZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIDIwMDctMjAxNyBQcmVzdGFTaG9wXG4gKlxuICogTk9USUNFIE9GIExJQ0VOU0VcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIHN1YmplY3QgdG8gdGhlIEFjYWRlbWljIEZyZWUgTGljZW5zZSAzLjAgKEFGTC0zLjApXG4gKiB0aGF0IGlzIGJ1bmRsZWQgd2l0aCB0aGlzIHBhY2thZ2UgaW4gdGhlIGZpbGUgTElDRU5TRS50eHQuXG4gKiBJdCBpcyBhbHNvIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSB3b3JsZC13aWRlLXdlYiBhdCB0aGlzIFVSTDpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQUZMLTMuMFxuICogSWYgeW91IGRpZCBub3QgcmVjZWl2ZSBhIGNvcHkgb2YgdGhlIGxpY2Vuc2UgYW5kIGFyZSB1bmFibGUgdG9cbiAqIG9idGFpbiBpdCB0aHJvdWdoIHRoZSB3b3JsZC13aWRlLXdlYiwgcGxlYXNlIHNlbmQgYW4gZW1haWxcbiAqIHRvIGxpY2Vuc2VAcHJlc3Rhc2hvcC5jb20gc28gd2UgY2FuIHNlbmQgeW91IGEgY29weSBpbW1lZGlhdGVseS5cbiAqXG4gKiBESVNDTEFJTUVSXG4gKlxuICogRG8gbm90IGVkaXQgb3IgYWRkIHRvIHRoaXMgZmlsZSBpZiB5b3Ugd2lzaCB0byB1cGdyYWRlIFByZXN0YVNob3AgdG8gbmV3ZXJcbiAqIHZlcnNpb25zIGluIHRoZSBmdXR1cmUuIElmIHlvdSB3aXNoIHRvIGN1c3RvbWl6ZSBQcmVzdGFTaG9wIGZvciB5b3VyXG4gKiBuZWVkcyBwbGVhc2UgcmVmZXIgdG8gaHR0cDovL3d3dy5wcmVzdGFzaG9wLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAYXV0aG9yICAgIFByZXN0YVNob3AgU0EgPGNvbnRhY3RAcHJlc3Rhc2hvcC5jb20+XG4gKiBAY29weXJpZ2h0IDIwMDctMjAxNyBQcmVzdGFTaG9wIFNBXG4gKiBAbGljZW5zZSAgIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQUZMLTMuMCBBY2FkZW1pYyBGcmVlIExpY2Vuc2UgMy4wIChBRkwtMy4wKVxuICogSW50ZXJuYXRpb25hbCBSZWdpc3RlcmVkIFRyYWRlbWFyayAmIFByb3BlcnR5IG9mIFByZXN0YVNob3AgU0FcbiAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbnZhciBUb3BNZW51ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9wTWVudShlbCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb3BNZW51KTtcbiAgICB0aGlzLmVsID0gZWw7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUb3BNZW51LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBzZWxmLmVsLmhvdmVySW50ZW50KHtcbiAgICAgICAgb3Zlcjogc2VsZi50b2dnbGVDbGFzc1N1Yk1lbnUsXG4gICAgICAgIG91dDogc2VsZi50b2dnbGVDbGFzc1N1Yk1lbnUsXG4gICAgICAgIHNlbGVjdG9yOiAnID4gbGknLFxuICAgICAgICB0aW1lb3V0OiAxMDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVDbGFzc1N1Yk1lbnVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlQ2xhc3NTdWJNZW51KCkge1xuICAgICAgdmFyIF9pdGVtID0gJCh0aGlzKTtcbiAgICAgIHZhciBleHBhbmRlZCA9IF9pdGVtLmF0dHIoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIGlmICh0eXBlb2YgZXhwYW5kZWQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZXhwYW5kZWQgPSBleHBhbmRlZC50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgICAgIF9pdGVtLnRvZ2dsZUNsYXNzKCdtZW51X19pdGVtLS1hY3RpdmUnKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgIWV4cGFuZGVkKTtcbiAgICAgICAgJCgnLm1lbnUtc3ViJywgX2l0ZW0pLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAhZXhwYW5kZWQpLmF0dHIoJ2FyaWEtaGlkZGVuJywgZXhwYW5kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufSgpO1xuZXhwb3J0IHsgVG9wTWVudSBhcyBkZWZhdWx0IH07IiwiLyoqXG4gKiAyMDA3LTIwMTcgUHJlc3RhU2hvcFxuICpcbiAqIE5PVElDRSBPRiBMSUNFTlNFXG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBzdWJqZWN0IHRvIHRoZSBBY2FkZW1pYyBGcmVlIExpY2Vuc2UgMy4wIChBRkwtMy4wKVxuICogdGhhdCBpcyBidW5kbGVkIHdpdGggdGhpcyBwYWNrYWdlIGluIHRoZSBmaWxlIExJQ0VOU0UudHh0LlxuICogSXQgaXMgYWxzbyBhdmFpbGFibGUgdGhyb3VnaCB0aGUgd29ybGQtd2lkZS13ZWIgYXQgdGhpcyBVUkw6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0FGTC0zLjBcbiAqIElmIHlvdSBkaWQgbm90IHJlY2VpdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIGFuZCBhcmUgdW5hYmxlIHRvXG4gKiBvYnRhaW4gaXQgdGhyb3VnaCB0aGUgd29ybGQtd2lkZS13ZWIsIHBsZWFzZSBzZW5kIGFuIGVtYWlsXG4gKiB0byBsaWNlbnNlQHByZXN0YXNob3AuY29tIHNvIHdlIGNhbiBzZW5kIHlvdSBhIGNvcHkgaW1tZWRpYXRlbHkuXG4gKlxuICogRElTQ0xBSU1FUlxuICpcbiAqIERvIG5vdCBlZGl0IG9yIGFkZCB0byB0aGlzIGZpbGUgaWYgeW91IHdpc2ggdG8gdXBncmFkZSBQcmVzdGFTaG9wIHRvIG5ld2VyXG4gKiB2ZXJzaW9ucyBpbiB0aGUgZnV0dXJlLiBJZiB5b3Ugd2lzaCB0byBjdXN0b21pemUgUHJlc3RhU2hvcCBmb3IgeW91clxuICogbmVlZHMgcGxlYXNlIHJlZmVyIHRvIGh0dHA6Ly93d3cucHJlc3Rhc2hvcC5jb20gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGF1dGhvciAgICBQcmVzdGFTaG9wIFNBIDxjb250YWN0QHByZXN0YXNob3AuY29tPlxuICogQGNvcHlyaWdodCAyMDA3LTIwMTcgUHJlc3RhU2hvcCBTQVxuICogQGxpY2Vuc2UgICBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0FGTC0zLjAgQWNhZGVtaWMgRnJlZSBMaWNlbnNlIDMuMCAoQUZMLTMuMClcbiAqIEludGVybmF0aW9uYWwgUmVnaXN0ZXJlZCBUcmFkZW1hcmsgJiBQcm9wZXJ0eSBvZiBQcmVzdGFTaG9wIFNBXG4gKi9cbmltcG9ydCBwcmVzdGFzaG9wIGZyb20gJ3ByZXN0YXNob3AnO1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbnByZXN0YXNob3AuYmxvY2tjYXJ0ID0gcHJlc3Rhc2hvcC5ibG9ja2NhcnQgfHwge307XG5wcmVzdGFzaG9wLmJsb2NrY2FydC5zaG93TW9kYWwgPSBmdW5jdGlvbiAoaHRtbCkge1xuICBmdW5jdGlvbiBnZXRCbG9ja0NhcnRNb2RhbCgpIHtcbiAgICByZXR1cm4gJCgnI2Jsb2NrY2FydC1tb2RhbCcpO1xuICB9XG4gIHZhciAkYmxvY2tDYXJ0TW9kYWwgPSBnZXRCbG9ja0NhcnRNb2RhbCgpO1xuICBpZiAoJGJsb2NrQ2FydE1vZGFsLmxlbmd0aCkge1xuICAgICRibG9ja0NhcnRNb2RhbC5yZW1vdmUoKTtcbiAgfVxuICAkKCdib2R5JykuYXBwZW5kKGh0bWwpO1xuICAkYmxvY2tDYXJ0TW9kYWwgPSBnZXRCbG9ja0NhcnRNb2RhbCgpO1xuICAkYmxvY2tDYXJ0TW9kYWwubW9kYWwoJ3Nob3cnKS5vbignaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcHJlc3Rhc2hvcC5lbWl0KCd1cGRhdGVQcm9kdWN0Jywge1xuICAgICAgcmVhc29uOiBldmVudC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfSk7XG59OyIsIi8qKlxuICogMjAwNy0yMDE3IFByZXN0YVNob3BcbiAqXG4gKiBOT1RJQ0UgT0YgTElDRU5TRVxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgc3ViamVjdCB0byB0aGUgQWNhZGVtaWMgRnJlZSBMaWNlbnNlIDMuMCAoQUZMLTMuMClcbiAqIHRoYXQgaXMgYnVuZGxlZCB3aXRoIHRoaXMgcGFja2FnZSBpbiB0aGUgZmlsZSBMSUNFTlNFLnR4dC5cbiAqIEl0IGlzIGFsc28gYXZhaWxhYmxlIHRocm91Z2ggdGhlIHdvcmxkLXdpZGUtd2ViIGF0IHRoaXMgVVJMOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9BRkwtMy4wXG4gKiBJZiB5b3UgZGlkIG5vdCByZWNlaXZlIGEgY29weSBvZiB0aGUgbGljZW5zZSBhbmQgYXJlIHVuYWJsZSB0b1xuICogb2J0YWluIGl0IHRocm91Z2ggdGhlIHdvcmxkLXdpZGUtd2ViLCBwbGVhc2Ugc2VuZCBhbiBlbWFpbFxuICogdG8gbGljZW5zZUBwcmVzdGFzaG9wLmNvbSBzbyB3ZSBjYW4gc2VuZCB5b3UgYSBjb3B5IGltbWVkaWF0ZWx5LlxuICpcbiAqIERJU0NMQUlNRVJcbiAqXG4gKiBEbyBub3QgZWRpdCBvciBhZGQgdG8gdGhpcyBmaWxlIGlmIHlvdSB3aXNoIHRvIHVwZ3JhZGUgUHJlc3RhU2hvcCB0byBuZXdlclxuICogdmVyc2lvbnMgaW4gdGhlIGZ1dHVyZS4gSWYgeW91IHdpc2ggdG8gY3VzdG9taXplIFByZXN0YVNob3AgZm9yIHlvdXJcbiAqIG5lZWRzIHBsZWFzZSByZWZlciB0byBodHRwOi8vd3d3LnByZXN0YXNob3AuY29tIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBhdXRob3IgICAgUHJlc3RhU2hvcCBTQSA8Y29udGFjdEBwcmVzdGFzaG9wLmNvbT5cbiAqIEBjb3B5cmlnaHQgMjAwNy0yMDE3IFByZXN0YVNob3AgU0FcbiAqIEBsaWNlbnNlICAgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9BRkwtMy4wIEFjYWRlbWljIEZyZWUgTGljZW5zZSAzLjAgKEFGTC0zLjApXG4gKiBJbnRlcm5hdGlvbmFsIFJlZ2lzdGVyZWQgVHJhZGVtYXJrICYgUHJvcGVydHkgb2YgUHJlc3RhU2hvcCBTQVxuICovXG5pbXBvcnQgJ2Jvb3RzdHJhcC9qcy9zcmMvdXRpbCc7XG5pbXBvcnQgJ2Jvb3RzdHJhcC9qcy9zcmMvYWxlcnQnO1xuaW1wb3J0ICdib290c3RyYXAvanMvc3JjL2J1dHRvbic7XG5pbXBvcnQgJy4uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvc3JjL2NvbGxhcHNlLmpzJztcbmltcG9ydCAnYm9vdHN0cmFwL2pzL3NyYy9jb2xsYXBzZSc7XG5pbXBvcnQgJ2Jvb3RzdHJhcC9qcy9zcmMvZHJvcGRvd24nO1xuaW1wb3J0ICdib290c3RyYXAvanMvc3JjL21vZGFsJztcbmltcG9ydCAnYm9vdHN0cmFwL2pzL3NyYy9wb3BvdmVyJztcbmltcG9ydCAnYm9vdHN0cmFwL2pzL3NyYy90YWInO1xuaW1wb3J0ICdib290c3RyYXAvanMvc3JjL3RvYXN0JztcbmltcG9ydCAnYm9vdHN0cmFwL2pzL3NyYy90b29sdGlwJztcbmltcG9ydCAnYm9vdHN0cmFwLXRvdWNoc3Bpbic7XG5pbXBvcnQgJy4vbGliL3NsaWNrLm1pbic7XG5pbXBvcnQgJy4vbGliL2pxdWVyeS5ob3ZlckludGVudC5taW4nO1xuaW1wb3J0IFNsaWNrU2xpZGVyIGZyb20gJy4vY29tcG9uZW50cy9zbGljayc7XG5pbXBvcnQgJy4uL25vZGVfbW9kdWxlcy9qcXVlcnktem9vbS9qcXVlcnkuem9vbS5taW4uanMnO1xuaW1wb3J0ICcuL3Jlc3BvbnNpdmUnO1xuaW1wb3J0ICcuL2NoZWNrb3V0JztcbmltcG9ydCAnLi9jdXN0b21lcic7XG5pbXBvcnQgJy4vbGlzdGluZyc7XG5pbXBvcnQgJy4vcHJvZHVjdCc7XG5pbXBvcnQgJy4vY2FydCc7XG5pbXBvcnQgRm9ybSBmcm9tICcuL2NvbXBvbmVudHMvZm9ybSc7XG5pbXBvcnQgVG9wTWVudSBmcm9tICcuL2NvbXBvbmVudHMvdG9wLW1lbnUnO1xuaW1wb3J0IHByZXN0YXNob3AgZnJvbSAncHJlc3Rhc2hvcCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgJy4vY29tcG9uZW50cy9ibG9jay1jYXJ0JztcbmltcG9ydCBsYXp5c2l6ZXMgZnJvbSAnbGF6eXNpemVzJztcblxuLy8gXCJpbmhlcml0XCIgRXZlbnRFbWl0dGVyXG5mb3IgKHZhciBpIGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgcHJlc3Rhc2hvcFtpXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbaV07XG59XG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gIHZhciBmb3JtID0gbmV3IEZvcm0oKTtcbiAgdmFyIHNsaWNrU2xpZGVyID0gbmV3IFNsaWNrU2xpZGVyKCk7XG4gIHZhciB0b3BNZW51RWwgPSAkKCcjX2Rlc2t0b3BfdG9wX21lbnUgI3RvcC1tZW51Jyk7XG4gIHZhciB0b3BNZW51ID0gbmV3IFRvcE1lbnUodG9wTWVudUVsKTtcbiAgZm9ybS5pbml0KCk7XG4gIHNsaWNrU2xpZGVyLmluaXQoKTtcbiAgdG9wTWVudS5pbml0KCk7XG5cbiAgLy9kaXNwbGF5IGlucHV0IGZpbGUgY29udGVudCBpbiBjdXN0b20gZmlsZSBpbnB1dCBCU1xuICAkKCcuY3VzdG9tLWZpbGUtaW5wdXQnKS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWxlTmFtZSA9ICQodGhpcykudmFsKCkuc3BsaXQoJ1xcXFwnKS5wb3AoKTtcbiAgICAkKHRoaXMpLm5leHQoJy5jdXN0b20tZmlsZS1sYWJlbCcpLmFkZENsYXNzKFwic2VsZWN0ZWRcIikuaHRtbChmaWxlTmFtZSk7XG4gIH0pO1xufSk7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdsYXp5bG9hZGVkJywgZnVuY3Rpb24gKGUpIHtcbiAgJChlLnRhcmdldCkucGFyZW50KCkuYWRkQ2xhc3MoJ3JjLS1sYXp5bG9hZCcpO1xufSk7XG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUubG9nKCdyZWFkeScpO1xuICAvKiBTQ1JPTEwgVE8gQU5DSE9SICovXG4gIGlmICh3aW5kb3cubG9jYXRpb24uaGFzaCAmJiB3aW5kb3cubG9jYXRpb24uaGFzaFsxXSAhPSAnLycpIHtcbiAgICBzY3JvbGxUb0FuY2hvcih3aW5kb3cubG9jYXRpb24uaGFzaCk7XG4gIH1cbiAgRnVsbFdpZHRoKCk7XG4gIGlmICgkKGxvY2F0aW9uKS5hdHRyKFwicGF0aG5hbWVcIikgIT0gXCIvY29tbWFuZGVcIiAmJiAkKGxvY2F0aW9uKS5hdHRyKFwicGF0aG5hbWVcIikgIT0gXCIvY2hlY2tvdXRcIikge1xuICAgIHN0aWNreSgpO1xuICAgIE1vYmlsZU1lbnVPaygpO1xuICB9XG4gICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24gKCkge1xuICAgIEZ1bGxXaWR0aCgpO1xuICAgIGlmICgkKGxvY2F0aW9uKS5hdHRyKFwicGF0aG5hbWVcIikgIT0gXCIvY29tbWFuZGVcIiAmJiAkKGxvY2F0aW9uKS5hdHRyKFwicGF0aG5hbWVcIikgIT0gXCIvY2hlY2tvdXRcIikge1xuICAgICAgTW9iaWxlTWVudU9rKCk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gRnVsbFdpZHRoKCkge1xuICAgICQoJy5mdWxsd2lkdGgnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250ZW50ID0gJCh0aGlzKTtcbiAgICAgIHZhciBmdWxsd2lkdGggPSAkKCdib2R5Jykud2lkdGgoKSxcbiAgICAgICAgbWFyZ2luX2Z1bGwgPSBmdWxsd2lkdGggLyAyO1xuICAgICAgLy9jb25zb2xlLmxvZyhmdWxsd2lkdGgpO1xuICAgICAgLy9jb25zb2xlLmxvZyhjb250ZW50KTtcbiAgICAgIGNvbnRlbnQuY3NzKHtcbiAgICAgICAgJ2xlZnQnOiAnNTAlJyxcbiAgICAgICAgJ3Bvc2l0aW9uJzogJ3JlbGF0aXZlJyxcbiAgICAgICAgJ3dpZHRoJzogZnVsbHdpZHRoLFxuICAgICAgICAnbWFyZ2luLWxlZnQnOiAtbWFyZ2luX2Z1bGxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN0aWNreSgpIHtcbiAgICBjb25zb2xlLmxvZygnc3RpY2t5Jyk7XG4gICAgdmFyIHlvdXJOYXZpZ2F0aW9uID0gJChcIiNoZWFkZXJcIik7XG4gICAgdmFyIHN0aWNreURpdiA9IFwic3RpY2t5XCI7XG4gICAgdmFyIHVuU3RpY2t5RGl2ID0gXCJ1bnN0aWNreVwiO1xuICAgIHZhciB5b3VySGVhZGVyID0gJCgnI2hlYWRlcicpLmhlaWdodCgpO1xuICAgICQod2luZG93KS5zY3JvbGwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCQodGhpcykuc2Nyb2xsVG9wKCkgPiAwKSB7XG4gICAgICAgIHlvdXJOYXZpZ2F0aW9uLmFkZENsYXNzKHN0aWNreURpdikucmVtb3ZlQ2xhc3ModW5TdGlja3lEaXYpO1xuICAgICAgICAkKCdib2R5JykuY3NzKCdwYWRkaW5nLXRvcCcsIHlvdXJIZWFkZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeW91ck5hdmlnYXRpb24uYWRkQ2xhc3ModW5TdGlja3lEaXYpLnJlbW92ZUNsYXNzKHN0aWNreURpdik7XG4gICAgICAgICQoJ2JvZHknKS5jc3MoJ3BhZGRpbmctdG9wJywgMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gTW9iaWxlTWVudU9rKCkge1xuICAgICQoXCIubW9kYWwtZGlhbG9nX19vZmZjYW52YXMgI2FkdG1fbWVudVwiKS5hZGRDbGFzcyhcImFkdG1fbWVudV90b2dnbGVfb3BlblwiKTtcbiAgICAvLyQoJyNhZHRtX21lbnUnKS50b2dnbGVDbGFzcygnYWR0bV9tZW51X3RvZ2dsZV9vcGVuJyk7XG4gICAgLy8kKCcjYWR0bV9tZW51IC5hZHZ0bV9tZW51X3RvZ2dsZScpLnRvZ2dsZUNsYXNzKCdhZHRtX21lbnVfbW9iaWxlX21vZGUnKTtcbiAgfVxuICBmdW5jdGlvbiBzY3JvbGxUb0FuY2hvcihhbmNob3IpIHtcbiAgICBjb25zb2xlLmxvZyhhbmNob3IpO1xuICAgIHZhciB0YXJnZXQgPSAkKGFuY2hvcik7XG4gICAgdmFyIHNjcm9sbFRvcCA9IHRhcmdldC5vZmZzZXQoKS50b3AgLSAkKCcjaGVhZGVyJykuaGVpZ2h0KCkgLSA0MDtcbiAgICAvL3ZhciBzY3JvbGxUb3AgPSB0YXJnZXQub2Zmc2V0KCkudG9wIC0gJCgnI2hlYWRlcicpLmhlaWdodCgpO1xuICAgIGNvbnNvbGUubG9nKCdoZWFkZXIgaGVpZ2h0OiAnICsgJCgnI2hlYWRlcicpLmhlaWdodCgpKTtcbiAgICBjb25zb2xlLmxvZygnc2Nyb2xsVG9wIDogJyArIHNjcm9sbFRvcCk7XG4gICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgICB9LCAxMDAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDYWxsYmFjayBhZnRlciBhbmltYXRpb25cbiAgICAgIC8vIE11c3QgY2hhbmdlIGZvY3VzIVxuICAgICAgdmFyICR0YXJnZXQgPSAkKHRhcmdldCk7XG4gICAgICAkdGFyZ2V0LmZvY3VzKCk7XG4gICAgICBpZiAoJHRhcmdldC5pcyhcIjpmb2N1c1wiKSkge1xuICAgICAgICAvLyBDaGVja2luZyBpZiB0aGUgdGFyZ2V0IHdhcyBmb2N1c2VkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR0YXJnZXQuYXR0cigndGFiaW5kZXgnLCAnLTEnKTsgLy8gQWRkaW5nIHRhYmluZGV4IGZvciBlbGVtZW50cyBub3QgZm9jdXNhYmxlXG4gICAgICAgICR0YXJnZXQuZm9jdXMoKTsgLy8gU2V0IGZvY3VzIGFnYWluXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBGb25jdGlvbiBwb3VyIHNjcm9sbGVyIGxlcyBsaWVucyB2ZXJzIGFuY3Jlc1xuICAkKCdhW2hyZWYqPVwiI1wiXScpXG4gIC8vIFJlbW92ZSBsaW5rcyB0aGF0IGRvbid0IGFjdHVhbGx5IGxpbmsgdG8gYW55dGhpbmdcbiAgLm5vdCgnW2hyZWY9XCIjXCJdJykubm90KCdbaHJlZio9XCIjZm9vdGVyXCJdJykubm90KCcuZm9vdGVyX190aXRsZS0tbW9iaWxlJykubm90KCcubm9zY3JvbGwnKVxuICAvKlxuICAgLm5vdCgnW2hyZWY9XCIjMFwiXScpXG4gICAubm90KCdbaHJlZj1cIiNidF90YWJzLTBcIl0nKVxuICAgLm5vdCgnW2hyZWY9XCIjYnRfdGFicy0xXCJdJykqLy5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBPbi1wYWdlIGxpbmtzXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCAnJykgPT0gdGhpcy5wYXRobmFtZS5yZXBsYWNlKC9eXFwvLywgJycpICYmIGxvY2F0aW9uLmhvc3RuYW1lID09IHRoaXMuaG9zdG5hbWUpIHtcbiAgICAgIC8vIEZpZ3VyZSBvdXQgZWxlbWVudCB0byBzY3JvbGwgdG9cblxuICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ25hdi1saW5rJykpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9ICQodGhpcykucGFyZW50KCkucGFyZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gJCh0aGlzLmhhc2gpO1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQubGVuZ3RoID8gdGFyZ2V0IDogJCgnW25hbWU9JyArIHRoaXMuaGFzaC5zbGljZSgxKSArICddJyk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygndGFyZ2V0Jyk7XG4gICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuICAgICAgY29uc29sZS5sb2codGFyZ2V0Lm9mZnNldCgpLnRvcCk7XG4gICAgICBjb25zb2xlLmxvZygnaGVhZGVyIGhlaWdodCcpO1xuICAgICAgY29uc29sZS5sb2coJCgnI2hlYWRlcicpLmhlaWdodCgpKTtcblxuICAgICAgLy8gRG9lcyBhIHNjcm9sbCB0YXJnZXQgZXhpc3Q/XG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICAvLyBPbmx5IHByZXZlbnQgZGVmYXVsdCBpZiBhbmltYXRpb24gaXMgYWN0dWFsbHkgZ29ubmEgaGFwcGVuXG4gICAgICAgIC8vZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGFyZ2V0Lm9mZnNldCgpLnRvcCAtICQoJyNoZWFkZXInKS5oZWlnaHQoKSAtIDQwO1xuICAgICAgICBjb25zb2xlLmxvZygnaGVhZGVyIGhlaWdodDogJyArICQoJyNoZWFkZXInKS5oZWlnaHQoKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdzY3JvbGxUb3AgOiAnICsgc2Nyb2xsVG9wKTtcbiAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gICAgICAgIH0sIDEwMDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBDYWxsYmFjayBhZnRlciBhbmltYXRpb25cbiAgICAgICAgICAvLyBNdXN0IGNoYW5nZSBmb2N1cyFcbiAgICAgICAgICB2YXIgJHRhcmdldCA9ICQodGFyZ2V0KTtcbiAgICAgICAgICAkdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgaWYgKCR0YXJnZXQuaXMoXCI6Zm9jdXNcIikpIHtcbiAgICAgICAgICAgIC8vIENoZWNraW5nIGlmIHRoZSB0YXJnZXQgd2FzIGZvY3VzZWRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHRhcmdldC5hdHRyKCd0YWJpbmRleCcsICctMScpOyAvLyBBZGRpbmcgdGFiaW5kZXggZm9yIGVsZW1lbnRzIG5vdCBmb2N1c2FibGVcbiAgICAgICAgICAgICR0YXJnZXQuZm9jdXMoKTsgLy8gU2V0IGZvY3VzIGFnYWluXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///741\n")},285:function(module,exports,__webpack_require__){"use strict";eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n/*\r\n *  Bootstrap Touchspin - v4.7.3\r\n *  A mobile and touch friendly input spinner component for Bootstrap 3 & 4.\r\n *  https://www.virtuosoft.eu/code/bootstrap-touchspin/\r\n *\r\n *  Made by István Ujj-Mészáros\r\n *  Under MIT License\r\n */\n(function (factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(669)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($) {\n  'use strict';\n\n  var _currentSpinnerId = 0;\n  $.fn.TouchSpin = function (options) {\n    var defaults = {\n      min: 0,\n      // If null, there is no minimum enforced\n      max: 100,\n      // If null, there is no maximum enforced\n      initval: '',\n      replacementval: '',\n      firstclickvalueifempty: null,\n      step: 1,\n      decimals: 0,\n      stepinterval: 100,\n      forcestepdivisibility: 'round',\n      // none | floor | round | ceil\n      stepintervaldelay: 500,\n      verticalbuttons: false,\n      verticalup: '&plus;',\n      verticaldown: '&minus;',\n      verticalupclass: '',\n      verticaldownclass: '',\n      prefix: '',\n      postfix: '',\n      prefix_extraclass: '',\n      postfix_extraclass: '',\n      booster: true,\n      boostat: 10,\n      maxboostedstep: false,\n      mousewheel: true,\n      buttondown_class: 'btn btn-primary',\n      buttonup_class: 'btn btn-primary',\n      buttondown_txt: '&minus;',\n      buttonup_txt: '&plus;',\n      callback_before_calculation: function callback_before_calculation(value) {\n        return value;\n      },\n      callback_after_calculation: function callback_after_calculation(value) {\n        return value;\n      }\n    };\n    var attributeMap = {\n      min: 'min',\n      max: 'max',\n      initval: 'init-val',\n      replacementval: 'replacement-val',\n      firstclickvalueifempty: 'first-click-value-if-empty',\n      step: 'step',\n      decimals: 'decimals',\n      stepinterval: 'step-interval',\n      verticalbuttons: 'vertical-buttons',\n      verticalupclass: 'vertical-up-class',\n      verticaldownclass: 'vertical-down-class',\n      forcestepdivisibility: 'force-step-divisibility',\n      stepintervaldelay: 'step-interval-delay',\n      prefix: 'prefix',\n      postfix: 'postfix',\n      prefix_extraclass: 'prefix-extra-class',\n      postfix_extraclass: 'postfix-extra-class',\n      booster: 'booster',\n      boostat: 'boostat',\n      maxboostedstep: 'max-boosted-step',\n      mousewheel: 'mouse-wheel',\n      buttondown_class: 'button-down-class',\n      buttonup_class: 'button-up-class',\n      buttondown_txt: 'button-down-txt',\n      buttonup_txt: 'button-up-txt'\n    };\n    return this.each(function () {\n      var settings,\n        originalinput = $(this),\n        originalinput_data = originalinput.data(),\n        _detached_prefix,\n        _detached_postfix,\n        container,\n        elements,\n        verticalbuttons_html,\n        value,\n        downSpinTimer,\n        upSpinTimer,\n        downDelayTimeout,\n        upDelayTimeout,\n        spincount = 0,\n        spinning = false;\n      init();\n      function init() {\n        if (originalinput.data('alreadyinitialized')) {\n          return;\n        }\n        originalinput.data('alreadyinitialized', true);\n        _currentSpinnerId += 1;\n        originalinput.data('spinnerid', _currentSpinnerId);\n        if (!originalinput.is('input')) {\n          console.log('Must be an input.');\n          return;\n        }\n        _initSettings();\n        _setInitval();\n        _checkValue();\n        _buildHtml();\n        _initElements();\n        _updateButtonDisabledState();\n        _hideEmptyPrefixPostfix();\n        _setupMutationObservers();\n        _bindEvents();\n        _bindEventsInterface();\n      }\n      function _setInitval() {\n        if (settings.initval !== '' && originalinput.val() === '') {\n          originalinput.val(settings.initval);\n        }\n      }\n      function changeSettings(newsettings) {\n        _updateSettings(newsettings);\n        _checkValue();\n        var value = elements.input.val();\n        if (value !== '') {\n          value = parseFloat(settings.callback_before_calculation(elements.input.val()));\n          elements.input.val(settings.callback_after_calculation(parseFloat(value).toFixed(settings.decimals)));\n        }\n      }\n      function _initSettings() {\n        settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);\n        if (parseFloat(settings.step) !== 1) {\n          var remainder;\n\n          // Modify settings.max to be divisible by step\n          remainder = settings.max % settings.step;\n          if (remainder !== 0) {\n            settings.max = parseFloat(settings.max) - remainder;\n          }\n\n          // Do the same with min, should work with negative numbers too\n          remainder = settings.min % settings.step;\n          if (remainder !== 0) {\n            settings.min = parseFloat(settings.min) + (parseFloat(settings.step) - remainder);\n          }\n        }\n      }\n      function _parseAttributes() {\n        var data = {};\n\n        // Setting up based on data attributes\n        $.each(attributeMap, function (key, value) {\n          var attrName = 'bts-' + value + '';\n          if (originalinput.is('[data-' + attrName + ']')) {\n            data[key] = originalinput.data(attrName);\n          }\n        });\n\n        // Setting up based on input attributes if specified (input attributes have precedence)\n        $.each(['min', 'max', 'step'], function (i, key) {\n          if (originalinput.is('[' + key + ']')) {\n            if (data[key] !== undefined) {\n              console.warn('Both the \"data-bts-' + key + '\" data attribute and the \"' + key + '\" individual attribute were specified, the individual attribute will take precedence on: ', originalinput);\n            }\n            data[key] = originalinput.attr(key);\n          }\n        });\n        return data;\n      }\n      function _destroy() {\n        var $parent = originalinput.parent();\n        stopSpin();\n        originalinput.off('.touchspin');\n        if ($parent.hasClass('bootstrap-touchspin-injected')) {\n          originalinput.siblings().remove();\n          originalinput.unwrap();\n        } else {\n          $('.bootstrap-touchspin-injected', $parent).remove();\n          $parent.removeClass('bootstrap-touchspin');\n        }\n        originalinput.data('alreadyinitialized', false);\n      }\n      function _updateSettings(newsettings) {\n        settings = $.extend({}, settings, newsettings);\n\n        // Update postfix and prefix texts if those settings were changed.\n        if (newsettings.postfix) {\n          var $postfix = originalinput.parent().find('.bootstrap-touchspin-postfix');\n          if ($postfix.length === 0) {\n            _detached_postfix.insertAfter(originalinput);\n          }\n          originalinput.parent().find('.bootstrap-touchspin-postfix .input-group-text').text(newsettings.postfix);\n        }\n        if (newsettings.prefix) {\n          var $prefix = originalinput.parent().find('.bootstrap-touchspin-prefix');\n          if ($prefix.length === 0) {\n            _detached_prefix.insertBefore(originalinput);\n          }\n          originalinput.parent().find('.bootstrap-touchspin-prefix .input-group-text').text(newsettings.prefix);\n        }\n        _hideEmptyPrefixPostfix();\n      }\n      function _buildHtml() {\n        var initval = originalinput.val(),\n          parentelement = originalinput.parent();\n        if (initval !== '') {\n          // initval may not be parsable as a number (callback_after_calculation() may decorate it so it cant be parsed).  Use the callbacks if provided.\n          initval = settings.callback_before_calculation(initval);\n          initval = settings.callback_after_calculation(parseFloat(initval).toFixed(settings.decimals));\n        }\n        originalinput.data('initvalue', initval).val(initval);\n        originalinput.addClass('form-control');\n        verticalbuttons_html = \"\\n          <span class=\\\"input-group-addon bootstrap-touchspin-vertical-button-wrapper\\\">\\n            <span class=\\\"input-group-btn-vertical\\\">\\n              <button tabindex=\\\"-1\\\" class=\\\"\".concat(settings.buttondown_class, \" bootstrap-touchspin-up \").concat(settings.verticalupclass, \"\\\" type=\\\"button\\\">\").concat(settings.verticalup, \"</button>\\n              <button tabindex=\\\"-1\\\" class=\\\"\").concat(settings.buttonup_class, \" bootstrap-touchspin-down \").concat(settings.verticaldownclass, \"\\\" type=\\\"button\\\">\").concat(settings.verticaldown, \"</button>\\n            </span>\\n          </span>\\n       \");\n        if (parentelement.hasClass('input-group')) {\n          _advanceInputGroup(parentelement);\n        } else {\n          _buildInputGroup();\n        }\n      }\n      function _advanceInputGroup(parentelement) {\n        parentelement.addClass('bootstrap-touchspin');\n        var prev = originalinput.prev(),\n          next = originalinput.next();\n        var downhtml,\n          uphtml,\n          prefixhtml = \"\\n            <span class=\\\"input-group-addon input-group-prepend bootstrap-touchspin-prefix input-group-prepend bootstrap-touchspin-injected\\\">\\n              <span class=\\\"input-group-text\\\">\".concat(settings.prefix, \"</span>\\n            </span>\\n          \"),\n          postfixhtml = \"\\n            <span class=\\\"input-group-addon input-group-append bootstrap-touchspin-postfix input-group-append bootstrap-touchspin-injected\\\">\\n              <span class=\\\"input-group-text\\\">\".concat(settings.postfix, \"</span>\\n            </span>\\n          \");\n        if (settings.verticalbuttons) {\n          $(verticalbuttons_html).insertAfter(originalinput);\n        } else {\n          if (prev.hasClass('input-group-btn') || prev.hasClass('input-group-prepend')) {\n            downhtml = \"\\n              <button tabindex=\\\"-1\\\" class=\\\"\".concat(settings.buttondown_class, \" bootstrap-touchspin-down bootstrap-touchspin-injected\\\" type=\\\"button\\\">\").concat(settings.buttondown_txt, \"</button>\\n            \");\n            prev.append(downhtml);\n          } else {\n            downhtml = \"\\n              <span class=\\\"input-group-btn input-group-prepend bootstrap-touchspin-injected\\\">\\n                <button tabindex=\\\"-1\\\" class=\\\"\".concat(settings.buttondown_class, \" bootstrap-touchspin-down\\\" type=\\\"button\\\">\").concat(settings.buttondown_txt, \"</button>\\n              </span>\\n            \");\n            $(downhtml).insertBefore(originalinput);\n          }\n          if (next.hasClass('input-group-btn') || next.hasClass('input-group-append')) {\n            uphtml = \"\\n            <button tabindex=\\\"-1\\\" class=\\\"\".concat(settings.buttonup_class, \" bootstrap-touchspin-up bootstrap-touchspin-injected\\\" type=\\\"button\\\">\").concat(settings.buttonup_txt, \"</button>\\n          \");\n            next.prepend(uphtml);\n          } else {\n            uphtml = \"\\n            <span class=\\\"input-group-btn input-group-append bootstrap-touchspin-injected\\\">\\n              <button tabindex=\\\"-1\\\" class=\\\"\".concat(settings.buttonup_class, \" bootstrap-touchspin-up\\\" type=\\\"button\\\">\").concat(settings.buttonup_txt, \"</button>\\n            </span>\\n          \");\n            $(uphtml).insertAfter(originalinput);\n          }\n        }\n        $(prefixhtml).insertBefore(originalinput);\n        $(postfixhtml).insertAfter(originalinput);\n        container = parentelement;\n      }\n      function _buildInputGroup() {\n        var html;\n        var inputGroupSize = '';\n        if (originalinput.hasClass('input-sm') || originalinput.hasClass('form-control-sm')) {\n          inputGroupSize = 'input-group-sm';\n        } else if (originalinput.hasClass('input-lg') || originalinput.hasClass('form-control-lg')) {\n          inputGroupSize = 'input-group-lg';\n        }\n        if (settings.verticalbuttons) {\n          html = \"\\n            <div class=\\\"input-group \".concat(inputGroupSize, \" bootstrap-touchspin bootstrap-touchspin-injected\\\">\\n              <span class=\\\"input-group-addon input-group-prepend bootstrap-touchspin-prefix\\\">\\n                <span class=\\\"input-group-text\\\">\").concat(settings.prefix, \"</span>\\n              </span>\\n              <span class=\\\"input-group-addon bootstrap-touchspin-postfix input-group-append\\\">\\n                <span class=\\\"input-group-text\\\">\").concat(settings.postfix, \"</span>\\n              </span>\\n              \").concat(verticalbuttons_html, \"\\n            </div>\\n          \");\n        } else {\n          html = \"\\n            <div class=\\\"input-group bootstrap-touchspin bootstrap-touchspin-injected\\\">\\n              <span class=\\\"input-group-btn input-group-prepend\\\">\\n                <button tabindex=\\\"-1\\\" class=\\\"\".concat(settings.buttondown_class, \" bootstrap-touchspin-down\\\" type=\\\"button\\\">\").concat(settings.buttondown_txt, \"</button>\\n              </span>\\n              <span class=\\\"input-group-addon bootstrap-touchspin-prefix input-group-prepend\\\">\\n                <span class=\\\"input-group-text\\\">\").concat(settings.prefix, \"</span>\\n              </span>\\n              <span class=\\\"input-group-addon bootstrap-touchspin-postfix input-group-append\\\">\\n                <span class=\\\"input-group-text\\\">\").concat(settings.postfix, \"</span>\\n              </span>\\n              <span class=\\\"input-group-btn input-group-append\\\">\\n                <button tabindex=\\\"-1\\\" class=\\\"\").concat(settings.buttonup_class, \" bootstrap-touchspin-up\\\" type=\\\"button\\\">\").concat(settings.buttonup_txt, \"</button>\\n              </span>\\n            </div>\");\n        }\n        container = $(html).insertBefore(originalinput);\n        $('.bootstrap-touchspin-prefix', container).after(originalinput);\n        if (originalinput.hasClass('input-sm') || originalinput.hasClass('form-control-sm')) {\n          container.addClass('input-group-sm');\n        } else if (originalinput.hasClass('input-lg') || originalinput.hasClass('form-control-lg')) {\n          container.addClass('input-group-lg');\n        }\n      }\n      function _initElements() {\n        elements = {\n          down: $('.bootstrap-touchspin-down', container),\n          up: $('.bootstrap-touchspin-up', container),\n          input: $('input', container),\n          prefix: $('.bootstrap-touchspin-prefix', container).addClass(settings.prefix_extraclass),\n          postfix: $('.bootstrap-touchspin-postfix', container).addClass(settings.postfix_extraclass)\n        };\n      }\n      function _hideEmptyPrefixPostfix() {\n        if (settings.prefix === '') {\n          _detached_prefix = elements.prefix.detach();\n        }\n        if (settings.postfix === '') {\n          _detached_postfix = elements.postfix.detach();\n        }\n      }\n      function _bindEvents() {\n        originalinput.on('keydown.touchspin', function (ev) {\n          var code = ev.keyCode || ev.which;\n          if (code === 38) {\n            if (spinning !== 'up') {\n              upOnce();\n              startUpSpin();\n            }\n            ev.preventDefault();\n          } else if (code === 40) {\n            if (spinning !== 'down') {\n              downOnce();\n              startDownSpin();\n            }\n            ev.preventDefault();\n          } else if (code === 9 || code === 13) {\n            _checkValue();\n          }\n        });\n        originalinput.on('keyup.touchspin', function (ev) {\n          var code = ev.keyCode || ev.which;\n          if (code === 38) {\n            stopSpin();\n          } else if (code === 40) {\n            stopSpin();\n          }\n        });\n\n        // change is fired before blur, so we need to work around that\n        $(document).on('mousedown touchstart', function (event) {\n          if ($(event.target).is(originalinput)) {\n            return;\n          }\n          _checkValue();\n        });\n        originalinput.on('blur.touchspin', function () {\n          _checkValue();\n        });\n        elements.down.on('keydown', function (ev) {\n          var code = ev.keyCode || ev.which;\n          if (code === 32 || code === 13) {\n            if (spinning !== 'down') {\n              downOnce();\n              startDownSpin();\n            }\n            ev.preventDefault();\n          }\n        });\n        elements.down.on('keyup.touchspin', function (ev) {\n          var code = ev.keyCode || ev.which;\n          if (code === 32 || code === 13) {\n            stopSpin();\n          }\n        });\n        elements.up.on('keydown.touchspin', function (ev) {\n          var code = ev.keyCode || ev.which;\n          if (code === 32 || code === 13) {\n            if (spinning !== 'up') {\n              upOnce();\n              startUpSpin();\n            }\n            ev.preventDefault();\n          }\n        });\n        elements.up.on('keyup.touchspin', function (ev) {\n          var code = ev.keyCode || ev.which;\n          if (code === 32 || code === 13) {\n            stopSpin();\n          }\n        });\n        elements.down.on('mousedown.touchspin', function (ev) {\n          elements.down.off('touchstart.touchspin'); // android 4 workaround\n\n          if (originalinput.is(':disabled,[readonly]')) {\n            return;\n          }\n          downOnce();\n          startDownSpin();\n          ev.preventDefault();\n          ev.stopPropagation();\n        });\n        elements.down.on('touchstart.touchspin', function (ev) {\n          elements.down.off('mousedown.touchspin'); // android 4 workaround\n\n          if (originalinput.is(':disabled,[readonly]')) {\n            return;\n          }\n          downOnce();\n          startDownSpin();\n          ev.preventDefault();\n          ev.stopPropagation();\n        });\n        elements.up.on('mousedown.touchspin', function (ev) {\n          elements.up.off('touchstart.touchspin'); // android 4 workaround\n\n          if (originalinput.is(':disabled,[readonly]')) {\n            return;\n          }\n          upOnce();\n          startUpSpin();\n          ev.preventDefault();\n          ev.stopPropagation();\n        });\n        elements.up.on('touchstart.touchspin', function (ev) {\n          elements.up.off('mousedown.touchspin'); // android 4 workaround\n\n          if (originalinput.is(':disabled,[readonly]')) {\n            return;\n          }\n          upOnce();\n          startUpSpin();\n          ev.preventDefault();\n          ev.stopPropagation();\n        });\n        elements.up.on('mouseup.touchspin mouseout.touchspin touchleave.touchspin touchend.touchspin touchcancel.touchspin', function (ev) {\n          if (!spinning) {\n            return;\n          }\n          ev.stopPropagation();\n          stopSpin();\n        });\n        elements.down.on('mouseup.touchspin mouseout.touchspin touchleave.touchspin touchend.touchspin touchcancel.touchspin', function (ev) {\n          if (!spinning) {\n            return;\n          }\n          ev.stopPropagation();\n          stopSpin();\n        });\n        elements.down.on('mousemove.touchspin touchmove.touchspin', function (ev) {\n          if (!spinning) {\n            return;\n          }\n          ev.stopPropagation();\n          ev.preventDefault();\n        });\n        elements.up.on('mousemove.touchspin touchmove.touchspin', function (ev) {\n          if (!spinning) {\n            return;\n          }\n          ev.stopPropagation();\n          ev.preventDefault();\n        });\n        originalinput.on('mousewheel.touchspin DOMMouseScroll.touchspin', function (ev) {\n          if (!settings.mousewheel || !originalinput.is(':focus')) {\n            return;\n          }\n          var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;\n          ev.stopPropagation();\n          ev.preventDefault();\n          if (delta < 0) {\n            downOnce();\n          } else {\n            upOnce();\n          }\n        });\n      }\n      function _bindEventsInterface() {\n        originalinput.on('touchspin.destroy', function () {\n          _destroy();\n        });\n        originalinput.on('touchspin.uponce', function () {\n          stopSpin();\n          upOnce();\n        });\n        originalinput.on('touchspin.downonce', function () {\n          stopSpin();\n          downOnce();\n        });\n        originalinput.on('touchspin.startupspin', function () {\n          startUpSpin();\n        });\n        originalinput.on('touchspin.startdownspin', function () {\n          startDownSpin();\n        });\n        originalinput.on('touchspin.stopspin', function () {\n          stopSpin();\n        });\n        originalinput.on('touchspin.updatesettings', function (e, newsettings) {\n          changeSettings(newsettings);\n        });\n      }\n      function _setupMutationObservers() {\n        if (typeof MutationObserver !== 'undefined') {\n          // MutationObserver is available\n          var observer = new MutationObserver(function (mutations) {\n            mutations.forEach(function (mutation) {\n              if (mutation.type === 'attributes' && (mutation.attributeName === 'disabled' || mutation.attributeName === 'readonly')) {\n                _updateButtonDisabledState();\n              }\n            });\n          });\n          observer.observe(originalinput[0], {\n            attributes: true\n          });\n        }\n      }\n      function _forcestepdivisibility(value) {\n        switch (settings.forcestepdivisibility) {\n          case 'round':\n            return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);\n          case 'floor':\n            return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);\n          case 'ceil':\n            return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);\n          default:\n            return value.toFixed(settings.decimals);\n        }\n      }\n      function _checkValue() {\n        var val, parsedval, returnval;\n        val = settings.callback_before_calculation(originalinput.val());\n        if (val === '') {\n          if (settings.replacementval !== '') {\n            originalinput.val(settings.replacementval);\n            originalinput.trigger('change');\n          }\n          return;\n        }\n        if (settings.decimals > 0 && val === '.') {\n          return;\n        }\n        parsedval = parseFloat(val);\n        if (isNaN(parsedval)) {\n          if (settings.replacementval !== '') {\n            parsedval = settings.replacementval;\n          } else {\n            parsedval = 0;\n          }\n        }\n        returnval = parsedval;\n        if (parsedval.toString() !== val) {\n          returnval = parsedval;\n        }\n        returnval = _forcestepdivisibility(parsedval);\n        if (settings.min !== null && parsedval < settings.min) {\n          returnval = settings.min;\n        }\n        if (settings.max !== null && parsedval > settings.max) {\n          returnval = settings.max;\n        }\n        if (parseFloat(parsedval).toString() !== parseFloat(returnval).toString()) {\n          originalinput.val(returnval);\n        }\n        originalinput.val(settings.callback_after_calculation(parseFloat(returnval).toFixed(settings.decimals)));\n      }\n      function _getBoostedStep() {\n        if (!settings.booster) {\n          return settings.step;\n        } else {\n          var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;\n          if (settings.maxboostedstep) {\n            if (boosted > settings.maxboostedstep) {\n              boosted = settings.maxboostedstep;\n              value = Math.round(value / boosted) * boosted;\n            }\n          }\n          return Math.max(settings.step, boosted);\n        }\n      }\n      function valueIfIsNaN() {\n        if (typeof settings.firstclickvalueifempty === 'number') {\n          return settings.firstclickvalueifempty;\n        } else {\n          return (settings.min + settings.max) / 2;\n        }\n      }\n      function _updateButtonDisabledState() {\n        var isDisabled = originalinput.is(':disabled,[readonly]');\n        elements.up.prop('disabled', isDisabled);\n        elements.down.prop('disabled', isDisabled);\n        if (isDisabled) {\n          stopSpin();\n        }\n      }\n      function upOnce() {\n        if (originalinput.is(':disabled,[readonly]')) {\n          return;\n        }\n        _checkValue();\n        value = parseFloat(settings.callback_before_calculation(elements.input.val()));\n        var initvalue = value;\n        var boostedstep;\n        if (isNaN(value)) {\n          value = valueIfIsNaN();\n        } else {\n          boostedstep = _getBoostedStep();\n          value = value + boostedstep;\n        }\n        if (settings.max !== null && value >= settings.max) {\n          value = settings.max;\n          originalinput.trigger('touchspin.on.max');\n          stopSpin();\n        }\n        elements.input.val(settings.callback_after_calculation(parseFloat(value).toFixed(settings.decimals)));\n        if (initvalue !== value) {\n          originalinput.trigger('change');\n        }\n      }\n      function downOnce() {\n        if (originalinput.is(':disabled,[readonly]')) {\n          return;\n        }\n        _checkValue();\n        value = parseFloat(settings.callback_before_calculation(elements.input.val()));\n        var initvalue = value;\n        var boostedstep;\n        if (isNaN(value)) {\n          value = valueIfIsNaN();\n        } else {\n          boostedstep = _getBoostedStep();\n          value = value - boostedstep;\n        }\n        if (settings.min !== null && value <= settings.min) {\n          value = settings.min;\n          originalinput.trigger('touchspin.on.min');\n          stopSpin();\n        }\n        elements.input.val(settings.callback_after_calculation(parseFloat(value).toFixed(settings.decimals)));\n        if (initvalue !== value) {\n          originalinput.trigger('change');\n        }\n      }\n      function startDownSpin() {\n        if (originalinput.is(':disabled,[readonly]')) {\n          return;\n        }\n        stopSpin();\n        spincount = 0;\n        spinning = 'down';\n        originalinput.trigger('touchspin.on.startspin');\n        originalinput.trigger('touchspin.on.startdownspin');\n        downDelayTimeout = setTimeout(function () {\n          downSpinTimer = setInterval(function () {\n            spincount++;\n            downOnce();\n          }, settings.stepinterval);\n        }, settings.stepintervaldelay);\n      }\n      function startUpSpin() {\n        if (originalinput.is(':disabled,[readonly]')) {\n          return;\n        }\n        stopSpin();\n        spincount = 0;\n        spinning = 'up';\n        originalinput.trigger('touchspin.on.startspin');\n        originalinput.trigger('touchspin.on.startupspin');\n        upDelayTimeout = setTimeout(function () {\n          upSpinTimer = setInterval(function () {\n            spincount++;\n            upOnce();\n          }, settings.stepinterval);\n        }, settings.stepintervaldelay);\n      }\n      function stopSpin() {\n        clearTimeout(downDelayTimeout);\n        clearTimeout(upDelayTimeout);\n        clearInterval(downSpinTimer);\n        clearInterval(upSpinTimer);\n        switch (spinning) {\n          case 'up':\n            originalinput.trigger('touchspin.on.stopupspin');\n            originalinput.trigger('touchspin.on.stopspin');\n            break;\n          case 'down':\n            originalinput.trigger('touchspin.on.stopdownspin');\n            originalinput.trigger('touchspin.on.stopspin');\n            break;\n        }\n        spincount = 0;\n        spinning = false;\n      }\n    });\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAtdG91Y2hzcGluL2Rpc3QvanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uanM/YWNlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIF90eXBlb2Yob2JqKTtcbn1cbi8qXHJcbiAqICBCb290c3RyYXAgVG91Y2hzcGluIC0gdjQuNy4zXHJcbiAqICBBIG1vYmlsZSBhbmQgdG91Y2ggZnJpZW5kbHkgaW5wdXQgc3Bpbm5lciBjb21wb25lbnQgZm9yIEJvb3RzdHJhcCAzICYgNC5cclxuICogIGh0dHBzOi8vd3d3LnZpcnR1b3NvZnQuZXUvY29kZS9ib290c3RyYXAtdG91Y2hzcGluL1xyXG4gKlxyXG4gKiAgTWFkZSBieSBJc3R2w6FuIFVqai1Nw6lzesOhcm9zXHJcbiAqICBVbmRlciBNSVQgTGljZW5zZVxyXG4gKi9cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgbW9kdWxlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobW9kdWxlKSkgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgalF1ZXJ5KSB7XG4gICAgICBpZiAoalF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jykocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZhY3RvcnkoalF1ZXJ5KTtcbiAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5KGpRdWVyeSk7XG4gIH1cbn0pKGZ1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2N1cnJlbnRTcGlubmVySWQgPSAwO1xuICAkLmZuLlRvdWNoU3BpbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgbWluOiAwLFxuICAgICAgLy8gSWYgbnVsbCwgdGhlcmUgaXMgbm8gbWluaW11bSBlbmZvcmNlZFxuICAgICAgbWF4OiAxMDAsXG4gICAgICAvLyBJZiBudWxsLCB0aGVyZSBpcyBubyBtYXhpbXVtIGVuZm9yY2VkXG4gICAgICBpbml0dmFsOiAnJyxcbiAgICAgIHJlcGxhY2VtZW50dmFsOiAnJyxcbiAgICAgIGZpcnN0Y2xpY2t2YWx1ZWlmZW1wdHk6IG51bGwsXG4gICAgICBzdGVwOiAxLFxuICAgICAgZGVjaW1hbHM6IDAsXG4gICAgICBzdGVwaW50ZXJ2YWw6IDEwMCxcbiAgICAgIGZvcmNlc3RlcGRpdmlzaWJpbGl0eTogJ3JvdW5kJyxcbiAgICAgIC8vIG5vbmUgfCBmbG9vciB8IHJvdW5kIHwgY2VpbFxuICAgICAgc3RlcGludGVydmFsZGVsYXk6IDUwMCxcbiAgICAgIHZlcnRpY2FsYnV0dG9uczogZmFsc2UsXG4gICAgICB2ZXJ0aWNhbHVwOiAnJnBsdXM7JyxcbiAgICAgIHZlcnRpY2FsZG93bjogJyZtaW51czsnLFxuICAgICAgdmVydGljYWx1cGNsYXNzOiAnJyxcbiAgICAgIHZlcnRpY2FsZG93bmNsYXNzOiAnJyxcbiAgICAgIHByZWZpeDogJycsXG4gICAgICBwb3N0Zml4OiAnJyxcbiAgICAgIHByZWZpeF9leHRyYWNsYXNzOiAnJyxcbiAgICAgIHBvc3RmaXhfZXh0cmFjbGFzczogJycsXG4gICAgICBib29zdGVyOiB0cnVlLFxuICAgICAgYm9vc3RhdDogMTAsXG4gICAgICBtYXhib29zdGVkc3RlcDogZmFsc2UsXG4gICAgICBtb3VzZXdoZWVsOiB0cnVlLFxuICAgICAgYnV0dG9uZG93bl9jbGFzczogJ2J0biBidG4tcHJpbWFyeScsXG4gICAgICBidXR0b251cF9jbGFzczogJ2J0biBidG4tcHJpbWFyeScsXG4gICAgICBidXR0b25kb3duX3R4dDogJyZtaW51czsnLFxuICAgICAgYnV0dG9udXBfdHh0OiAnJnBsdXM7JyxcbiAgICAgIGNhbGxiYWNrX2JlZm9yZV9jYWxjdWxhdGlvbjogZnVuY3Rpb24gY2FsbGJhY2tfYmVmb3JlX2NhbGN1bGF0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFja19hZnRlcl9jYWxjdWxhdGlvbjogZnVuY3Rpb24gY2FsbGJhY2tfYWZ0ZXJfY2FsY3VsYXRpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGF0dHJpYnV0ZU1hcCA9IHtcbiAgICAgIG1pbjogJ21pbicsXG4gICAgICBtYXg6ICdtYXgnLFxuICAgICAgaW5pdHZhbDogJ2luaXQtdmFsJyxcbiAgICAgIHJlcGxhY2VtZW50dmFsOiAncmVwbGFjZW1lbnQtdmFsJyxcbiAgICAgIGZpcnN0Y2xpY2t2YWx1ZWlmZW1wdHk6ICdmaXJzdC1jbGljay12YWx1ZS1pZi1lbXB0eScsXG4gICAgICBzdGVwOiAnc3RlcCcsXG4gICAgICBkZWNpbWFsczogJ2RlY2ltYWxzJyxcbiAgICAgIHN0ZXBpbnRlcnZhbDogJ3N0ZXAtaW50ZXJ2YWwnLFxuICAgICAgdmVydGljYWxidXR0b25zOiAndmVydGljYWwtYnV0dG9ucycsXG4gICAgICB2ZXJ0aWNhbHVwY2xhc3M6ICd2ZXJ0aWNhbC11cC1jbGFzcycsXG4gICAgICB2ZXJ0aWNhbGRvd25jbGFzczogJ3ZlcnRpY2FsLWRvd24tY2xhc3MnLFxuICAgICAgZm9yY2VzdGVwZGl2aXNpYmlsaXR5OiAnZm9yY2Utc3RlcC1kaXZpc2liaWxpdHknLFxuICAgICAgc3RlcGludGVydmFsZGVsYXk6ICdzdGVwLWludGVydmFsLWRlbGF5JyxcbiAgICAgIHByZWZpeDogJ3ByZWZpeCcsXG4gICAgICBwb3N0Zml4OiAncG9zdGZpeCcsXG4gICAgICBwcmVmaXhfZXh0cmFjbGFzczogJ3ByZWZpeC1leHRyYS1jbGFzcycsXG4gICAgICBwb3N0Zml4X2V4dHJhY2xhc3M6ICdwb3N0Zml4LWV4dHJhLWNsYXNzJyxcbiAgICAgIGJvb3N0ZXI6ICdib29zdGVyJyxcbiAgICAgIGJvb3N0YXQ6ICdib29zdGF0JyxcbiAgICAgIG1heGJvb3N0ZWRzdGVwOiAnbWF4LWJvb3N0ZWQtc3RlcCcsXG4gICAgICBtb3VzZXdoZWVsOiAnbW91c2Utd2hlZWwnLFxuICAgICAgYnV0dG9uZG93bl9jbGFzczogJ2J1dHRvbi1kb3duLWNsYXNzJyxcbiAgICAgIGJ1dHRvbnVwX2NsYXNzOiAnYnV0dG9uLXVwLWNsYXNzJyxcbiAgICAgIGJ1dHRvbmRvd25fdHh0OiAnYnV0dG9uLWRvd24tdHh0JyxcbiAgICAgIGJ1dHRvbnVwX3R4dDogJ2J1dHRvbi11cC10eHQnXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZXR0aW5ncyxcbiAgICAgICAgb3JpZ2luYWxpbnB1dCA9ICQodGhpcyksXG4gICAgICAgIG9yaWdpbmFsaW5wdXRfZGF0YSA9IG9yaWdpbmFsaW5wdXQuZGF0YSgpLFxuICAgICAgICBfZGV0YWNoZWRfcHJlZml4LFxuICAgICAgICBfZGV0YWNoZWRfcG9zdGZpeCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgdmVydGljYWxidXR0b25zX2h0bWwsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb3duU3BpblRpbWVyLFxuICAgICAgICB1cFNwaW5UaW1lcixcbiAgICAgICAgZG93bkRlbGF5VGltZW91dCxcbiAgICAgICAgdXBEZWxheVRpbWVvdXQsXG4gICAgICAgIHNwaW5jb3VudCA9IDAsXG4gICAgICAgIHNwaW5uaW5nID0gZmFsc2U7XG4gICAgICBpbml0KCk7XG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5kYXRhKCdhbHJlYWR5aW5pdGlhbGl6ZWQnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcmlnaW5hbGlucHV0LmRhdGEoJ2FscmVhZHlpbml0aWFsaXplZCcsIHRydWUpO1xuICAgICAgICBfY3VycmVudFNwaW5uZXJJZCArPSAxO1xuICAgICAgICBvcmlnaW5hbGlucHV0LmRhdGEoJ3NwaW5uZXJpZCcsIF9jdXJyZW50U3Bpbm5lcklkKTtcbiAgICAgICAgaWYgKCFvcmlnaW5hbGlucHV0LmlzKCdpbnB1dCcpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ011c3QgYmUgYW4gaW5wdXQuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9pbml0U2V0dGluZ3MoKTtcbiAgICAgICAgX3NldEluaXR2YWwoKTtcbiAgICAgICAgX2NoZWNrVmFsdWUoKTtcbiAgICAgICAgX2J1aWxkSHRtbCgpO1xuICAgICAgICBfaW5pdEVsZW1lbnRzKCk7XG4gICAgICAgIF91cGRhdGVCdXR0b25EaXNhYmxlZFN0YXRlKCk7XG4gICAgICAgIF9oaWRlRW1wdHlQcmVmaXhQb3N0Zml4KCk7XG4gICAgICAgIF9zZXR1cE11dGF0aW9uT2JzZXJ2ZXJzKCk7XG4gICAgICAgIF9iaW5kRXZlbnRzKCk7XG4gICAgICAgIF9iaW5kRXZlbnRzSW50ZXJmYWNlKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfc2V0SW5pdHZhbCgpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmluaXR2YWwgIT09ICcnICYmIG9yaWdpbmFsaW5wdXQudmFsKCkgPT09ICcnKSB7XG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC52YWwoc2V0dGluZ3MuaW5pdHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNoYW5nZVNldHRpbmdzKG5ld3NldHRpbmdzKSB7XG4gICAgICAgIF91cGRhdGVTZXR0aW5ncyhuZXdzZXR0aW5ncyk7XG4gICAgICAgIF9jaGVja1ZhbHVlKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnRzLmlucHV0LnZhbCgpO1xuICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHNldHRpbmdzLmNhbGxiYWNrX2JlZm9yZV9jYWxjdWxhdGlvbihlbGVtZW50cy5pbnB1dC52YWwoKSkpO1xuICAgICAgICAgIGVsZW1lbnRzLmlucHV0LnZhbChzZXR0aW5ncy5jYWxsYmFja19hZnRlcl9jYWxjdWxhdGlvbihwYXJzZUZsb2F0KHZhbHVlKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfaW5pdFNldHRpbmdzKCkge1xuICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3JpZ2luYWxpbnB1dF9kYXRhLCBfcGFyc2VBdHRyaWJ1dGVzKCksIG9wdGlvbnMpO1xuICAgICAgICBpZiAocGFyc2VGbG9hdChzZXR0aW5ncy5zdGVwKSAhPT0gMSkge1xuICAgICAgICAgIHZhciByZW1haW5kZXI7XG5cbiAgICAgICAgICAvLyBNb2RpZnkgc2V0dGluZ3MubWF4IHRvIGJlIGRpdmlzaWJsZSBieSBzdGVwXG4gICAgICAgICAgcmVtYWluZGVyID0gc2V0dGluZ3MubWF4ICUgc2V0dGluZ3Muc3RlcDtcbiAgICAgICAgICBpZiAocmVtYWluZGVyICE9PSAwKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXggPSBwYXJzZUZsb2F0KHNldHRpbmdzLm1heCkgLSByZW1haW5kZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRG8gdGhlIHNhbWUgd2l0aCBtaW4sIHNob3VsZCB3b3JrIHdpdGggbmVnYXRpdmUgbnVtYmVycyB0b29cbiAgICAgICAgICByZW1haW5kZXIgPSBzZXR0aW5ncy5taW4gJSBzZXR0aW5ncy5zdGVwO1xuICAgICAgICAgIGlmIChyZW1haW5kZXIgIT09IDApIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm1pbiA9IHBhcnNlRmxvYXQoc2V0dGluZ3MubWluKSArIChwYXJzZUZsb2F0KHNldHRpbmdzLnN0ZXApIC0gcmVtYWluZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9wYXJzZUF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgICAgLy8gU2V0dGluZyB1cCBiYXNlZCBvbiBkYXRhIGF0dHJpYnV0ZXNcbiAgICAgICAgJC5lYWNoKGF0dHJpYnV0ZU1hcCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAnYnRzLScgKyB2YWx1ZSArICcnO1xuICAgICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmlzKCdbZGF0YS0nICsgYXR0ck5hbWUgKyAnXScpKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSBvcmlnaW5hbGlucHV0LmRhdGEoYXR0ck5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0dGluZyB1cCBiYXNlZCBvbiBpbnB1dCBhdHRyaWJ1dGVzIGlmIHNwZWNpZmllZCAoaW5wdXQgYXR0cmlidXRlcyBoYXZlIHByZWNlZGVuY2UpXG4gICAgICAgICQuZWFjaChbJ21pbicsICdtYXgnLCAnc3RlcCddLCBmdW5jdGlvbiAoaSwga2V5KSB7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJ1snICsga2V5ICsgJ10nKSkge1xuICAgICAgICAgICAgaWYgKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignQm90aCB0aGUgXCJkYXRhLWJ0cy0nICsga2V5ICsgJ1wiIGRhdGEgYXR0cmlidXRlIGFuZCB0aGUgXCInICsga2V5ICsgJ1wiIGluZGl2aWR1YWwgYXR0cmlidXRlIHdlcmUgc3BlY2lmaWVkLCB0aGUgaW5kaXZpZHVhbCBhdHRyaWJ1dGUgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb246ICcsIG9yaWdpbmFsaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVtrZXldID0gb3JpZ2luYWxpbnB1dC5hdHRyKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgICAgdmFyICRwYXJlbnQgPSBvcmlnaW5hbGlucHV0LnBhcmVudCgpO1xuICAgICAgICBzdG9wU3BpbigpO1xuICAgICAgICBvcmlnaW5hbGlucHV0Lm9mZignLnRvdWNoc3BpbicpO1xuICAgICAgICBpZiAoJHBhcmVudC5oYXNDbGFzcygnYm9vdHN0cmFwLXRvdWNoc3Bpbi1pbmplY3RlZCcpKSB7XG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC5zaWJsaW5ncygpLnJlbW92ZSgpO1xuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudW53cmFwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCgnLmJvb3RzdHJhcC10b3VjaHNwaW4taW5qZWN0ZWQnLCAkcGFyZW50KS5yZW1vdmUoKTtcbiAgICAgICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdib290c3RyYXAtdG91Y2hzcGluJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ2luYWxpbnB1dC5kYXRhKCdhbHJlYWR5aW5pdGlhbGl6ZWQnLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdXBkYXRlU2V0dGluZ3MobmV3c2V0dGluZ3MpIHtcbiAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgc2V0dGluZ3MsIG5ld3NldHRpbmdzKTtcblxuICAgICAgICAvLyBVcGRhdGUgcG9zdGZpeCBhbmQgcHJlZml4IHRleHRzIGlmIHRob3NlIHNldHRpbmdzIHdlcmUgY2hhbmdlZC5cbiAgICAgICAgaWYgKG5ld3NldHRpbmdzLnBvc3RmaXgpIHtcbiAgICAgICAgICB2YXIgJHBvc3RmaXggPSBvcmlnaW5hbGlucHV0LnBhcmVudCgpLmZpbmQoJy5ib290c3RyYXAtdG91Y2hzcGluLXBvc3RmaXgnKTtcbiAgICAgICAgICBpZiAoJHBvc3RmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBfZGV0YWNoZWRfcG9zdGZpeC5pbnNlcnRBZnRlcihvcmlnaW5hbGlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC5wYXJlbnQoKS5maW5kKCcuYm9vdHN0cmFwLXRvdWNoc3Bpbi1wb3N0Zml4IC5pbnB1dC1ncm91cC10ZXh0JykudGV4dChuZXdzZXR0aW5ncy5wb3N0Zml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3c2V0dGluZ3MucHJlZml4KSB7XG4gICAgICAgICAgdmFyICRwcmVmaXggPSBvcmlnaW5hbGlucHV0LnBhcmVudCgpLmZpbmQoJy5ib290c3RyYXAtdG91Y2hzcGluLXByZWZpeCcpO1xuICAgICAgICAgIGlmICgkcHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgX2RldGFjaGVkX3ByZWZpeC5pbnNlcnRCZWZvcmUob3JpZ2luYWxpbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQucGFyZW50KCkuZmluZCgnLmJvb3RzdHJhcC10b3VjaHNwaW4tcHJlZml4IC5pbnB1dC1ncm91cC10ZXh0JykudGV4dChuZXdzZXR0aW5ncy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIF9oaWRlRW1wdHlQcmVmaXhQb3N0Zml4KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfYnVpbGRIdG1sKCkge1xuICAgICAgICB2YXIgaW5pdHZhbCA9IG9yaWdpbmFsaW5wdXQudmFsKCksXG4gICAgICAgICAgcGFyZW50ZWxlbWVudCA9IG9yaWdpbmFsaW5wdXQucGFyZW50KCk7XG4gICAgICAgIGlmIChpbml0dmFsICE9PSAnJykge1xuICAgICAgICAgIC8vIGluaXR2YWwgbWF5IG5vdCBiZSBwYXJzYWJsZSBhcyBhIG51bWJlciAoY2FsbGJhY2tfYWZ0ZXJfY2FsY3VsYXRpb24oKSBtYXkgZGVjb3JhdGUgaXQgc28gaXQgY2FudCBiZSBwYXJzZWQpLiAgVXNlIHRoZSBjYWxsYmFja3MgaWYgcHJvdmlkZWQuXG4gICAgICAgICAgaW5pdHZhbCA9IHNldHRpbmdzLmNhbGxiYWNrX2JlZm9yZV9jYWxjdWxhdGlvbihpbml0dmFsKTtcbiAgICAgICAgICBpbml0dmFsID0gc2V0dGluZ3MuY2FsbGJhY2tfYWZ0ZXJfY2FsY3VsYXRpb24ocGFyc2VGbG9hdChpbml0dmFsKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ2luYWxpbnB1dC5kYXRhKCdpbml0dmFsdWUnLCBpbml0dmFsKS52YWwoaW5pdHZhbCk7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICB2ZXJ0aWNhbGJ1dHRvbnNfaHRtbCA9IFwiXFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXZlcnRpY2FsLWJ1dHRvbi13cmFwcGVyXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuLXZlcnRpY2FsXFxcIj5cXG4gICAgICAgICAgICAgIDxidXR0b24gdGFiaW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwiXCIuY29uY2F0KHNldHRpbmdzLmJ1dHRvbmRvd25fY2xhc3MsIFwiIGJvb3RzdHJhcC10b3VjaHNwaW4tdXAgXCIpLmNvbmNhdChzZXR0aW5ncy52ZXJ0aWNhbHVwY2xhc3MsIFwiXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlwiKS5jb25jYXQoc2V0dGluZ3MudmVydGljYWx1cCwgXCI8L2J1dHRvbj5cXG4gICAgICAgICAgICAgIDxidXR0b24gdGFiaW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzZXR0aW5ncy5idXR0b251cF9jbGFzcywgXCIgYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duIFwiKS5jb25jYXQoc2V0dGluZ3MudmVydGljYWxkb3duY2xhc3MsIFwiXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlwiKS5jb25jYXQoc2V0dGluZ3MudmVydGljYWxkb3duLCBcIjwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgPC9zcGFuPlxcbiAgICAgICBcIik7XG4gICAgICAgIGlmIChwYXJlbnRlbGVtZW50Lmhhc0NsYXNzKCdpbnB1dC1ncm91cCcpKSB7XG4gICAgICAgICAgX2FkdmFuY2VJbnB1dEdyb3VwKHBhcmVudGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9idWlsZElucHV0R3JvdXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2FkdmFuY2VJbnB1dEdyb3VwKHBhcmVudGVsZW1lbnQpIHtcbiAgICAgICAgcGFyZW50ZWxlbWVudC5hZGRDbGFzcygnYm9vdHN0cmFwLXRvdWNoc3BpbicpO1xuICAgICAgICB2YXIgcHJldiA9IG9yaWdpbmFsaW5wdXQucHJldigpLFxuICAgICAgICAgIG5leHQgPSBvcmlnaW5hbGlucHV0Lm5leHQoKTtcbiAgICAgICAgdmFyIGRvd25odG1sLFxuICAgICAgICAgIHVwaHRtbCxcbiAgICAgICAgICBwcmVmaXhodG1sID0gXCJcXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb24gaW5wdXQtZ3JvdXAtcHJlcGVuZCBib290c3RyYXAtdG91Y2hzcGluLXByZWZpeCBpbnB1dC1ncm91cC1wcmVwZW5kIGJvb3RzdHJhcC10b3VjaHNwaW4taW5qZWN0ZWRcXFwiPlxcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLXRleHRcXFwiPlwiLmNvbmNhdChzZXR0aW5ncy5wcmVmaXgsIFwiPC9zcGFuPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgXCIpLFxuICAgICAgICAgIHBvc3RmaXhodG1sID0gXCJcXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb24gaW5wdXQtZ3JvdXAtYXBwZW5kIGJvb3RzdHJhcC10b3VjaHNwaW4tcG9zdGZpeCBpbnB1dC1ncm91cC1hcHBlbmQgYm9vdHN0cmFwLXRvdWNoc3Bpbi1pbmplY3RlZFxcXCI+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtdGV4dFxcXCI+XCIuY29uY2F0KHNldHRpbmdzLnBvc3RmaXgsIFwiPC9zcGFuPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgXCIpO1xuICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxidXR0b25zKSB7XG4gICAgICAgICAgJCh2ZXJ0aWNhbGJ1dHRvbnNfaHRtbCkuaW5zZXJ0QWZ0ZXIob3JpZ2luYWxpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXYuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwLWJ0bicpIHx8IHByZXYuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwLXByZXBlbmQnKSkge1xuICAgICAgICAgICAgZG93bmh0bWwgPSBcIlxcbiAgICAgICAgICAgICAgPGJ1dHRvbiB0YWJpbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJcIi5jb25jYXQoc2V0dGluZ3MuYnV0dG9uZG93bl9jbGFzcywgXCIgYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duIGJvb3RzdHJhcC10b3VjaHNwaW4taW5qZWN0ZWRcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+XCIpLmNvbmNhdChzZXR0aW5ncy5idXR0b25kb3duX3R4dCwgXCI8L2J1dHRvbj5cXG4gICAgICAgICAgICBcIik7XG4gICAgICAgICAgICBwcmV2LmFwcGVuZChkb3duaHRtbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvd25odG1sID0gXCJcXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG4gaW5wdXQtZ3JvdXAtcHJlcGVuZCBib290c3RyYXAtdG91Y2hzcGluLWluamVjdGVkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0YWJpbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJcIi5jb25jYXQoc2V0dGluZ3MuYnV0dG9uZG93bl9jbGFzcywgXCIgYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlwiKS5jb25jYXQoc2V0dGluZ3MuYnV0dG9uZG93bl90eHQsIFwiPC9idXR0b24+XFxuICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgXCIpO1xuICAgICAgICAgICAgJChkb3duaHRtbCkuaW5zZXJ0QmVmb3JlKG9yaWdpbmFsaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dC5oYXNDbGFzcygnaW5wdXQtZ3JvdXAtYnRuJykgfHwgbmV4dC5oYXNDbGFzcygnaW5wdXQtZ3JvdXAtYXBwZW5kJykpIHtcbiAgICAgICAgICAgIHVwaHRtbCA9IFwiXFxuICAgICAgICAgICAgPGJ1dHRvbiB0YWJpbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJcIi5jb25jYXQoc2V0dGluZ3MuYnV0dG9udXBfY2xhc3MsIFwiIGJvb3RzdHJhcC10b3VjaHNwaW4tdXAgYm9vdHN0cmFwLXRvdWNoc3Bpbi1pbmplY3RlZFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIikuY29uY2F0KHNldHRpbmdzLmJ1dHRvbnVwX3R4dCwgXCI8L2J1dHRvbj5cXG4gICAgICAgICAgXCIpO1xuICAgICAgICAgICAgbmV4dC5wcmVwZW5kKHVwaHRtbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwaHRtbCA9IFwiXFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0biBpbnB1dC1ncm91cC1hcHBlbmQgYm9vdHN0cmFwLXRvdWNoc3Bpbi1pbmplY3RlZFxcXCI+XFxuICAgICAgICAgICAgICA8YnV0dG9uIHRhYmluZGV4PVxcXCItMVxcXCIgY2xhc3M9XFxcIlwiLmNvbmNhdChzZXR0aW5ncy5idXR0b251cF9jbGFzcywgXCIgYm9vdHN0cmFwLXRvdWNoc3Bpbi11cFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIikuY29uY2F0KHNldHRpbmdzLmJ1dHRvbnVwX3R4dCwgXCI8L2J1dHRvbj5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIFwiKTtcbiAgICAgICAgICAgICQodXBodG1sKS5pbnNlcnRBZnRlcihvcmlnaW5hbGlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJChwcmVmaXhodG1sKS5pbnNlcnRCZWZvcmUob3JpZ2luYWxpbnB1dCk7XG4gICAgICAgICQocG9zdGZpeGh0bWwpLmluc2VydEFmdGVyKG9yaWdpbmFsaW5wdXQpO1xuICAgICAgICBjb250YWluZXIgPSBwYXJlbnRlbGVtZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2J1aWxkSW5wdXRHcm91cCgpIHtcbiAgICAgICAgdmFyIGh0bWw7XG4gICAgICAgIHZhciBpbnB1dEdyb3VwU2l6ZSA9ICcnO1xuICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5oYXNDbGFzcygnaW5wdXQtc20nKSB8fCBvcmlnaW5hbGlucHV0Lmhhc0NsYXNzKCdmb3JtLWNvbnRyb2wtc20nKSkge1xuICAgICAgICAgIGlucHV0R3JvdXBTaXplID0gJ2lucHV0LWdyb3VwLXNtJztcbiAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbGlucHV0Lmhhc0NsYXNzKCdpbnB1dC1sZycpIHx8IG9yaWdpbmFsaW5wdXQuaGFzQ2xhc3MoJ2Zvcm0tY29udHJvbC1sZycpKSB7XG4gICAgICAgICAgaW5wdXRHcm91cFNpemUgPSAnaW5wdXQtZ3JvdXAtbGcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy52ZXJ0aWNhbGJ1dHRvbnMpIHtcbiAgICAgICAgICBodG1sID0gXCJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cCBcIi5jb25jYXQoaW5wdXRHcm91cFNpemUsIFwiIGJvb3RzdHJhcC10b3VjaHNwaW4gYm9vdHN0cmFwLXRvdWNoc3Bpbi1pbmplY3RlZFxcXCI+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb24gaW5wdXQtZ3JvdXAtcHJlcGVuZCBib290c3RyYXAtdG91Y2hzcGluLXByZWZpeFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC10ZXh0XFxcIj5cIikuY29uY2F0KHNldHRpbmdzLnByZWZpeCwgXCI8L3NwYW4+XFxuICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb24gYm9vdHN0cmFwLXRvdWNoc3Bpbi1wb3N0Zml4IGlucHV0LWdyb3VwLWFwcGVuZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC10ZXh0XFxcIj5cIikuY29uY2F0KHNldHRpbmdzLnBvc3RmaXgsIFwiPC9zcGFuPlxcbiAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgXCIpLmNvbmNhdCh2ZXJ0aWNhbGJ1dHRvbnNfaHRtbCwgXCJcXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGh0bWwgPSBcIlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwIGJvb3RzdHJhcC10b3VjaHNwaW4gYm9vdHN0cmFwLXRvdWNoc3Bpbi1pbmplY3RlZFxcXCI+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuIGlucHV0LWdyb3VwLXByZXBlbmRcXFwiPlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHRhYmluZGV4PVxcXCItMVxcXCIgY2xhc3M9XFxcIlwiLmNvbmNhdChzZXR0aW5ncy5idXR0b25kb3duX2NsYXNzLCBcIiBib290c3RyYXAtdG91Y2hzcGluLWRvd25cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+XCIpLmNvbmNhdChzZXR0aW5ncy5idXR0b25kb3duX3R4dCwgXCI8L2J1dHRvbj5cXG4gICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXByZWZpeCBpbnB1dC1ncm91cC1wcmVwZW5kXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLXRleHRcXFwiPlwiKS5jb25jYXQoc2V0dGluZ3MucHJlZml4LCBcIjwvc3Bhbj5cXG4gICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXBvc3RmaXggaW5wdXQtZ3JvdXAtYXBwZW5kXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLXRleHRcXFwiPlwiKS5jb25jYXQoc2V0dGluZ3MucG9zdGZpeCwgXCI8L3NwYW4+XFxuICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuIGlucHV0LWdyb3VwLWFwcGVuZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxidXR0b24gdGFiaW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwiXCIpLmNvbmNhdChzZXR0aW5ncy5idXR0b251cF9jbGFzcywgXCIgYm9vdHN0cmFwLXRvdWNoc3Bpbi11cFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIikuY29uY2F0KHNldHRpbmdzLmJ1dHRvbnVwX3R4dCwgXCI8L2J1dHRvbj5cXG4gICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyID0gJChodG1sKS5pbnNlcnRCZWZvcmUob3JpZ2luYWxpbnB1dCk7XG4gICAgICAgICQoJy5ib290c3RyYXAtdG91Y2hzcGluLXByZWZpeCcsIGNvbnRhaW5lcikuYWZ0ZXIob3JpZ2luYWxpbnB1dCk7XG4gICAgICAgIGlmIChvcmlnaW5hbGlucHV0Lmhhc0NsYXNzKCdpbnB1dC1zbScpIHx8IG9yaWdpbmFsaW5wdXQuaGFzQ2xhc3MoJ2Zvcm0tY29udHJvbC1zbScpKSB7XG4gICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKCdpbnB1dC1ncm91cC1zbScpO1xuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsaW5wdXQuaGFzQ2xhc3MoJ2lucHV0LWxnJykgfHwgb3JpZ2luYWxpbnB1dC5oYXNDbGFzcygnZm9ybS1jb250cm9sLWxnJykpIHtcbiAgICAgICAgICBjb250YWluZXIuYWRkQ2xhc3MoJ2lucHV0LWdyb3VwLWxnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9pbml0RWxlbWVudHMoKSB7XG4gICAgICAgIGVsZW1lbnRzID0ge1xuICAgICAgICAgIGRvd246ICQoJy5ib290c3RyYXAtdG91Y2hzcGluLWRvd24nLCBjb250YWluZXIpLFxuICAgICAgICAgIHVwOiAkKCcuYm9vdHN0cmFwLXRvdWNoc3Bpbi11cCcsIGNvbnRhaW5lciksXG4gICAgICAgICAgaW5wdXQ6ICQoJ2lucHV0JywgY29udGFpbmVyKSxcbiAgICAgICAgICBwcmVmaXg6ICQoJy5ib290c3RyYXAtdG91Y2hzcGluLXByZWZpeCcsIGNvbnRhaW5lcikuYWRkQ2xhc3Moc2V0dGluZ3MucHJlZml4X2V4dHJhY2xhc3MpLFxuICAgICAgICAgIHBvc3RmaXg6ICQoJy5ib290c3RyYXAtdG91Y2hzcGluLXBvc3RmaXgnLCBjb250YWluZXIpLmFkZENsYXNzKHNldHRpbmdzLnBvc3RmaXhfZXh0cmFjbGFzcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9oaWRlRW1wdHlQcmVmaXhQb3N0Zml4KCkge1xuICAgICAgICBpZiAoc2V0dGluZ3MucHJlZml4ID09PSAnJykge1xuICAgICAgICAgIF9kZXRhY2hlZF9wcmVmaXggPSBlbGVtZW50cy5wcmVmaXguZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnBvc3RmaXggPT09ICcnKSB7XG4gICAgICAgICAgX2RldGFjaGVkX3Bvc3RmaXggPSBlbGVtZW50cy5wb3N0Zml4LmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfYmluZEV2ZW50cygpIHtcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigna2V5ZG93bi50b3VjaHNwaW4nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IDM4KSB7XG4gICAgICAgICAgICBpZiAoc3Bpbm5pbmcgIT09ICd1cCcpIHtcbiAgICAgICAgICAgICAgdXBPbmNlKCk7XG4gICAgICAgICAgICAgIHN0YXJ0VXBTcGluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDApIHtcbiAgICAgICAgICAgIGlmIChzcGlubmluZyAhPT0gJ2Rvd24nKSB7XG4gICAgICAgICAgICAgIGRvd25PbmNlKCk7XG4gICAgICAgICAgICAgIHN0YXJ0RG93blNwaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSA5IHx8IGNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICBfY2hlY2tWYWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ2tleXVwLnRvdWNoc3BpbicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzgpIHtcbiAgICAgICAgICAgIHN0b3BTcGluKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSA0MCkge1xuICAgICAgICAgICAgc3RvcFNwaW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoYW5nZSBpcyBmaXJlZCBiZWZvcmUgYmx1ciwgc28gd2UgbmVlZCB0byB3b3JrIGFyb3VuZCB0aGF0XG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdtb3VzZWRvd24gdG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmICgkKGV2ZW50LnRhcmdldCkuaXMob3JpZ2luYWxpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoZWNrVmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ2JsdXIudG91Y2hzcGluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF9jaGVja1ZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgdmFyIGNvZGUgPSBldi5rZXlDb2RlIHx8IGV2LndoaWNoO1xuICAgICAgICAgIGlmIChjb2RlID09PSAzMiB8fCBjb2RlID09PSAxMykge1xuICAgICAgICAgICAgaWYgKHNwaW5uaW5nICE9PSAnZG93bicpIHtcbiAgICAgICAgICAgICAgZG93bk9uY2UoKTtcbiAgICAgICAgICAgICAgc3RhcnREb3duU3BpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCdrZXl1cC50b3VjaHNwaW4nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICBzdG9wU3BpbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnRzLnVwLm9uKCdrZXlkb3duLnRvdWNoc3BpbicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIGlmIChzcGlubmluZyAhPT0gJ3VwJykge1xuICAgICAgICAgICAgICB1cE9uY2UoKTtcbiAgICAgICAgICAgICAgc3RhcnRVcFNwaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudHMudXAub24oJ2tleXVwLnRvdWNoc3BpbicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHN0b3BTcGluKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudHMuZG93bi5vbignbW91c2Vkb3duLnRvdWNoc3BpbicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIGVsZW1lbnRzLmRvd24ub2ZmKCd0b3VjaHN0YXJ0LnRvdWNoc3BpbicpOyAvLyBhbmRyb2lkIDQgd29ya2Fyb3VuZFxuXG4gICAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJzpkaXNhYmxlZCxbcmVhZG9ubHldJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG93bk9uY2UoKTtcbiAgICAgICAgICBzdGFydERvd25TcGluKCk7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnRzLmRvd24ub24oJ3RvdWNoc3RhcnQudG91Y2hzcGluJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgZWxlbWVudHMuZG93bi5vZmYoJ21vdXNlZG93bi50b3VjaHNwaW4nKTsgLy8gYW5kcm9pZCA0IHdvcmthcm91bmRcblxuICAgICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmlzKCc6ZGlzYWJsZWQsW3JlYWRvbmx5XScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvd25PbmNlKCk7XG4gICAgICAgICAgc3RhcnREb3duU3BpbigpO1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50cy51cC5vbignbW91c2Vkb3duLnRvdWNoc3BpbicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIGVsZW1lbnRzLnVwLm9mZigndG91Y2hzdGFydC50b3VjaHNwaW4nKTsgLy8gYW5kcm9pZCA0IHdvcmthcm91bmRcblxuICAgICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmlzKCc6ZGlzYWJsZWQsW3JlYWRvbmx5XScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwT25jZSgpO1xuICAgICAgICAgIHN0YXJ0VXBTcGluKCk7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnRzLnVwLm9uKCd0b3VjaHN0YXJ0LnRvdWNoc3BpbicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIGVsZW1lbnRzLnVwLm9mZignbW91c2Vkb3duLnRvdWNoc3BpbicpOyAvLyBhbmRyb2lkIDQgd29ya2Fyb3VuZFxuXG4gICAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJzpkaXNhYmxlZCxbcmVhZG9ubHldJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBPbmNlKCk7XG4gICAgICAgICAgc3RhcnRVcFNwaW4oKTtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudHMudXAub24oJ21vdXNldXAudG91Y2hzcGluIG1vdXNlb3V0LnRvdWNoc3BpbiB0b3VjaGxlYXZlLnRvdWNoc3BpbiB0b3VjaGVuZC50b3VjaHNwaW4gdG91Y2hjYW5jZWwudG91Y2hzcGluJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgaWYgKCFzcGlubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBzdG9wU3BpbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudHMuZG93bi5vbignbW91c2V1cC50b3VjaHNwaW4gbW91c2VvdXQudG91Y2hzcGluIHRvdWNobGVhdmUudG91Y2hzcGluIHRvdWNoZW5kLnRvdWNoc3BpbiB0b3VjaGNhbmNlbC50b3VjaHNwaW4nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICBpZiAoIXNwaW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHN0b3BTcGluKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCdtb3VzZW1vdmUudG91Y2hzcGluIHRvdWNobW92ZS50b3VjaHNwaW4nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICBpZiAoIXNwaW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50cy51cC5vbignbW91c2Vtb3ZlLnRvdWNoc3BpbiB0b3VjaG1vdmUudG91Y2hzcGluJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgaWYgKCFzcGlubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbignbW91c2V3aGVlbC50b3VjaHNwaW4gRE9NTW91c2VTY3JvbGwudG91Y2hzcGluJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgaWYgKCFzZXR0aW5ncy5tb3VzZXdoZWVsIHx8ICFvcmlnaW5hbGlucHV0LmlzKCc6Zm9jdXMnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVsdGEgPSBldi5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEgfHwgLWV2Lm9yaWdpbmFsRXZlbnQuZGVsdGFZIHx8IC1ldi5vcmlnaW5hbEV2ZW50LmRldGFpbDtcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIGRvd25PbmNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwT25jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfYmluZEV2ZW50c0ludGVyZmFjZSgpIHtcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigndG91Y2hzcGluLmRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX2Rlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi51cG9uY2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RvcFNwaW4oKTtcbiAgICAgICAgICB1cE9uY2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi5kb3dub25jZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdG9wU3BpbigpO1xuICAgICAgICAgIGRvd25PbmNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCd0b3VjaHNwaW4uc3RhcnR1cHNwaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhcnRVcFNwaW4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi5zdGFydGRvd25zcGluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXJ0RG93blNwaW4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi5zdG9wc3BpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdG9wU3BpbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigndG91Y2hzcGluLnVwZGF0ZXNldHRpbmdzJywgZnVuY3Rpb24gKGUsIG5ld3NldHRpbmdzKSB7XG4gICAgICAgICAgY2hhbmdlU2V0dGluZ3MobmV3c2V0dGluZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9zZXR1cE11dGF0aW9uT2JzZXJ2ZXJzKCkge1xuICAgICAgICBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGVcbiAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gJ2Rpc2FibGVkJyB8fCBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSAncmVhZG9ubHknKSkge1xuICAgICAgICAgICAgICAgIF91cGRhdGVCdXR0b25EaXNhYmxlZFN0YXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUob3JpZ2luYWxpbnB1dFswXSwge1xuICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfZm9yY2VzdGVwZGl2aXNpYmlsaXR5KHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuZm9yY2VzdGVwZGl2aXNpYmlsaXR5KSB7XG4gICAgICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICAgICAgcmV0dXJuIChNYXRoLnJvdW5kKHZhbHVlIC8gc2V0dGluZ3Muc3RlcCkgKiBzZXR0aW5ncy5zdGVwKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKTtcbiAgICAgICAgICBjYXNlICdmbG9vcic6XG4gICAgICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IodmFsdWUgLyBzZXR0aW5ncy5zdGVwKSAqIHNldHRpbmdzLnN0ZXApLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpO1xuICAgICAgICAgIGNhc2UgJ2NlaWwnOlxuICAgICAgICAgICAgcmV0dXJuIChNYXRoLmNlaWwodmFsdWUgLyBzZXR0aW5ncy5zdGVwKSAqIHNldHRpbmdzLnN0ZXApLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9GaXhlZChzZXR0aW5ncy5kZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9jaGVja1ZhbHVlKCkge1xuICAgICAgICB2YXIgdmFsLCBwYXJzZWR2YWwsIHJldHVybnZhbDtcbiAgICAgICAgdmFsID0gc2V0dGluZ3MuY2FsbGJhY2tfYmVmb3JlX2NhbGN1bGF0aW9uKG9yaWdpbmFsaW5wdXQudmFsKCkpO1xuICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgIGlmIChzZXR0aW5ncy5yZXBsYWNlbWVudHZhbCAhPT0gJycpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudmFsKHNldHRpbmdzLnJlcGxhY2VtZW50dmFsKTtcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbHMgPiAwICYmIHZhbCA9PT0gJy4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZHZhbCA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgaWYgKGlzTmFOKHBhcnNlZHZhbCkpIHtcbiAgICAgICAgICBpZiAoc2V0dGluZ3MucmVwbGFjZW1lbnR2YWwgIT09ICcnKSB7XG4gICAgICAgICAgICBwYXJzZWR2YWwgPSBzZXR0aW5ncy5yZXBsYWNlbWVudHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkdmFsID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJudmFsID0gcGFyc2VkdmFsO1xuICAgICAgICBpZiAocGFyc2VkdmFsLnRvU3RyaW5nKCkgIT09IHZhbCkge1xuICAgICAgICAgIHJldHVybnZhbCA9IHBhcnNlZHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm52YWwgPSBfZm9yY2VzdGVwZGl2aXNpYmlsaXR5KHBhcnNlZHZhbCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5taW4gIT09IG51bGwgJiYgcGFyc2VkdmFsIDwgc2V0dGluZ3MubWluKSB7XG4gICAgICAgICAgcmV0dXJudmFsID0gc2V0dGluZ3MubWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5tYXggIT09IG51bGwgJiYgcGFyc2VkdmFsID4gc2V0dGluZ3MubWF4KSB7XG4gICAgICAgICAgcmV0dXJudmFsID0gc2V0dGluZ3MubWF4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZUZsb2F0KHBhcnNlZHZhbCkudG9TdHJpbmcoKSAhPT0gcGFyc2VGbG9hdChyZXR1cm52YWwpLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnZhbChyZXR1cm52YWwpO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdpbmFsaW5wdXQudmFsKHNldHRpbmdzLmNhbGxiYWNrX2FmdGVyX2NhbGN1bGF0aW9uKHBhcnNlRmxvYXQocmV0dXJudmFsKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKSkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2dldEJvb3N0ZWRTdGVwKCkge1xuICAgICAgICBpZiAoIXNldHRpbmdzLmJvb3N0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYm9vc3RlZCA9IE1hdGgucG93KDIsIE1hdGguZmxvb3Ioc3BpbmNvdW50IC8gc2V0dGluZ3MuYm9vc3RhdCkpICogc2V0dGluZ3Muc3RlcDtcbiAgICAgICAgICBpZiAoc2V0dGluZ3MubWF4Ym9vc3RlZHN0ZXApIHtcbiAgICAgICAgICAgIGlmIChib29zdGVkID4gc2V0dGluZ3MubWF4Ym9vc3RlZHN0ZXApIHtcbiAgICAgICAgICAgICAgYm9vc3RlZCA9IHNldHRpbmdzLm1heGJvb3N0ZWRzdGVwO1xuICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyBib29zdGVkKSAqIGJvb3N0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLm1heChzZXR0aW5ncy5zdGVwLCBib29zdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdmFsdWVJZklzTmFOKCkge1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0Y2xpY2t2YWx1ZWlmZW1wdHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmZpcnN0Y2xpY2t2YWx1ZWlmZW1wdHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChzZXR0aW5ncy5taW4gKyBzZXR0aW5ncy5tYXgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX3VwZGF0ZUJ1dHRvbkRpc2FibGVkU3RhdGUoKSB7XG4gICAgICAgIHZhciBpc0Rpc2FibGVkID0gb3JpZ2luYWxpbnB1dC5pcygnOmRpc2FibGVkLFtyZWFkb25seV0nKTtcbiAgICAgICAgZWxlbWVudHMudXAucHJvcCgnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgZWxlbWVudHMuZG93bi5wcm9wKCdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgIHN0b3BTcGluKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwT25jZSgpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJzpkaXNhYmxlZCxbcmVhZG9ubHldJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX2NoZWNrVmFsdWUoKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHNldHRpbmdzLmNhbGxiYWNrX2JlZm9yZV9jYWxjdWxhdGlvbihlbGVtZW50cy5pbnB1dC52YWwoKSkpO1xuICAgICAgICB2YXIgaW5pdHZhbHVlID0gdmFsdWU7XG4gICAgICAgIHZhciBib29zdGVkc3RlcDtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVJZklzTmFOKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm9vc3RlZHN0ZXAgPSBfZ2V0Qm9vc3RlZFN0ZXAoKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgYm9vc3RlZHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLm1heCAhPT0gbnVsbCAmJiB2YWx1ZSA+PSBzZXR0aW5ncy5tYXgpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLm1heDtcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5tYXgnKTtcbiAgICAgICAgICBzdG9wU3BpbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLmlucHV0LnZhbChzZXR0aW5ncy5jYWxsYmFja19hZnRlcl9jYWxjdWxhdGlvbihwYXJzZUZsb2F0KHZhbHVlKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKSkpO1xuICAgICAgICBpZiAoaW5pdHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRvd25PbmNlKCkge1xuICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5pcygnOmRpc2FibGVkLFtyZWFkb25seV0nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfY2hlY2tWYWx1ZSgpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoc2V0dGluZ3MuY2FsbGJhY2tfYmVmb3JlX2NhbGN1bGF0aW9uKGVsZW1lbnRzLmlucHV0LnZhbCgpKSk7XG4gICAgICAgIHZhciBpbml0dmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGJvb3N0ZWRzdGVwO1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZUlmSXNOYU4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib29zdGVkc3RlcCA9IF9nZXRCb29zdGVkU3RlcCgpO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUgLSBib29zdGVkc3RlcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MubWluICE9PSBudWxsICYmIHZhbHVlIDw9IHNldHRpbmdzLm1pbikge1xuICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MubWluO1xuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLm1pbicpO1xuICAgICAgICAgIHN0b3BTcGluKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMuaW5wdXQudmFsKHNldHRpbmdzLmNhbGxiYWNrX2FmdGVyX2NhbGN1bGF0aW9uKHBhcnNlRmxvYXQodmFsdWUpLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpKSk7XG4gICAgICAgIGlmIChpbml0dmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RhcnREb3duU3BpbigpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJzpkaXNhYmxlZCxbcmVhZG9ubHldJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcFNwaW4oKTtcbiAgICAgICAgc3BpbmNvdW50ID0gMDtcbiAgICAgICAgc3Bpbm5pbmcgPSAnZG93bic7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0YXJ0c3BpbicpO1xuICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdGFydGRvd25zcGluJyk7XG4gICAgICAgIGRvd25EZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkb3duU3BpblRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3BpbmNvdW50Kys7XG4gICAgICAgICAgICBkb3duT25jZSgpO1xuICAgICAgICAgIH0sIHNldHRpbmdzLnN0ZXBpbnRlcnZhbCk7XG4gICAgICAgIH0sIHNldHRpbmdzLnN0ZXBpbnRlcnZhbGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0VXBTcGluKCkge1xuICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5pcygnOmRpc2FibGVkLFtyZWFkb25seV0nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdG9wU3BpbigpO1xuICAgICAgICBzcGluY291bnQgPSAwO1xuICAgICAgICBzcGlubmluZyA9ICd1cCc7XG4gICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0YXJ0c3BpbicpO1xuICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdGFydHVwc3BpbicpO1xuICAgICAgICB1cERlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVwU3BpblRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3BpbmNvdW50Kys7XG4gICAgICAgICAgICB1cE9uY2UoKTtcbiAgICAgICAgICB9LCBzZXR0aW5ncy5zdGVwaW50ZXJ2YWwpO1xuICAgICAgICB9LCBzZXR0aW5ncy5zdGVwaW50ZXJ2YWxkZWxheSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdG9wU3BpbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGRvd25EZWxheVRpbWVvdXQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodXBEZWxheVRpbWVvdXQpO1xuICAgICAgICBjbGVhckludGVydmFsKGRvd25TcGluVGltZXIpO1xuICAgICAgICBjbGVhckludGVydmFsKHVwU3BpblRpbWVyKTtcbiAgICAgICAgc3dpdGNoIChzcGlubmluZykge1xuICAgICAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0b3B1cHNwaW4nKTtcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0b3BzcGluJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLnN0b3Bkb3duc3BpbicpO1xuICAgICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RvcHNwaW4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNwaW5jb3VudCA9IDA7XG4gICAgICAgIHNwaW5uaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///285\n")},32:function(module){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar R = (typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + _typeof(listener));\n  }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function get() {\n    return defaultMaxListeners;\n  },\n  set: function set(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n  var handler = events[type];\n  if (handler === undefined) return false;\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events !== undefined) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    ;\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + _typeof(emitter));\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZXN0YXJvY2tldC1kZXYtdG9vbHMvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9kZWMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbnZhciBSID0gKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoUmVmbGVjdCkpID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsO1xudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbicgPyBSLmFwcGx5IDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xufTtcbnZhciBSZWZsZWN0T3duS2V5cztcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXM7XG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyBfdHlwZW9mKGxpc3RlbmVyKSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9IHR5cGUgPT09ICdlcnJvcic7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7ZWxzZSBpZiAoIWRvRXJyb3IpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICsgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbn07XG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7XG4gICAgZmlyZWQ6IGZhbHNlLFxuICAgIHdyYXBGbjogdW5kZWZpbmVkLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHR5cGU6IHR5cGUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSB7XG4gICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcikgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHBvc2l0aW9uID0gLTE7XG4gICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPCAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAocG9zaXRpb24gPT09IDApIGxpc3Quc2hpZnQoKTtlbHNlIHtcbiAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgfVxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcbiAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICB2YXIga2V5O1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG4gIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgO1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgX3R5cGVvZihlbWl0dGVyKSk7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n")},471:function(){eval('/*!\n\tZoom 1.7.21\n\tlicense: MIT\n\thttp://www.jacklmoore.com/zoom\n*/\n(function (o) {\n  var t = {\n    url: !1,\n    callback: !1,\n    target: !1,\n    duration: 120,\n    on: "mouseover",\n    touch: !0,\n    onZoomIn: !1,\n    onZoomOut: !1,\n    magnify: 1\n  };\n  o.zoom = function (t, n, e, i) {\n    var u,\n      c,\n      a,\n      r,\n      m,\n      l,\n      s,\n      f = o(t),\n      h = f.css("position"),\n      d = o(n);\n    return t.style.position = /(absolute|fixed)/.test(h) ? h : "relative", t.style.overflow = "hidden", e.style.width = e.style.height = "", o(e).addClass("zoomImg").css({\n      position: "absolute",\n      top: 0,\n      left: 0,\n      opacity: 0,\n      width: e.width * i,\n      height: e.height * i,\n      border: "none",\n      maxWidth: "none",\n      maxHeight: "none"\n    }).appendTo(t), {\n      init: function init() {\n        c = f.outerWidth(), u = f.outerHeight(), n === t ? (r = c, a = u) : (r = d.outerWidth(), a = d.outerHeight()), m = (e.width - c) / r, l = (e.height - u) / a, s = d.offset();\n      },\n      move: function move(o) {\n        var t = o.pageX - s.left,\n          n = o.pageY - s.top;\n        n = Math.max(Math.min(n, a), 0), t = Math.max(Math.min(t, r), 0), e.style.left = t * -m + "px", e.style.top = n * -l + "px";\n      }\n    };\n  }, o.fn.zoom = function (n) {\n    return this.each(function () {\n      var e = o.extend({}, t, n || {}),\n        i = e.target && o(e.target)[0] || this,\n        u = this,\n        c = o(u),\n        a = document.createElement("img"),\n        r = o(a),\n        m = "mousemove.zoom",\n        l = !1,\n        s = !1;\n      if (!e.url) {\n        var f = u.querySelector("img");\n        if (f && (e.url = f.getAttribute("data-src") || f.currentSrc || f.src), !e.url) return;\n      }\n      c.one("zoom.destroy", function (o, t) {\n        c.off(".zoom"), i.style.position = o, i.style.overflow = t, a.onload = null, r.remove();\n      }.bind(this, i.style.position, i.style.overflow)), a.onload = function () {\n        function t(t) {\n          f.init(), f.move(t), r.stop().fadeTo(o.support.opacity ? e.duration : 0, 1, o.isFunction(e.onZoomIn) ? e.onZoomIn.call(a) : !1);\n        }\n        function n() {\n          r.stop().fadeTo(e.duration, 0, o.isFunction(e.onZoomOut) ? e.onZoomOut.call(a) : !1);\n        }\n        var f = o.zoom(i, u, a, e.magnify);\n        "grab" === e.on ? c.on("mousedown.zoom", function (e) {\n          1 === e.which && (o(document).one("mouseup.zoom", function () {\n            n(), o(document).off(m, f.move);\n          }), t(e), o(document).on(m, f.move), e.preventDefault());\n        }) : "click" === e.on ? c.on("click.zoom", function (e) {\n          return l ? void 0 : (l = !0, t(e), o(document).on(m, f.move), o(document).one("click.zoom", function () {\n            n(), l = !1, o(document).off(m, f.move);\n          }), !1);\n        }) : "toggle" === e.on ? c.on("click.zoom", function (o) {\n          l ? n() : t(o), l = !l;\n        }) : "mouseover" === e.on && (f.init(), c.on("mouseenter.zoom", t).on("mouseleave.zoom", n).on(m, f.move)), e.touch && c.on("touchstart.zoom", function (o) {\n          o.preventDefault(), s ? (s = !1, n()) : (s = !0, t(o.originalEvent.touches[0] || o.originalEvent.changedTouches[0]));\n        }).on("touchmove.zoom", function (o) {\n          o.preventDefault(), f.move(o.originalEvent.touches[0] || o.originalEvent.changedTouches[0]);\n        }).on("touchend.zoom", function (o) {\n          o.preventDefault(), s && (s = !1, n());\n        }), o.isFunction(e.callback) && e.callback.call(a);\n      }, a.setAttribute("role", "presentation"), a.alt = "", a.src = e.url;\n    });\n  }, o.fn.zoom.defaults = t;\n})(window.jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9qcXVlcnktem9vbS9qcXVlcnkuem9vbS5taW4uanM/NWQyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcblx0Wm9vbSAxLjcuMjFcblx0bGljZW5zZTogTUlUXG5cdGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vem9vbVxuKi9cbihmdW5jdGlvbiAobykge1xuICB2YXIgdCA9IHtcbiAgICB1cmw6ICExLFxuICAgIGNhbGxiYWNrOiAhMSxcbiAgICB0YXJnZXQ6ICExLFxuICAgIGR1cmF0aW9uOiAxMjAsXG4gICAgb246IFwibW91c2VvdmVyXCIsXG4gICAgdG91Y2g6ICEwLFxuICAgIG9uWm9vbUluOiAhMSxcbiAgICBvblpvb21PdXQ6ICExLFxuICAgIG1hZ25pZnk6IDFcbiAgfTtcbiAgby56b29tID0gZnVuY3Rpb24gKHQsIG4sIGUsIGkpIHtcbiAgICB2YXIgdSxcbiAgICAgIGMsXG4gICAgICBhLFxuICAgICAgcixcbiAgICAgIG0sXG4gICAgICBsLFxuICAgICAgcyxcbiAgICAgIGYgPSBvKHQpLFxuICAgICAgaCA9IGYuY3NzKFwicG9zaXRpb25cIiksXG4gICAgICBkID0gbyhuKTtcbiAgICByZXR1cm4gdC5zdHlsZS5wb3NpdGlvbiA9IC8oYWJzb2x1dGV8Zml4ZWQpLy50ZXN0KGgpID8gaCA6IFwicmVsYXRpdmVcIiwgdC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIGUuc3R5bGUud2lkdGggPSBlLnN0eWxlLmhlaWdodCA9IFwiXCIsIG8oZSkuYWRkQ2xhc3MoXCJ6b29tSW1nXCIpLmNzcyh7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB3aWR0aDogZS53aWR0aCAqIGksXG4gICAgICBoZWlnaHQ6IGUuaGVpZ2h0ICogaSxcbiAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICBtYXhXaWR0aDogXCJub25lXCIsXG4gICAgICBtYXhIZWlnaHQ6IFwibm9uZVwiXG4gICAgfSkuYXBwZW5kVG8odCksIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGMgPSBmLm91dGVyV2lkdGgoKSwgdSA9IGYub3V0ZXJIZWlnaHQoKSwgbiA9PT0gdCA/IChyID0gYywgYSA9IHUpIDogKHIgPSBkLm91dGVyV2lkdGgoKSwgYSA9IGQub3V0ZXJIZWlnaHQoKSksIG0gPSAoZS53aWR0aCAtIGMpIC8gciwgbCA9IChlLmhlaWdodCAtIHUpIC8gYSwgcyA9IGQub2Zmc2V0KCk7XG4gICAgICB9LFxuICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZShvKSB7XG4gICAgICAgIHZhciB0ID0gby5wYWdlWCAtIHMubGVmdCxcbiAgICAgICAgICBuID0gby5wYWdlWSAtIHMudG9wO1xuICAgICAgICBuID0gTWF0aC5tYXgoTWF0aC5taW4obiwgYSksIDApLCB0ID0gTWF0aC5tYXgoTWF0aC5taW4odCwgciksIDApLCBlLnN0eWxlLmxlZnQgPSB0ICogLW0gKyBcInB4XCIsIGUuc3R5bGUudG9wID0gbiAqIC1sICsgXCJweFwiO1xuICAgICAgfVxuICAgIH07XG4gIH0sIG8uZm4uem9vbSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IG8uZXh0ZW5kKHt9LCB0LCBuIHx8IHt9KSxcbiAgICAgICAgaSA9IGUudGFyZ2V0ICYmIG8oZS50YXJnZXQpWzBdIHx8IHRoaXMsXG4gICAgICAgIHUgPSB0aGlzLFxuICAgICAgICBjID0gbyh1KSxcbiAgICAgICAgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiksXG4gICAgICAgIHIgPSBvKGEpLFxuICAgICAgICBtID0gXCJtb3VzZW1vdmUuem9vbVwiLFxuICAgICAgICBsID0gITEsXG4gICAgICAgIHMgPSAhMTtcbiAgICAgIGlmICghZS51cmwpIHtcbiAgICAgICAgdmFyIGYgPSB1LnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIik7XG4gICAgICAgIGlmIChmICYmIChlLnVybCA9IGYuZ2V0QXR0cmlidXRlKFwiZGF0YS1zcmNcIikgfHwgZi5jdXJyZW50U3JjIHx8IGYuc3JjKSwgIWUudXJsKSByZXR1cm47XG4gICAgICB9XG4gICAgICBjLm9uZShcInpvb20uZGVzdHJveVwiLCBmdW5jdGlvbiAobywgdCkge1xuICAgICAgICBjLm9mZihcIi56b29tXCIpLCBpLnN0eWxlLnBvc2l0aW9uID0gbywgaS5zdHlsZS5vdmVyZmxvdyA9IHQsIGEub25sb2FkID0gbnVsbCwgci5yZW1vdmUoKTtcbiAgICAgIH0uYmluZCh0aGlzLCBpLnN0eWxlLnBvc2l0aW9uLCBpLnN0eWxlLm92ZXJmbG93KSksIGEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiB0KHQpIHtcbiAgICAgICAgICBmLmluaXQoKSwgZi5tb3ZlKHQpLCByLnN0b3AoKS5mYWRlVG8oby5zdXBwb3J0Lm9wYWNpdHkgPyBlLmR1cmF0aW9uIDogMCwgMSwgby5pc0Z1bmN0aW9uKGUub25ab29tSW4pID8gZS5vblpvb21Jbi5jYWxsKGEpIDogITEpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgci5zdG9wKCkuZmFkZVRvKGUuZHVyYXRpb24sIDAsIG8uaXNGdW5jdGlvbihlLm9uWm9vbU91dCkgPyBlLm9uWm9vbU91dC5jYWxsKGEpIDogITEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmID0gby56b29tKGksIHUsIGEsIGUubWFnbmlmeSk7XG4gICAgICAgIFwiZ3JhYlwiID09PSBlLm9uID8gYy5vbihcIm1vdXNlZG93bi56b29tXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgMSA9PT0gZS53aGljaCAmJiAobyhkb2N1bWVudCkub25lKFwibW91c2V1cC56b29tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG4oKSwgbyhkb2N1bWVudCkub2ZmKG0sIGYubW92ZSk7XG4gICAgICAgICAgfSksIHQoZSksIG8oZG9jdW1lbnQpLm9uKG0sIGYubW92ZSksIGUucHJldmVudERlZmF1bHQoKSk7XG4gICAgICAgIH0pIDogXCJjbGlja1wiID09PSBlLm9uID8gYy5vbihcImNsaWNrLnpvb21cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gbCA/IHZvaWQgMCA6IChsID0gITAsIHQoZSksIG8oZG9jdW1lbnQpLm9uKG0sIGYubW92ZSksIG8oZG9jdW1lbnQpLm9uZShcImNsaWNrLnpvb21cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbigpLCBsID0gITEsIG8oZG9jdW1lbnQpLm9mZihtLCBmLm1vdmUpO1xuICAgICAgICAgIH0pLCAhMSk7XG4gICAgICAgIH0pIDogXCJ0b2dnbGVcIiA9PT0gZS5vbiA/IGMub24oXCJjbGljay56b29tXCIsIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgbCA/IG4oKSA6IHQobyksIGwgPSAhbDtcbiAgICAgICAgfSkgOiBcIm1vdXNlb3ZlclwiID09PSBlLm9uICYmIChmLmluaXQoKSwgYy5vbihcIm1vdXNlZW50ZXIuem9vbVwiLCB0KS5vbihcIm1vdXNlbGVhdmUuem9vbVwiLCBuKS5vbihtLCBmLm1vdmUpKSwgZS50b3VjaCAmJiBjLm9uKFwidG91Y2hzdGFydC56b29tXCIsIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgby5wcmV2ZW50RGVmYXVsdCgpLCBzID8gKHMgPSAhMSwgbigpKSA6IChzID0gITAsIHQoby5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0gfHwgby5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSk7XG4gICAgICAgIH0pLm9uKFwidG91Y2htb3ZlLnpvb21cIiwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICBvLnByZXZlbnREZWZhdWx0KCksIGYubW92ZShvLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSB8fCBvLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgICB9KS5vbihcInRvdWNoZW5kLnpvb21cIiwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICBvLnByZXZlbnREZWZhdWx0KCksIHMgJiYgKHMgPSAhMSwgbigpKTtcbiAgICAgICAgfSksIG8uaXNGdW5jdGlvbihlLmNhbGxiYWNrKSAmJiBlLmNhbGxiYWNrLmNhbGwoYSk7XG4gICAgICB9LCBhLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIiksIGEuYWx0ID0gXCJcIiwgYS5zcmMgPSBlLnVybDtcbiAgICB9KTtcbiAgfSwgby5mbi56b29tLmRlZmF1bHRzID0gdDtcbn0pKHdpbmRvdy5qUXVlcnkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///471\n')},64:function(module,__unused_webpack_exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n(function (window, factory) {\n  var lazySizes = factory(window, window.document, Date);\n  window.lazySizes = lazySizes;\n  if (( false ? 0 : _typeof(module)) == 'object' && module.exports) {\n    module.exports = lazySizes;\n  }\n})(typeof window != 'undefined' ? window : {},\n/**\n * import(\"./types/global\")\n * @typedef { import(\"./types/lazysizes-config\").LazySizesConfigPartial } LazySizesConfigPartial\n */\nfunction l(window, document, Date) {\n  // Pass in the window Date function also for SSR because the Date class can be lost\n  'use strict';\n\n  /*jshint eqnull:true */\n  var lazysizes,\n    /**\n     * @type { LazySizesConfigPartial }\n     */\n    lazySizesCfg;\n  (function () {\n    var prop;\n    var lazySizesDefaults = {\n      lazyClass: 'lazyload',\n      loadedClass: 'lazyloaded',\n      loadingClass: 'lazyloading',\n      preloadClass: 'lazypreload',\n      errorClass: 'lazyerror',\n      //strictClass: 'lazystrict',\n      autosizesClass: 'lazyautosizes',\n      fastLoadedClass: 'ls-is-cached',\n      iframeLoadMode: 0,\n      srcAttr: 'data-src',\n      srcsetAttr: 'data-srcset',\n      sizesAttr: 'data-sizes',\n      //preloadAfterLoad: false,\n      minSize: 40,\n      customMedia: {},\n      init: true,\n      expFactor: 1.5,\n      hFac: 0.8,\n      loadMode: 2,\n      loadHidden: true,\n      ricTimeout: 0,\n      throttleDelay: 125\n    };\n    lazySizesCfg = window.lazySizesConfig || window.lazysizesConfig || {};\n    for (prop in lazySizesDefaults) {\n      if (!(prop in lazySizesCfg)) {\n        lazySizesCfg[prop] = lazySizesDefaults[prop];\n      }\n    }\n  })();\n  if (!document || !document.getElementsByClassName) {\n    return {\n      init: function init() {},\n      /**\n       * @type { LazySizesConfigPartial }\n       */\n      cfg: lazySizesCfg,\n      /**\n       * @type { true }\n       */\n      noSupport: true\n    };\n  }\n  var docElem = document.documentElement;\n  var supportPicture = window.HTMLPictureElement;\n  var _addEventListener = 'addEventListener';\n  var _getAttribute = 'getAttribute';\n\n  /**\n   * Update to bind to window because 'this' becomes null during SSR\n   * builds.\n   */\n  var addEventListener = window[_addEventListener].bind(window);\n  var setTimeout = window.setTimeout;\n  var requestAnimationFrame = window.requestAnimationFrame || setTimeout;\n  var requestIdleCallback = window.requestIdleCallback;\n  var regPicture = /^picture$/i;\n  var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];\n  var regClassCache = {};\n  var forEach = Array.prototype.forEach;\n\n  /**\n   * @param ele {Element}\n   * @param cls {string}\n   */\n  var hasClass = function hasClass(ele, cls) {\n    if (!regClassCache[cls]) {\n      regClassCache[cls] = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)');\n    }\n    return regClassCache[cls].test(ele[_getAttribute]('class') || '') && regClassCache[cls];\n  };\n\n  /**\n   * @param ele {Element}\n   * @param cls {string}\n   */\n  var addClass = function addClass(ele, cls) {\n    if (!hasClass(ele, cls)) {\n      ele.setAttribute('class', (ele[_getAttribute]('class') || '').trim() + ' ' + cls);\n    }\n  };\n\n  /**\n   * @param ele {Element}\n   * @param cls {string}\n   */\n  var removeClass = function removeClass(ele, cls) {\n    var reg;\n    if (reg = hasClass(ele, cls)) {\n      ele.setAttribute('class', (ele[_getAttribute]('class') || '').replace(reg, ' '));\n    }\n  };\n  var addRemoveLoadEvents = function addRemoveLoadEvents(dom, fn, add) {\n    var action = add ? _addEventListener : 'removeEventListener';\n    if (add) {\n      addRemoveLoadEvents(dom, fn);\n    }\n    loadEvents.forEach(function (evt) {\n      dom[action](evt, fn);\n    });\n  };\n\n  /**\n   * @param elem { Element }\n   * @param name { string }\n   * @param detail { any }\n   * @param noBubbles { boolean }\n   * @param noCancelable { boolean }\n   * @returns { CustomEvent }\n   */\n  var triggerEvent = function triggerEvent(elem, name, detail, noBubbles, noCancelable) {\n    var event = document.createEvent('Event');\n    if (!detail) {\n      detail = {};\n    }\n    detail.instance = lazysizes;\n    event.initEvent(name, !noBubbles, !noCancelable);\n    event.detail = detail;\n    elem.dispatchEvent(event);\n    return event;\n  };\n  var updatePolyfill = function updatePolyfill(el, full) {\n    var polyfill;\n    if (!supportPicture && (polyfill = window.picturefill || lazySizesCfg.pf)) {\n      if (full && full.src && !el[_getAttribute]('srcset')) {\n        el.setAttribute('srcset', full.src);\n      }\n      polyfill({\n        reevaluate: true,\n        elements: [el]\n      });\n    } else if (full && full.src) {\n      el.src = full.src;\n    }\n  };\n  var getCSS = function getCSS(elem, style) {\n    return (getComputedStyle(elem, null) || {})[style];\n  };\n\n  /**\n   *\n   * @param elem { Element }\n   * @param parent { Element }\n   * @param [width] {number}\n   * @returns {number}\n   */\n  var getWidth = function getWidth(elem, parent, width) {\n    width = width || elem.offsetWidth;\n    while (width < lazySizesCfg.minSize && parent && !elem._lazysizesWidth) {\n      width = parent.offsetWidth;\n      parent = parent.parentNode;\n    }\n    return width;\n  };\n  var rAF = function () {\n    var running, waiting;\n    var firstFns = [];\n    var secondFns = [];\n    var fns = firstFns;\n    var run = function run() {\n      var runFns = fns;\n      fns = firstFns.length ? secondFns : firstFns;\n      running = true;\n      waiting = false;\n      while (runFns.length) {\n        runFns.shift()();\n      }\n      running = false;\n    };\n    var rafBatch = function rafBatch(fn, queue) {\n      if (running && !queue) {\n        fn.apply(this, arguments);\n      } else {\n        fns.push(fn);\n        if (!waiting) {\n          waiting = true;\n          (document.hidden ? setTimeout : requestAnimationFrame)(run);\n        }\n      }\n    };\n    rafBatch._lsFlush = run;\n    return rafBatch;\n  }();\n  var rAFIt = function rAFIt(fn, simple) {\n    return simple ? function () {\n      rAF(fn);\n    } : function () {\n      var that = this;\n      var args = arguments;\n      rAF(function () {\n        fn.apply(that, args);\n      });\n    };\n  };\n  var throttle = function throttle(fn) {\n    var running;\n    var lastTime = 0;\n    var gDelay = lazySizesCfg.throttleDelay;\n    var rICTimeout = lazySizesCfg.ricTimeout;\n    var run = function run() {\n      running = false;\n      lastTime = Date.now();\n      fn();\n    };\n    var idleCallback = requestIdleCallback && rICTimeout > 49 ? function () {\n      requestIdleCallback(run, {\n        timeout: rICTimeout\n      });\n      if (rICTimeout !== lazySizesCfg.ricTimeout) {\n        rICTimeout = lazySizesCfg.ricTimeout;\n      }\n    } : rAFIt(function () {\n      setTimeout(run);\n    }, true);\n    return function (isPriority) {\n      var delay;\n      if (isPriority = isPriority === true) {\n        rICTimeout = 33;\n      }\n      if (running) {\n        return;\n      }\n      running = true;\n      delay = gDelay - (Date.now() - lastTime);\n      if (delay < 0) {\n        delay = 0;\n      }\n      if (isPriority || delay < 9) {\n        idleCallback();\n      } else {\n        setTimeout(idleCallback, delay);\n      }\n    };\n  };\n\n  //based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html\n  var debounce = function debounce(func) {\n    var timeout, timestamp;\n    var wait = 99;\n    var run = function run() {\n      timeout = null;\n      func();\n    };\n    var later = function later() {\n      var last = Date.now() - timestamp;\n      if (last < wait) {\n        setTimeout(later, wait - last);\n      } else {\n        (requestIdleCallback || run)(run);\n      }\n    };\n    return function () {\n      timestamp = Date.now();\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n    };\n  };\n  var loader = function () {\n    var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;\n    var eLvW, elvH, eLtop, eLleft, eLright, eLbottom, isBodyHidden;\n    var regImg = /^img$/i;\n    var regIframe = /^iframe$/i;\n    var supportScroll = 'onscroll' in window && !/(gle|ing)bot/.test(navigator.userAgent);\n    var shrinkExpand = 0;\n    var currentExpand = 0;\n    var isLoading = 0;\n    var lowRuns = -1;\n    var resetPreloading = function resetPreloading(e) {\n      isLoading--;\n      if (!e || isLoading < 0 || !e.target) {\n        isLoading = 0;\n      }\n    };\n    var isVisible = function isVisible(elem) {\n      if (isBodyHidden == null) {\n        isBodyHidden = getCSS(document.body, 'visibility') == 'hidden';\n      }\n      return isBodyHidden || !(getCSS(elem.parentNode, 'visibility') == 'hidden' && getCSS(elem, 'visibility') == 'hidden');\n    };\n    var isNestedVisible = function isNestedVisible(elem, elemExpand) {\n      var outerRect;\n      var parent = elem;\n      var visible = isVisible(elem);\n      eLtop -= elemExpand;\n      eLbottom += elemExpand;\n      eLleft -= elemExpand;\n      eLright += elemExpand;\n      while (visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem) {\n        visible = (getCSS(parent, 'opacity') || 1) > 0;\n        if (visible && getCSS(parent, 'overflow') != 'visible') {\n          outerRect = parent.getBoundingClientRect();\n          visible = eLright > outerRect.left && eLleft < outerRect.right && eLbottom > outerRect.top - 1 && eLtop < outerRect.bottom + 1;\n        }\n      }\n      return visible;\n    };\n    var checkElements = function checkElements() {\n      var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal, defaultExpand, preloadExpand, hFac;\n      var lazyloadElems = lazysizes.elements;\n      if ((loadMode = lazySizesCfg.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {\n        i = 0;\n        lowRuns++;\n        for (; i < eLlen; i++) {\n          if (!lazyloadElems[i] || lazyloadElems[i]._lazyRace) {\n            continue;\n          }\n          if (!supportScroll || lazysizes.prematureUnveil && lazysizes.prematureUnveil(lazyloadElems[i])) {\n            unveilElement(lazyloadElems[i]);\n            continue;\n          }\n          if (!(elemExpandVal = lazyloadElems[i][_getAttribute]('data-expand')) || !(elemExpand = elemExpandVal * 1)) {\n            elemExpand = currentExpand;\n          }\n          if (!defaultExpand) {\n            defaultExpand = !lazySizesCfg.expand || lazySizesCfg.expand < 1 ? docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370 : lazySizesCfg.expand;\n            lazysizes._defEx = defaultExpand;\n            preloadExpand = defaultExpand * lazySizesCfg.expFactor;\n            hFac = lazySizesCfg.hFac;\n            isBodyHidden = null;\n            if (currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden) {\n              currentExpand = preloadExpand;\n              lowRuns = 0;\n            } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {\n              currentExpand = defaultExpand;\n            } else {\n              currentExpand = shrinkExpand;\n            }\n          }\n          if (beforeExpandVal !== elemExpand) {\n            eLvW = innerWidth + elemExpand * hFac;\n            elvH = innerHeight + elemExpand;\n            elemNegativeExpand = elemExpand * -1;\n            beforeExpandVal = elemExpand;\n          }\n          rect = lazyloadElems[i].getBoundingClientRect();\n          if ((eLbottom = rect.bottom) >= elemNegativeExpand && (eLtop = rect.top) <= elvH && (eLright = rect.right) >= elemNegativeExpand * hFac && (eLleft = rect.left) <= eLvW && (eLbottom || eLright || eLleft || eLtop) && (lazySizesCfg.loadHidden || isVisible(lazyloadElems[i])) && (isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4) || isNestedVisible(lazyloadElems[i], elemExpand))) {\n            unveilElement(lazyloadElems[i]);\n            loadedSomething = true;\n            if (isLoading > 9) {\n              break;\n            }\n          } else if (!loadedSomething && isCompleted && !autoLoadElem && isLoading < 4 && lowRuns < 4 && loadMode > 2 && (preloadElems[0] || lazySizesCfg.preloadAfterLoad) && (preloadElems[0] || !elemExpandVal && (eLbottom || eLright || eLleft || eLtop || lazyloadElems[i][_getAttribute](lazySizesCfg.sizesAttr) != 'auto'))) {\n            autoLoadElem = preloadElems[0] || lazyloadElems[i];\n          }\n        }\n        if (autoLoadElem && !loadedSomething) {\n          unveilElement(autoLoadElem);\n        }\n      }\n    };\n    var throttledCheckElements = throttle(checkElements);\n    var switchLoadingClass = function switchLoadingClass(e) {\n      var elem = e.target;\n      if (elem._lazyCache) {\n        delete elem._lazyCache;\n        return;\n      }\n      resetPreloading(e);\n      addClass(elem, lazySizesCfg.loadedClass);\n      removeClass(elem, lazySizesCfg.loadingClass);\n      addRemoveLoadEvents(elem, rafSwitchLoadingClass);\n      triggerEvent(elem, 'lazyloaded');\n    };\n    var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);\n    var rafSwitchLoadingClass = function rafSwitchLoadingClass(e) {\n      rafedSwitchLoadingClass({\n        target: e.target\n      });\n    };\n    var changeIframeSrc = function changeIframeSrc(elem, src) {\n      var loadMode = elem.getAttribute('data-load-mode') || lazySizesCfg.iframeLoadMode;\n\n      // loadMode can be also a string!\n      if (loadMode == 0) {\n        elem.contentWindow.location.replace(src);\n      } else if (loadMode == 1) {\n        elem.src = src;\n      }\n    };\n    var handleSources = function handleSources(source) {\n      var customMedia;\n      var sourceSrcset = source[_getAttribute](lazySizesCfg.srcsetAttr);\n      if (customMedia = lazySizesCfg.customMedia[source[_getAttribute]('data-media') || source[_getAttribute]('media')]) {\n        source.setAttribute('media', customMedia);\n      }\n      if (sourceSrcset) {\n        source.setAttribute('srcset', sourceSrcset);\n      }\n    };\n    var lazyUnveil = rAFIt(function (elem, detail, isAuto, sizes, isImg) {\n      var src, srcset, parent, isPicture, event, firesLoad;\n      if (!(event = triggerEvent(elem, 'lazybeforeunveil', detail)).defaultPrevented) {\n        if (sizes) {\n          if (isAuto) {\n            addClass(elem, lazySizesCfg.autosizesClass);\n          } else {\n            elem.setAttribute('sizes', sizes);\n          }\n        }\n        srcset = elem[_getAttribute](lazySizesCfg.srcsetAttr);\n        src = elem[_getAttribute](lazySizesCfg.srcAttr);\n        if (isImg) {\n          parent = elem.parentNode;\n          isPicture = parent && regPicture.test(parent.nodeName || '');\n        }\n        firesLoad = detail.firesLoad || 'src' in elem && (srcset || src || isPicture);\n        event = {\n          target: elem\n        };\n        addClass(elem, lazySizesCfg.loadingClass);\n        if (firesLoad) {\n          clearTimeout(resetPreloadingTimer);\n          resetPreloadingTimer = setTimeout(resetPreloading, 2500);\n          addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);\n        }\n        if (isPicture) {\n          forEach.call(parent.getElementsByTagName('source'), handleSources);\n        }\n        if (srcset) {\n          elem.setAttribute('srcset', srcset);\n        } else if (src && !isPicture) {\n          if (regIframe.test(elem.nodeName)) {\n            changeIframeSrc(elem, src);\n          } else {\n            elem.src = src;\n          }\n        }\n        if (isImg && (srcset || isPicture)) {\n          updatePolyfill(elem, {\n            src: src\n          });\n        }\n      }\n      if (elem._lazyRace) {\n        delete elem._lazyRace;\n      }\n      removeClass(elem, lazySizesCfg.lazyClass);\n      rAF(function () {\n        // Part of this can be removed as soon as this fix is older: https://bugs.chromium.org/p/chromium/issues/detail?id=7731 (2015)\n        var isLoaded = elem.complete && elem.naturalWidth > 1;\n        if (!firesLoad || isLoaded) {\n          if (isLoaded) {\n            addClass(elem, lazySizesCfg.fastLoadedClass);\n          }\n          switchLoadingClass(event);\n          elem._lazyCache = true;\n          setTimeout(function () {\n            if ('_lazyCache' in elem) {\n              delete elem._lazyCache;\n            }\n          }, 9);\n        }\n        if (elem.loading == 'lazy') {\n          isLoading--;\n        }\n      }, true);\n    });\n\n    /**\n     *\n     * @param elem { Element }\n     */\n    var unveilElement = function unveilElement(elem) {\n      if (elem._lazyRace) {\n        return;\n      }\n      var detail;\n      var isImg = regImg.test(elem.nodeName);\n\n      //allow using sizes=\"auto\", but don't use. it's invalid. Use data-sizes=\"auto\" or a valid value for sizes instead (i.e.: sizes=\"80vw\")\n      var sizes = isImg && (elem[_getAttribute](lazySizesCfg.sizesAttr) || elem[_getAttribute]('sizes'));\n      var isAuto = sizes == 'auto';\n      if ((isAuto || !isCompleted) && isImg && (elem[_getAttribute]('src') || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesCfg.errorClass) && hasClass(elem, lazySizesCfg.lazyClass)) {\n        return;\n      }\n      detail = triggerEvent(elem, 'lazyunveilread').detail;\n      if (isAuto) {\n        autoSizer.updateElem(elem, true, elem.offsetWidth);\n      }\n      elem._lazyRace = true;\n      isLoading++;\n      lazyUnveil(elem, detail, isAuto, sizes, isImg);\n    };\n    var afterScroll = debounce(function () {\n      lazySizesCfg.loadMode = 3;\n      throttledCheckElements();\n    });\n    var altLoadmodeScrollListner = function altLoadmodeScrollListner() {\n      if (lazySizesCfg.loadMode == 3) {\n        lazySizesCfg.loadMode = 2;\n      }\n      afterScroll();\n    };\n    var onload = function onload() {\n      if (isCompleted) {\n        return;\n      }\n      if (Date.now() - started < 999) {\n        setTimeout(onload, 999);\n        return;\n      }\n      isCompleted = true;\n      lazySizesCfg.loadMode = 3;\n      throttledCheckElements();\n      addEventListener('scroll', altLoadmodeScrollListner, true);\n    };\n    return {\n      _: function _() {\n        started = Date.now();\n        lazysizes.elements = document.getElementsByClassName(lazySizesCfg.lazyClass);\n        preloadElems = document.getElementsByClassName(lazySizesCfg.lazyClass + ' ' + lazySizesCfg.preloadClass);\n        addEventListener('scroll', throttledCheckElements, true);\n        addEventListener('resize', throttledCheckElements, true);\n        addEventListener('pageshow', function (e) {\n          if (e.persisted) {\n            var loadingElements = document.querySelectorAll('.' + lazySizesCfg.loadingClass);\n            if (loadingElements.length && loadingElements.forEach) {\n              requestAnimationFrame(function () {\n                loadingElements.forEach(function (img) {\n                  if (img.complete) {\n                    unveilElement(img);\n                  }\n                });\n              });\n            }\n          }\n        });\n        if (window.MutationObserver) {\n          new MutationObserver(throttledCheckElements).observe(docElem, {\n            childList: true,\n            subtree: true,\n            attributes: true\n          });\n        } else {\n          docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);\n          docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);\n          setInterval(throttledCheckElements, 999);\n        }\n        addEventListener('hashchange', throttledCheckElements, true);\n\n        //, 'fullscreenchange'\n        ['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend'].forEach(function (name) {\n          document[_addEventListener](name, throttledCheckElements, true);\n        });\n        if (/d$|^c/.test(document.readyState)) {\n          onload();\n        } else {\n          addEventListener('load', onload);\n          document[_addEventListener]('DOMContentLoaded', throttledCheckElements);\n          setTimeout(onload, 20000);\n        }\n        if (lazysizes.elements.length) {\n          checkElements();\n          rAF._lsFlush();\n        } else {\n          throttledCheckElements();\n        }\n      },\n      checkElems: throttledCheckElements,\n      unveil: unveilElement,\n      _aLSL: altLoadmodeScrollListner\n    };\n  }();\n  var autoSizer = function () {\n    var autosizesElems;\n    var sizeElement = rAFIt(function (elem, parent, event, width) {\n      var sources, i, len;\n      elem._lazysizesWidth = width;\n      width += 'px';\n      elem.setAttribute('sizes', width);\n      if (regPicture.test(parent.nodeName || '')) {\n        sources = parent.getElementsByTagName('source');\n        for (i = 0, len = sources.length; i < len; i++) {\n          sources[i].setAttribute('sizes', width);\n        }\n      }\n      if (!event.detail.dataAttr) {\n        updatePolyfill(elem, event.detail);\n      }\n    });\n    /**\n     *\n     * @param elem {Element}\n     * @param dataAttr\n     * @param [width] { number }\n     */\n    var getSizeElement = function getSizeElement(elem, dataAttr, width) {\n      var event;\n      var parent = elem.parentNode;\n      if (parent) {\n        width = getWidth(elem, parent, width);\n        event = triggerEvent(elem, 'lazybeforesizes', {\n          width: width,\n          dataAttr: !!dataAttr\n        });\n        if (!event.defaultPrevented) {\n          width = event.detail.width;\n          if (width && width !== elem._lazysizesWidth) {\n            sizeElement(elem, parent, event, width);\n          }\n        }\n      }\n    };\n    var updateElementsSizes = function updateElementsSizes() {\n      var i;\n      var len = autosizesElems.length;\n      if (len) {\n        i = 0;\n        for (; i < len; i++) {\n          getSizeElement(autosizesElems[i]);\n        }\n      }\n    };\n    var debouncedUpdateElementsSizes = debounce(updateElementsSizes);\n    return {\n      _: function _() {\n        autosizesElems = document.getElementsByClassName(lazySizesCfg.autosizesClass);\n        addEventListener('resize', debouncedUpdateElementsSizes);\n      },\n      checkElems: debouncedUpdateElementsSizes,\n      updateElem: getSizeElement\n    };\n  }();\n  var init = function init() {\n    if (!init.i && document.getElementsByClassName) {\n      init.i = true;\n      autoSizer._();\n      loader._();\n    }\n  };\n  setTimeout(function () {\n    if (lazySizesCfg.init) {\n      init();\n    }\n  });\n  lazysizes = {\n    /**\n     * @type { LazySizesConfigPartial }\n     */\n    cfg: lazySizesCfg,\n    autoSizer: autoSizer,\n    loader: loader,\n    init: init,\n    uP: updatePolyfill,\n    aC: addClass,\n    rC: removeClass,\n    hC: hasClass,\n    fire: triggerEvent,\n    gW: getWidth,\n    rAF: rAF\n  };\n  return lazysizes;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL25vZGVfbW9kdWxlcy9sYXp5c2l6ZXMvbGF6eXNpemVzLmpzPzJhOWEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuKGZ1bmN0aW9uICh3aW5kb3csIGZhY3RvcnkpIHtcbiAgdmFyIGxhenlTaXplcyA9IGZhY3Rvcnkod2luZG93LCB3aW5kb3cuZG9jdW1lbnQsIERhdGUpO1xuICB3aW5kb3cubGF6eVNpemVzID0gbGF6eVNpemVzO1xuICBpZiAoKHR5cGVvZiBtb2R1bGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihtb2R1bGUpKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbGF6eVNpemVzO1xuICB9XG59KSh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDoge30sXG4vKipcbiAqIGltcG9ydChcIi4vdHlwZXMvZ2xvYmFsXCIpXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcIi4vdHlwZXMvbGF6eXNpemVzLWNvbmZpZ1wiKS5MYXp5U2l6ZXNDb25maWdQYXJ0aWFsIH0gTGF6eVNpemVzQ29uZmlnUGFydGlhbFxuICovXG5mdW5jdGlvbiBsKHdpbmRvdywgZG9jdW1lbnQsIERhdGUpIHtcbiAgLy8gUGFzcyBpbiB0aGUgd2luZG93IERhdGUgZnVuY3Rpb24gYWxzbyBmb3IgU1NSIGJlY2F1c2UgdGhlIERhdGUgY2xhc3MgY2FuIGJlIGxvc3RcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gIHZhciBsYXp5c2l6ZXMsXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyBMYXp5U2l6ZXNDb25maWdQYXJ0aWFsIH1cbiAgICAgKi9cbiAgICBsYXp5U2l6ZXNDZmc7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3A7XG4gICAgdmFyIGxhenlTaXplc0RlZmF1bHRzID0ge1xuICAgICAgbGF6eUNsYXNzOiAnbGF6eWxvYWQnLFxuICAgICAgbG9hZGVkQ2xhc3M6ICdsYXp5bG9hZGVkJyxcbiAgICAgIGxvYWRpbmdDbGFzczogJ2xhenlsb2FkaW5nJyxcbiAgICAgIHByZWxvYWRDbGFzczogJ2xhenlwcmVsb2FkJyxcbiAgICAgIGVycm9yQ2xhc3M6ICdsYXp5ZXJyb3InLFxuICAgICAgLy9zdHJpY3RDbGFzczogJ2xhenlzdHJpY3QnLFxuICAgICAgYXV0b3NpemVzQ2xhc3M6ICdsYXp5YXV0b3NpemVzJyxcbiAgICAgIGZhc3RMb2FkZWRDbGFzczogJ2xzLWlzLWNhY2hlZCcsXG4gICAgICBpZnJhbWVMb2FkTW9kZTogMCxcbiAgICAgIHNyY0F0dHI6ICdkYXRhLXNyYycsXG4gICAgICBzcmNzZXRBdHRyOiAnZGF0YS1zcmNzZXQnLFxuICAgICAgc2l6ZXNBdHRyOiAnZGF0YS1zaXplcycsXG4gICAgICAvL3ByZWxvYWRBZnRlckxvYWQ6IGZhbHNlLFxuICAgICAgbWluU2l6ZTogNDAsXG4gICAgICBjdXN0b21NZWRpYToge30sXG4gICAgICBpbml0OiB0cnVlLFxuICAgICAgZXhwRmFjdG9yOiAxLjUsXG4gICAgICBoRmFjOiAwLjgsXG4gICAgICBsb2FkTW9kZTogMixcbiAgICAgIGxvYWRIaWRkZW46IHRydWUsXG4gICAgICByaWNUaW1lb3V0OiAwLFxuICAgICAgdGhyb3R0bGVEZWxheTogMTI1XG4gICAgfTtcbiAgICBsYXp5U2l6ZXNDZmcgPSB3aW5kb3cubGF6eVNpemVzQ29uZmlnIHx8IHdpbmRvdy5sYXp5c2l6ZXNDb25maWcgfHwge307XG4gICAgZm9yIChwcm9wIGluIGxhenlTaXplc0RlZmF1bHRzKSB7XG4gICAgICBpZiAoIShwcm9wIGluIGxhenlTaXplc0NmZykpIHtcbiAgICAgICAgbGF6eVNpemVzQ2ZnW3Byb3BdID0gbGF6eVNpemVzRGVmYXVsdHNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuICBpZiAoIWRvY3VtZW50IHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7fSxcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgeyBMYXp5U2l6ZXNDb25maWdQYXJ0aWFsIH1cbiAgICAgICAqL1xuICAgICAgY2ZnOiBsYXp5U2l6ZXNDZmcsXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHsgdHJ1ZSB9XG4gICAgICAgKi9cbiAgICAgIG5vU3VwcG9ydDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgdmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBzdXBwb3J0UGljdHVyZSA9IHdpbmRvdy5IVE1MUGljdHVyZUVsZW1lbnQ7XG4gIHZhciBfYWRkRXZlbnRMaXN0ZW5lciA9ICdhZGRFdmVudExpc3RlbmVyJztcbiAgdmFyIF9nZXRBdHRyaWJ1dGUgPSAnZ2V0QXR0cmlidXRlJztcblxuICAvKipcbiAgICogVXBkYXRlIHRvIGJpbmQgdG8gd2luZG93IGJlY2F1c2UgJ3RoaXMnIGJlY29tZXMgbnVsbCBkdXJpbmcgU1NSXG4gICAqIGJ1aWxkcy5cbiAgICovXG4gIHZhciBhZGRFdmVudExpc3RlbmVyID0gd2luZG93W19hZGRFdmVudExpc3RlbmVyXS5iaW5kKHdpbmRvdyk7XG4gIHZhciBzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG4gIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHNldFRpbWVvdXQ7XG4gIHZhciByZXF1ZXN0SWRsZUNhbGxiYWNrID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2s7XG4gIHZhciByZWdQaWN0dXJlID0gL15waWN0dXJlJC9pO1xuICB2YXIgbG9hZEV2ZW50cyA9IFsnbG9hZCcsICdlcnJvcicsICdsYXp5aW5jbHVkZWQnLCAnX2xhenlsb2FkZWQnXTtcbiAgdmFyIHJlZ0NsYXNzQ2FjaGUgPSB7fTtcbiAgdmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcblxuICAvKipcbiAgICogQHBhcmFtIGVsZSB7RWxlbWVudH1cbiAgICogQHBhcmFtIGNscyB7c3RyaW5nfVxuICAgKi9cbiAgdmFyIGhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoZWxlLCBjbHMpIHtcbiAgICBpZiAoIXJlZ0NsYXNzQ2FjaGVbY2xzXSkge1xuICAgICAgcmVnQ2xhc3NDYWNoZVtjbHNdID0gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJyArIGNscyArICcoXFxcXHN8JCknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ0NsYXNzQ2FjaGVbY2xzXS50ZXN0KGVsZVtfZ2V0QXR0cmlidXRlXSgnY2xhc3MnKSB8fCAnJykgJiYgcmVnQ2xhc3NDYWNoZVtjbHNdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gZWxlIHtFbGVtZW50fVxuICAgKiBAcGFyYW0gY2xzIHtzdHJpbmd9XG4gICAqL1xuICB2YXIgYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyhlbGUsIGNscykge1xuICAgIGlmICghaGFzQ2xhc3MoZWxlLCBjbHMpKSB7XG4gICAgICBlbGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIChlbGVbX2dldEF0dHJpYnV0ZV0oJ2NsYXNzJykgfHwgJycpLnRyaW0oKSArICcgJyArIGNscyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gZWxlIHtFbGVtZW50fVxuICAgKiBAcGFyYW0gY2xzIHtzdHJpbmd9XG4gICAqL1xuICB2YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGUsIGNscykge1xuICAgIHZhciByZWc7XG4gICAgaWYgKHJlZyA9IGhhc0NsYXNzKGVsZSwgY2xzKSkge1xuICAgICAgZWxlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoZWxlW19nZXRBdHRyaWJ1dGVdKCdjbGFzcycpIHx8ICcnKS5yZXBsYWNlKHJlZywgJyAnKSk7XG4gICAgfVxuICB9O1xuICB2YXIgYWRkUmVtb3ZlTG9hZEV2ZW50cyA9IGZ1bmN0aW9uIGFkZFJlbW92ZUxvYWRFdmVudHMoZG9tLCBmbiwgYWRkKSB7XG4gICAgdmFyIGFjdGlvbiA9IGFkZCA/IF9hZGRFdmVudExpc3RlbmVyIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGlmIChhZGQpIHtcbiAgICAgIGFkZFJlbW92ZUxvYWRFdmVudHMoZG9tLCBmbik7XG4gICAgfVxuICAgIGxvYWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBkb21bYWN0aW9uXShldnQsIGZuKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIGVsZW0geyBFbGVtZW50IH1cbiAgICogQHBhcmFtIG5hbWUgeyBzdHJpbmcgfVxuICAgKiBAcGFyYW0gZGV0YWlsIHsgYW55IH1cbiAgICogQHBhcmFtIG5vQnViYmxlcyB7IGJvb2xlYW4gfVxuICAgKiBAcGFyYW0gbm9DYW5jZWxhYmxlIHsgYm9vbGVhbiB9XG4gICAqIEByZXR1cm5zIHsgQ3VzdG9tRXZlbnQgfVxuICAgKi9cbiAgdmFyIHRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIHRyaWdnZXJFdmVudChlbGVtLCBuYW1lLCBkZXRhaWwsIG5vQnViYmxlcywgbm9DYW5jZWxhYmxlKSB7XG4gICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgaWYgKCFkZXRhaWwpIHtcbiAgICAgIGRldGFpbCA9IHt9O1xuICAgIH1cbiAgICBkZXRhaWwuaW5zdGFuY2UgPSBsYXp5c2l6ZXM7XG4gICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsICFub0J1YmJsZXMsICFub0NhbmNlbGFibGUpO1xuICAgIGV2ZW50LmRldGFpbCA9IGRldGFpbDtcbiAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfTtcbiAgdmFyIHVwZGF0ZVBvbHlmaWxsID0gZnVuY3Rpb24gdXBkYXRlUG9seWZpbGwoZWwsIGZ1bGwpIHtcbiAgICB2YXIgcG9seWZpbGw7XG4gICAgaWYgKCFzdXBwb3J0UGljdHVyZSAmJiAocG9seWZpbGwgPSB3aW5kb3cucGljdHVyZWZpbGwgfHwgbGF6eVNpemVzQ2ZnLnBmKSkge1xuICAgICAgaWYgKGZ1bGwgJiYgZnVsbC5zcmMgJiYgIWVsW19nZXRBdHRyaWJ1dGVdKCdzcmNzZXQnKSkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3NyY3NldCcsIGZ1bGwuc3JjKTtcbiAgICAgIH1cbiAgICAgIHBvbHlmaWxsKHtcbiAgICAgICAgcmVldmFsdWF0ZTogdHJ1ZSxcbiAgICAgICAgZWxlbWVudHM6IFtlbF1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZnVsbCAmJiBmdWxsLnNyYykge1xuICAgICAgZWwuc3JjID0gZnVsbC5zcmM7XG4gICAgfVxuICB9O1xuICB2YXIgZ2V0Q1NTID0gZnVuY3Rpb24gZ2V0Q1NTKGVsZW0sIHN0eWxlKSB7XG4gICAgcmV0dXJuIChnZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpIHx8IHt9KVtzdHlsZV07XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtIHsgRWxlbWVudCB9XG4gICAqIEBwYXJhbSBwYXJlbnQgeyBFbGVtZW50IH1cbiAgICogQHBhcmFtIFt3aWR0aF0ge251bWJlcn1cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHZhciBnZXRXaWR0aCA9IGZ1bmN0aW9uIGdldFdpZHRoKGVsZW0sIHBhcmVudCwgd2lkdGgpIHtcbiAgICB3aWR0aCA9IHdpZHRoIHx8IGVsZW0ub2Zmc2V0V2lkdGg7XG4gICAgd2hpbGUgKHdpZHRoIDwgbGF6eVNpemVzQ2ZnLm1pblNpemUgJiYgcGFyZW50ICYmICFlbGVtLl9sYXp5c2l6ZXNXaWR0aCkge1xuICAgICAgd2lkdGggPSBwYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9O1xuICB2YXIgckFGID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBydW5uaW5nLCB3YWl0aW5nO1xuICAgIHZhciBmaXJzdEZucyA9IFtdO1xuICAgIHZhciBzZWNvbmRGbnMgPSBbXTtcbiAgICB2YXIgZm5zID0gZmlyc3RGbnM7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHZhciBydW5GbnMgPSBmbnM7XG4gICAgICBmbnMgPSBmaXJzdEZucy5sZW5ndGggPyBzZWNvbmRGbnMgOiBmaXJzdEZucztcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHJ1bkZucy5sZW5ndGgpIHtcbiAgICAgICAgcnVuRm5zLnNoaWZ0KCkoKTtcbiAgICAgIH1cbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIHZhciByYWZCYXRjaCA9IGZ1bmN0aW9uIHJhZkJhdGNoKGZuLCBxdWV1ZSkge1xuICAgICAgaWYgKHJ1bm5pbmcgJiYgIXF1ZXVlKSB7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbnMucHVzaChmbik7XG4gICAgICAgIGlmICghd2FpdGluZykge1xuICAgICAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgICAgIChkb2N1bWVudC5oaWRkZW4gPyBzZXRUaW1lb3V0IDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKShydW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByYWZCYXRjaC5fbHNGbHVzaCA9IHJ1bjtcbiAgICByZXR1cm4gcmFmQmF0Y2g7XG4gIH0oKTtcbiAgdmFyIHJBRkl0ID0gZnVuY3Rpb24gckFGSXQoZm4sIHNpbXBsZSkge1xuICAgIHJldHVybiBzaW1wbGUgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByQUYoZm4pO1xuICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJBRihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbiAgdmFyIHRocm90dGxlID0gZnVuY3Rpb24gdGhyb3R0bGUoZm4pIHtcbiAgICB2YXIgcnVubmluZztcbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHZhciBnRGVsYXkgPSBsYXp5U2l6ZXNDZmcudGhyb3R0bGVEZWxheTtcbiAgICB2YXIgcklDVGltZW91dCA9IGxhenlTaXplc0NmZy5yaWNUaW1lb3V0O1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBmbigpO1xuICAgIH07XG4gICAgdmFyIGlkbGVDYWxsYmFjayA9IHJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgcklDVGltZW91dCA+IDQ5ID8gZnVuY3Rpb24gKCkge1xuICAgICAgcmVxdWVzdElkbGVDYWxsYmFjayhydW4sIHtcbiAgICAgICAgdGltZW91dDogcklDVGltZW91dFxuICAgICAgfSk7XG4gICAgICBpZiAocklDVGltZW91dCAhPT0gbGF6eVNpemVzQ2ZnLnJpY1RpbWVvdXQpIHtcbiAgICAgICAgcklDVGltZW91dCA9IGxhenlTaXplc0NmZy5yaWNUaW1lb3V0O1xuICAgICAgfVxuICAgIH0gOiByQUZJdChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KHJ1bik7XG4gICAgfSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpc1ByaW9yaXR5KSB7XG4gICAgICB2YXIgZGVsYXk7XG4gICAgICBpZiAoaXNQcmlvcml0eSA9IGlzUHJpb3JpdHkgPT09IHRydWUpIHtcbiAgICAgICAgcklDVGltZW91dCA9IDMzO1xuICAgICAgfVxuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICBkZWxheSA9IGdEZWxheSAtIChEYXRlLm5vdygpIC0gbGFzdFRpbWUpO1xuICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmlvcml0eSB8fCBkZWxheSA8IDkpIHtcbiAgICAgICAgaWRsZUNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGlkbGVDYWxsYmFjaywgZGVsYXkpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy9iYXNlZCBvbiBodHRwOi8vbW9kZXJuamF2YXNjcmlwdC5ibG9nc3BvdC5kZS8yMDEzLzA4L2J1aWxkaW5nLWJldHRlci1kZWJvdW5jZS5odG1sXG4gIHZhciBkZWJvdW5jZSA9IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMpIHtcbiAgICB2YXIgdGltZW91dCwgdGltZXN0YW1wO1xuICAgIHZhciB3YWl0ID0gOTk7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgZnVuYygpO1xuICAgIH07XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgICBpZiAobGFzdCA8IHdhaXQpIHtcbiAgICAgICAgc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgcnVuKShydW4pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHZhciBsb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZWxvYWRFbGVtcywgaXNDb21wbGV0ZWQsIHJlc2V0UHJlbG9hZGluZ1RpbWVyLCBsb2FkTW9kZSwgc3RhcnRlZDtcbiAgICB2YXIgZUx2VywgZWx2SCwgZUx0b3AsIGVMbGVmdCwgZUxyaWdodCwgZUxib3R0b20sIGlzQm9keUhpZGRlbjtcbiAgICB2YXIgcmVnSW1nID0gL15pbWckL2k7XG4gICAgdmFyIHJlZ0lmcmFtZSA9IC9eaWZyYW1lJC9pO1xuICAgIHZhciBzdXBwb3J0U2Nyb2xsID0gJ29uc2Nyb2xsJyBpbiB3aW5kb3cgJiYgIS8oZ2xlfGluZylib3QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHNocmlua0V4cGFuZCA9IDA7XG4gICAgdmFyIGN1cnJlbnRFeHBhbmQgPSAwO1xuICAgIHZhciBpc0xvYWRpbmcgPSAwO1xuICAgIHZhciBsb3dSdW5zID0gLTE7XG4gICAgdmFyIHJlc2V0UHJlbG9hZGluZyA9IGZ1bmN0aW9uIHJlc2V0UHJlbG9hZGluZyhlKSB7XG4gICAgICBpc0xvYWRpbmctLTtcbiAgICAgIGlmICghZSB8fCBpc0xvYWRpbmcgPCAwIHx8ICFlLnRhcmdldCkge1xuICAgICAgICBpc0xvYWRpbmcgPSAwO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGlzVmlzaWJsZSA9IGZ1bmN0aW9uIGlzVmlzaWJsZShlbGVtKSB7XG4gICAgICBpZiAoaXNCb2R5SGlkZGVuID09IG51bGwpIHtcbiAgICAgICAgaXNCb2R5SGlkZGVuID0gZ2V0Q1NTKGRvY3VtZW50LmJvZHksICd2aXNpYmlsaXR5JykgPT0gJ2hpZGRlbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNCb2R5SGlkZGVuIHx8ICEoZ2V0Q1NTKGVsZW0ucGFyZW50Tm9kZSwgJ3Zpc2liaWxpdHknKSA9PSAnaGlkZGVuJyAmJiBnZXRDU1MoZWxlbSwgJ3Zpc2liaWxpdHknKSA9PSAnaGlkZGVuJyk7XG4gICAgfTtcbiAgICB2YXIgaXNOZXN0ZWRWaXNpYmxlID0gZnVuY3Rpb24gaXNOZXN0ZWRWaXNpYmxlKGVsZW0sIGVsZW1FeHBhbmQpIHtcbiAgICAgIHZhciBvdXRlclJlY3Q7XG4gICAgICB2YXIgcGFyZW50ID0gZWxlbTtcbiAgICAgIHZhciB2aXNpYmxlID0gaXNWaXNpYmxlKGVsZW0pO1xuICAgICAgZUx0b3AgLT0gZWxlbUV4cGFuZDtcbiAgICAgIGVMYm90dG9tICs9IGVsZW1FeHBhbmQ7XG4gICAgICBlTGxlZnQgLT0gZWxlbUV4cGFuZDtcbiAgICAgIGVMcmlnaHQgKz0gZWxlbUV4cGFuZDtcbiAgICAgIHdoaWxlICh2aXNpYmxlICYmIChwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50KSAmJiBwYXJlbnQgIT0gZG9jdW1lbnQuYm9keSAmJiBwYXJlbnQgIT0gZG9jRWxlbSkge1xuICAgICAgICB2aXNpYmxlID0gKGdldENTUyhwYXJlbnQsICdvcGFjaXR5JykgfHwgMSkgPiAwO1xuICAgICAgICBpZiAodmlzaWJsZSAmJiBnZXRDU1MocGFyZW50LCAnb3ZlcmZsb3cnKSAhPSAndmlzaWJsZScpIHtcbiAgICAgICAgICBvdXRlclJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgdmlzaWJsZSA9IGVMcmlnaHQgPiBvdXRlclJlY3QubGVmdCAmJiBlTGxlZnQgPCBvdXRlclJlY3QucmlnaHQgJiYgZUxib3R0b20gPiBvdXRlclJlY3QudG9wIC0gMSAmJiBlTHRvcCA8IG91dGVyUmVjdC5ib3R0b20gKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9O1xuICAgIHZhciBjaGVja0VsZW1lbnRzID0gZnVuY3Rpb24gY2hlY2tFbGVtZW50cygpIHtcbiAgICAgIHZhciBlTGxlbiwgaSwgcmVjdCwgYXV0b0xvYWRFbGVtLCBsb2FkZWRTb21ldGhpbmcsIGVsZW1FeHBhbmQsIGVsZW1OZWdhdGl2ZUV4cGFuZCwgZWxlbUV4cGFuZFZhbCwgYmVmb3JlRXhwYW5kVmFsLCBkZWZhdWx0RXhwYW5kLCBwcmVsb2FkRXhwYW5kLCBoRmFjO1xuICAgICAgdmFyIGxhenlsb2FkRWxlbXMgPSBsYXp5c2l6ZXMuZWxlbWVudHM7XG4gICAgICBpZiAoKGxvYWRNb2RlID0gbGF6eVNpemVzQ2ZnLmxvYWRNb2RlKSAmJiBpc0xvYWRpbmcgPCA4ICYmIChlTGxlbiA9IGxhenlsb2FkRWxlbXMubGVuZ3RoKSkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgbG93UnVucysrO1xuICAgICAgICBmb3IgKDsgaSA8IGVMbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxhenlsb2FkRWxlbXNbaV0gfHwgbGF6eWxvYWRFbGVtc1tpXS5fbGF6eVJhY2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN1cHBvcnRTY3JvbGwgfHwgbGF6eXNpemVzLnByZW1hdHVyZVVudmVpbCAmJiBsYXp5c2l6ZXMucHJlbWF0dXJlVW52ZWlsKGxhenlsb2FkRWxlbXNbaV0pKSB7XG4gICAgICAgICAgICB1bnZlaWxFbGVtZW50KGxhenlsb2FkRWxlbXNbaV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKGVsZW1FeHBhbmRWYWwgPSBsYXp5bG9hZEVsZW1zW2ldW19nZXRBdHRyaWJ1dGVdKCdkYXRhLWV4cGFuZCcpKSB8fCAhKGVsZW1FeHBhbmQgPSBlbGVtRXhwYW5kVmFsICogMSkpIHtcbiAgICAgICAgICAgIGVsZW1FeHBhbmQgPSBjdXJyZW50RXhwYW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRlZmF1bHRFeHBhbmQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRFeHBhbmQgPSAhbGF6eVNpemVzQ2ZnLmV4cGFuZCB8fCBsYXp5U2l6ZXNDZmcuZXhwYW5kIDwgMSA/IGRvY0VsZW0uY2xpZW50SGVpZ2h0ID4gNTAwICYmIGRvY0VsZW0uY2xpZW50V2lkdGggPiA1MDAgPyA1MDAgOiAzNzAgOiBsYXp5U2l6ZXNDZmcuZXhwYW5kO1xuICAgICAgICAgICAgbGF6eXNpemVzLl9kZWZFeCA9IGRlZmF1bHRFeHBhbmQ7XG4gICAgICAgICAgICBwcmVsb2FkRXhwYW5kID0gZGVmYXVsdEV4cGFuZCAqIGxhenlTaXplc0NmZy5leHBGYWN0b3I7XG4gICAgICAgICAgICBoRmFjID0gbGF6eVNpemVzQ2ZnLmhGYWM7XG4gICAgICAgICAgICBpc0JvZHlIaWRkZW4gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFeHBhbmQgPCBwcmVsb2FkRXhwYW5kICYmIGlzTG9hZGluZyA8IDEgJiYgbG93UnVucyA+IDIgJiYgbG9hZE1vZGUgPiAyICYmICFkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgY3VycmVudEV4cGFuZCA9IHByZWxvYWRFeHBhbmQ7XG4gICAgICAgICAgICAgIGxvd1J1bnMgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2FkTW9kZSA+IDEgJiYgbG93UnVucyA+IDEgJiYgaXNMb2FkaW5nIDwgNikge1xuICAgICAgICAgICAgICBjdXJyZW50RXhwYW5kID0gZGVmYXVsdEV4cGFuZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRFeHBhbmQgPSBzaHJpbmtFeHBhbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiZWZvcmVFeHBhbmRWYWwgIT09IGVsZW1FeHBhbmQpIHtcbiAgICAgICAgICAgIGVMdlcgPSBpbm5lcldpZHRoICsgZWxlbUV4cGFuZCAqIGhGYWM7XG4gICAgICAgICAgICBlbHZIID0gaW5uZXJIZWlnaHQgKyBlbGVtRXhwYW5kO1xuICAgICAgICAgICAgZWxlbU5lZ2F0aXZlRXhwYW5kID0gZWxlbUV4cGFuZCAqIC0xO1xuICAgICAgICAgICAgYmVmb3JlRXhwYW5kVmFsID0gZWxlbUV4cGFuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjdCA9IGxhenlsb2FkRWxlbXNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgaWYgKChlTGJvdHRvbSA9IHJlY3QuYm90dG9tKSA+PSBlbGVtTmVnYXRpdmVFeHBhbmQgJiYgKGVMdG9wID0gcmVjdC50b3ApIDw9IGVsdkggJiYgKGVMcmlnaHQgPSByZWN0LnJpZ2h0KSA+PSBlbGVtTmVnYXRpdmVFeHBhbmQgKiBoRmFjICYmIChlTGxlZnQgPSByZWN0LmxlZnQpIDw9IGVMdlcgJiYgKGVMYm90dG9tIHx8IGVMcmlnaHQgfHwgZUxsZWZ0IHx8IGVMdG9wKSAmJiAobGF6eVNpemVzQ2ZnLmxvYWRIaWRkZW4gfHwgaXNWaXNpYmxlKGxhenlsb2FkRWxlbXNbaV0pKSAmJiAoaXNDb21wbGV0ZWQgJiYgaXNMb2FkaW5nIDwgMyAmJiAhZWxlbUV4cGFuZFZhbCAmJiAobG9hZE1vZGUgPCAzIHx8IGxvd1J1bnMgPCA0KSB8fCBpc05lc3RlZFZpc2libGUobGF6eWxvYWRFbGVtc1tpXSwgZWxlbUV4cGFuZCkpKSB7XG4gICAgICAgICAgICB1bnZlaWxFbGVtZW50KGxhenlsb2FkRWxlbXNbaV0pO1xuICAgICAgICAgICAgbG9hZGVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpc0xvYWRpbmcgPiA5KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWxvYWRlZFNvbWV0aGluZyAmJiBpc0NvbXBsZXRlZCAmJiAhYXV0b0xvYWRFbGVtICYmIGlzTG9hZGluZyA8IDQgJiYgbG93UnVucyA8IDQgJiYgbG9hZE1vZGUgPiAyICYmIChwcmVsb2FkRWxlbXNbMF0gfHwgbGF6eVNpemVzQ2ZnLnByZWxvYWRBZnRlckxvYWQpICYmIChwcmVsb2FkRWxlbXNbMF0gfHwgIWVsZW1FeHBhbmRWYWwgJiYgKGVMYm90dG9tIHx8IGVMcmlnaHQgfHwgZUxsZWZ0IHx8IGVMdG9wIHx8IGxhenlsb2FkRWxlbXNbaV1bX2dldEF0dHJpYnV0ZV0obGF6eVNpemVzQ2ZnLnNpemVzQXR0cikgIT0gJ2F1dG8nKSkpIHtcbiAgICAgICAgICAgIGF1dG9Mb2FkRWxlbSA9IHByZWxvYWRFbGVtc1swXSB8fCBsYXp5bG9hZEVsZW1zW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b0xvYWRFbGVtICYmICFsb2FkZWRTb21ldGhpbmcpIHtcbiAgICAgICAgICB1bnZlaWxFbGVtZW50KGF1dG9Mb2FkRWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0aHJvdHRsZWRDaGVja0VsZW1lbnRzID0gdGhyb3R0bGUoY2hlY2tFbGVtZW50cyk7XG4gICAgdmFyIHN3aXRjaExvYWRpbmdDbGFzcyA9IGZ1bmN0aW9uIHN3aXRjaExvYWRpbmdDbGFzcyhlKSB7XG4gICAgICB2YXIgZWxlbSA9IGUudGFyZ2V0O1xuICAgICAgaWYgKGVsZW0uX2xhenlDYWNoZSkge1xuICAgICAgICBkZWxldGUgZWxlbS5fbGF6eUNhY2hlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNldFByZWxvYWRpbmcoZSk7XG4gICAgICBhZGRDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDZmcubG9hZGVkQ2xhc3MpO1xuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbSwgbGF6eVNpemVzQ2ZnLmxvYWRpbmdDbGFzcyk7XG4gICAgICBhZGRSZW1vdmVMb2FkRXZlbnRzKGVsZW0sIHJhZlN3aXRjaExvYWRpbmdDbGFzcyk7XG4gICAgICB0cmlnZ2VyRXZlbnQoZWxlbSwgJ2xhenlsb2FkZWQnKTtcbiAgICB9O1xuICAgIHZhciByYWZlZFN3aXRjaExvYWRpbmdDbGFzcyA9IHJBRkl0KHN3aXRjaExvYWRpbmdDbGFzcyk7XG4gICAgdmFyIHJhZlN3aXRjaExvYWRpbmdDbGFzcyA9IGZ1bmN0aW9uIHJhZlN3aXRjaExvYWRpbmdDbGFzcyhlKSB7XG4gICAgICByYWZlZFN3aXRjaExvYWRpbmdDbGFzcyh7XG4gICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGNoYW5nZUlmcmFtZVNyYyA9IGZ1bmN0aW9uIGNoYW5nZUlmcmFtZVNyYyhlbGVtLCBzcmMpIHtcbiAgICAgIHZhciBsb2FkTW9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWxvYWQtbW9kZScpIHx8IGxhenlTaXplc0NmZy5pZnJhbWVMb2FkTW9kZTtcblxuICAgICAgLy8gbG9hZE1vZGUgY2FuIGJlIGFsc28gYSBzdHJpbmchXG4gICAgICBpZiAobG9hZE1vZGUgPT0gMCkge1xuICAgICAgICBlbGVtLmNvbnRlbnRXaW5kb3cubG9jYXRpb24ucmVwbGFjZShzcmMpO1xuICAgICAgfSBlbHNlIGlmIChsb2FkTW9kZSA9PSAxKSB7XG4gICAgICAgIGVsZW0uc3JjID0gc3JjO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZVNvdXJjZXMgPSBmdW5jdGlvbiBoYW5kbGVTb3VyY2VzKHNvdXJjZSkge1xuICAgICAgdmFyIGN1c3RvbU1lZGlhO1xuICAgICAgdmFyIHNvdXJjZVNyY3NldCA9IHNvdXJjZVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDZmcuc3Jjc2V0QXR0cik7XG4gICAgICBpZiAoY3VzdG9tTWVkaWEgPSBsYXp5U2l6ZXNDZmcuY3VzdG9tTWVkaWFbc291cmNlW19nZXRBdHRyaWJ1dGVdKCdkYXRhLW1lZGlhJykgfHwgc291cmNlW19nZXRBdHRyaWJ1dGVdKCdtZWRpYScpXSkge1xuICAgICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKCdtZWRpYScsIGN1c3RvbU1lZGlhKTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2VTcmNzZXQpIHtcbiAgICAgICAgc291cmNlLnNldEF0dHJpYnV0ZSgnc3Jjc2V0Jywgc291cmNlU3Jjc2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBsYXp5VW52ZWlsID0gckFGSXQoZnVuY3Rpb24gKGVsZW0sIGRldGFpbCwgaXNBdXRvLCBzaXplcywgaXNJbWcpIHtcbiAgICAgIHZhciBzcmMsIHNyY3NldCwgcGFyZW50LCBpc1BpY3R1cmUsIGV2ZW50LCBmaXJlc0xvYWQ7XG4gICAgICBpZiAoIShldmVudCA9IHRyaWdnZXJFdmVudChlbGVtLCAnbGF6eWJlZm9yZXVudmVpbCcsIGRldGFpbCkpLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgaWYgKHNpemVzKSB7XG4gICAgICAgICAgaWYgKGlzQXV0bykge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbSwgbGF6eVNpemVzQ2ZnLmF1dG9zaXplc0NsYXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3NpemVzJywgc2l6ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzcmNzZXQgPSBlbGVtW19nZXRBdHRyaWJ1dGVdKGxhenlTaXplc0NmZy5zcmNzZXRBdHRyKTtcbiAgICAgICAgc3JjID0gZWxlbVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDZmcuc3JjQXR0cik7XG4gICAgICAgIGlmIChpc0ltZykge1xuICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICBpc1BpY3R1cmUgPSBwYXJlbnQgJiYgcmVnUGljdHVyZS50ZXN0KHBhcmVudC5ub2RlTmFtZSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZXNMb2FkID0gZGV0YWlsLmZpcmVzTG9hZCB8fCAnc3JjJyBpbiBlbGVtICYmIChzcmNzZXQgfHwgc3JjIHx8IGlzUGljdHVyZSk7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHRhcmdldDogZWxlbVxuICAgICAgICB9O1xuICAgICAgICBhZGRDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDZmcubG9hZGluZ0NsYXNzKTtcbiAgICAgICAgaWYgKGZpcmVzTG9hZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChyZXNldFByZWxvYWRpbmdUaW1lcik7XG4gICAgICAgICAgcmVzZXRQcmVsb2FkaW5nVGltZXIgPSBzZXRUaW1lb3V0KHJlc2V0UHJlbG9hZGluZywgMjUwMCk7XG4gICAgICAgICAgYWRkUmVtb3ZlTG9hZEV2ZW50cyhlbGVtLCByYWZTd2l0Y2hMb2FkaW5nQ2xhc3MsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BpY3R1cmUpIHtcbiAgICAgICAgICBmb3JFYWNoLmNhbGwocGFyZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKSwgaGFuZGxlU291cmNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyY3NldCkge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdzcmNzZXQnLCBzcmNzZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHNyYyAmJiAhaXNQaWN0dXJlKSB7XG4gICAgICAgICAgaWYgKHJlZ0lmcmFtZS50ZXN0KGVsZW0ubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICBjaGFuZ2VJZnJhbWVTcmMoZWxlbSwgc3JjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5zcmMgPSBzcmM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ltZyAmJiAoc3Jjc2V0IHx8IGlzUGljdHVyZSkpIHtcbiAgICAgICAgICB1cGRhdGVQb2x5ZmlsbChlbGVtLCB7XG4gICAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxlbS5fbGF6eVJhY2UpIHtcbiAgICAgICAgZGVsZXRlIGVsZW0uX2xhenlSYWNlO1xuICAgICAgfVxuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbSwgbGF6eVNpemVzQ2ZnLmxhenlDbGFzcyk7XG4gICAgICByQUYoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJ0IG9mIHRoaXMgY2FuIGJlIHJlbW92ZWQgYXMgc29vbiBhcyB0aGlzIGZpeCBpcyBvbGRlcjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NzczMSAoMjAxNSlcbiAgICAgICAgdmFyIGlzTG9hZGVkID0gZWxlbS5jb21wbGV0ZSAmJiBlbGVtLm5hdHVyYWxXaWR0aCA+IDE7XG4gICAgICAgIGlmICghZmlyZXNMb2FkIHx8IGlzTG9hZGVkKSB7XG4gICAgICAgICAgaWYgKGlzTG9hZGVkKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDZmcuZmFzdExvYWRlZENsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoTG9hZGluZ0NsYXNzKGV2ZW50KTtcbiAgICAgICAgICBlbGVtLl9sYXp5Q2FjaGUgPSB0cnVlO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCdfbGF6eUNhY2hlJyBpbiBlbGVtKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbGVtLl9sYXp5Q2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgOSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW0ubG9hZGluZyA9PSAnbGF6eScpIHtcbiAgICAgICAgICBpc0xvYWRpbmctLTtcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIHsgRWxlbWVudCB9XG4gICAgICovXG4gICAgdmFyIHVudmVpbEVsZW1lbnQgPSBmdW5jdGlvbiB1bnZlaWxFbGVtZW50KGVsZW0pIHtcbiAgICAgIGlmIChlbGVtLl9sYXp5UmFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGV0YWlsO1xuICAgICAgdmFyIGlzSW1nID0gcmVnSW1nLnRlc3QoZWxlbS5ub2RlTmFtZSk7XG5cbiAgICAgIC8vYWxsb3cgdXNpbmcgc2l6ZXM9XCJhdXRvXCIsIGJ1dCBkb24ndCB1c2UuIGl0J3MgaW52YWxpZC4gVXNlIGRhdGEtc2l6ZXM9XCJhdXRvXCIgb3IgYSB2YWxpZCB2YWx1ZSBmb3Igc2l6ZXMgaW5zdGVhZCAoaS5lLjogc2l6ZXM9XCI4MHZ3XCIpXG4gICAgICB2YXIgc2l6ZXMgPSBpc0ltZyAmJiAoZWxlbVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDZmcuc2l6ZXNBdHRyKSB8fCBlbGVtW19nZXRBdHRyaWJ1dGVdKCdzaXplcycpKTtcbiAgICAgIHZhciBpc0F1dG8gPSBzaXplcyA9PSAnYXV0byc7XG4gICAgICBpZiAoKGlzQXV0byB8fCAhaXNDb21wbGV0ZWQpICYmIGlzSW1nICYmIChlbGVtW19nZXRBdHRyaWJ1dGVdKCdzcmMnKSB8fCBlbGVtLnNyY3NldCkgJiYgIWVsZW0uY29tcGxldGUgJiYgIWhhc0NsYXNzKGVsZW0sIGxhenlTaXplc0NmZy5lcnJvckNsYXNzKSAmJiBoYXNDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDZmcubGF6eUNsYXNzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZXRhaWwgPSB0cmlnZ2VyRXZlbnQoZWxlbSwgJ2xhenl1bnZlaWxyZWFkJykuZGV0YWlsO1xuICAgICAgaWYgKGlzQXV0bykge1xuICAgICAgICBhdXRvU2l6ZXIudXBkYXRlRWxlbShlbGVtLCB0cnVlLCBlbGVtLm9mZnNldFdpZHRoKTtcbiAgICAgIH1cbiAgICAgIGVsZW0uX2xhenlSYWNlID0gdHJ1ZTtcbiAgICAgIGlzTG9hZGluZysrO1xuICAgICAgbGF6eVVudmVpbChlbGVtLCBkZXRhaWwsIGlzQXV0bywgc2l6ZXMsIGlzSW1nKTtcbiAgICB9O1xuICAgIHZhciBhZnRlclNjcm9sbCA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxhenlTaXplc0NmZy5sb2FkTW9kZSA9IDM7XG4gICAgICB0aHJvdHRsZWRDaGVja0VsZW1lbnRzKCk7XG4gICAgfSk7XG4gICAgdmFyIGFsdExvYWRtb2RlU2Nyb2xsTGlzdG5lciA9IGZ1bmN0aW9uIGFsdExvYWRtb2RlU2Nyb2xsTGlzdG5lcigpIHtcbiAgICAgIGlmIChsYXp5U2l6ZXNDZmcubG9hZE1vZGUgPT0gMykge1xuICAgICAgICBsYXp5U2l6ZXNDZmcubG9hZE1vZGUgPSAyO1xuICAgICAgfVxuICAgICAgYWZ0ZXJTY3JvbGwoKTtcbiAgICB9O1xuICAgIHZhciBvbmxvYWQgPSBmdW5jdGlvbiBvbmxvYWQoKSB7XG4gICAgICBpZiAoaXNDb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydGVkIDwgOTk5KSB7XG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkLCA5OTkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICBsYXp5U2l6ZXNDZmcubG9hZE1vZGUgPSAzO1xuICAgICAgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cygpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgYWx0TG9hZG1vZGVTY3JvbGxMaXN0bmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBfOiBmdW5jdGlvbiBfKCkge1xuICAgICAgICBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGF6eXNpemVzLmVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsYXp5U2l6ZXNDZmcubGF6eUNsYXNzKTtcbiAgICAgICAgcHJlbG9hZEVsZW1zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsYXp5U2l6ZXNDZmcubGF6eUNsYXNzICsgJyAnICsgbGF6eVNpemVzQ2ZnLnByZWxvYWRDbGFzcyk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChlLnBlcnNpc3RlZCkge1xuICAgICAgICAgICAgdmFyIGxvYWRpbmdFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgbGF6eVNpemVzQ2ZnLmxvYWRpbmdDbGFzcyk7XG4gICAgICAgICAgICBpZiAobG9hZGluZ0VsZW1lbnRzLmxlbmd0aCAmJiBsb2FkaW5nRWxlbWVudHMuZm9yRWFjaCkge1xuICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdW52ZWlsRWxlbWVudChpbWcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcih0aHJvdHRsZWRDaGVja0VsZW1lbnRzKS5vYnNlcnZlKGRvY0VsZW0sIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jRWxlbVtfYWRkRXZlbnRMaXN0ZW5lcl0oJ0RPTU5vZGVJbnNlcnRlZCcsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuICAgICAgICAgIGRvY0VsZW1bX2FkZEV2ZW50TGlzdGVuZXJdKCdET01BdHRyTW9kaWZpZWQnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcbiAgICAgICAgICBzZXRJbnRlcnZhbCh0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCA5OTkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLCB0cnVlKTtcblxuICAgICAgICAvLywgJ2Z1bGxzY3JlZW5jaGFuZ2UnXG4gICAgICAgIFsnZm9jdXMnLCAnbW91c2VvdmVyJywgJ2NsaWNrJywgJ2xvYWQnLCAndHJhbnNpdGlvbmVuZCcsICdhbmltYXRpb25lbmQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgZG9jdW1lbnRbX2FkZEV2ZW50TGlzdGVuZXJdKG5hbWUsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKC9kJHxeYy8udGVzdChkb2N1bWVudC5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgIG9ubG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgICAgIGRvY3VtZW50W19hZGRFdmVudExpc3RlbmVyXSgnRE9NQ29udGVudExvYWRlZCcsIHRocm90dGxlZENoZWNrRWxlbWVudHMpO1xuICAgICAgICAgIHNldFRpbWVvdXQob25sb2FkLCAyMDAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhenlzaXplcy5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBjaGVja0VsZW1lbnRzKCk7XG4gICAgICAgICAgckFGLl9sc0ZsdXNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hlY2tFbGVtczogdGhyb3R0bGVkQ2hlY2tFbGVtZW50cyxcbiAgICAgIHVudmVpbDogdW52ZWlsRWxlbWVudCxcbiAgICAgIF9hTFNMOiBhbHRMb2FkbW9kZVNjcm9sbExpc3RuZXJcbiAgICB9O1xuICB9KCk7XG4gIHZhciBhdXRvU2l6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF1dG9zaXplc0VsZW1zO1xuICAgIHZhciBzaXplRWxlbWVudCA9IHJBRkl0KGZ1bmN0aW9uIChlbGVtLCBwYXJlbnQsIGV2ZW50LCB3aWR0aCkge1xuICAgICAgdmFyIHNvdXJjZXMsIGksIGxlbjtcbiAgICAgIGVsZW0uX2xhenlzaXplc1dpZHRoID0gd2lkdGg7XG4gICAgICB3aWR0aCArPSAncHgnO1xuICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3NpemVzJywgd2lkdGgpO1xuICAgICAgaWYgKHJlZ1BpY3R1cmUudGVzdChwYXJlbnQubm9kZU5hbWUgfHwgJycpKSB7XG4gICAgICAgIHNvdXJjZXMgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc291cmNlc1tpXS5zZXRBdHRyaWJ1dGUoJ3NpemVzJywgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWV2ZW50LmRldGFpbC5kYXRhQXR0cikge1xuICAgICAgICB1cGRhdGVQb2x5ZmlsbChlbGVtLCBldmVudC5kZXRhaWwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW0ge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIGRhdGFBdHRyXG4gICAgICogQHBhcmFtIFt3aWR0aF0geyBudW1iZXIgfVxuICAgICAqL1xuICAgIHZhciBnZXRTaXplRWxlbWVudCA9IGZ1bmN0aW9uIGdldFNpemVFbGVtZW50KGVsZW0sIGRhdGFBdHRyLCB3aWR0aCkge1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgd2lkdGggPSBnZXRXaWR0aChlbGVtLCBwYXJlbnQsIHdpZHRoKTtcbiAgICAgICAgZXZlbnQgPSB0cmlnZ2VyRXZlbnQoZWxlbSwgJ2xhenliZWZvcmVzaXplcycsIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgZGF0YUF0dHI6ICEhZGF0YUF0dHJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHdpZHRoID0gZXZlbnQuZGV0YWlsLndpZHRoO1xuICAgICAgICAgIGlmICh3aWR0aCAmJiB3aWR0aCAhPT0gZWxlbS5fbGF6eXNpemVzV2lkdGgpIHtcbiAgICAgICAgICAgIHNpemVFbGVtZW50KGVsZW0sIHBhcmVudCwgZXZlbnQsIHdpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB1cGRhdGVFbGVtZW50c1NpemVzID0gZnVuY3Rpb24gdXBkYXRlRWxlbWVudHNTaXplcygpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGF1dG9zaXplc0VsZW1zLmxlbmd0aDtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBnZXRTaXplRWxlbWVudChhdXRvc2l6ZXNFbGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkZWJvdW5jZWRVcGRhdGVFbGVtZW50c1NpemVzID0gZGVib3VuY2UodXBkYXRlRWxlbWVudHNTaXplcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIF86IGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgIGF1dG9zaXplc0VsZW1zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsYXp5U2l6ZXNDZmcuYXV0b3NpemVzQ2xhc3MpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBkZWJvdW5jZWRVcGRhdGVFbGVtZW50c1NpemVzKTtcbiAgICAgIH0sXG4gICAgICBjaGVja0VsZW1zOiBkZWJvdW5jZWRVcGRhdGVFbGVtZW50c1NpemVzLFxuICAgICAgdXBkYXRlRWxlbTogZ2V0U2l6ZUVsZW1lbnRcbiAgICB9O1xuICB9KCk7XG4gIHZhciBpbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBpZiAoIWluaXQuaSAmJiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgICBpbml0LmkgPSB0cnVlO1xuICAgICAgYXV0b1NpemVyLl8oKTtcbiAgICAgIGxvYWRlci5fKCk7XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobGF6eVNpemVzQ2ZnLmluaXQpIHtcbiAgICAgIGluaXQoKTtcbiAgICB9XG4gIH0pO1xuICBsYXp5c2l6ZXMgPSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyBMYXp5U2l6ZXNDb25maWdQYXJ0aWFsIH1cbiAgICAgKi9cbiAgICBjZmc6IGxhenlTaXplc0NmZyxcbiAgICBhdXRvU2l6ZXI6IGF1dG9TaXplcixcbiAgICBsb2FkZXI6IGxvYWRlcixcbiAgICBpbml0OiBpbml0LFxuICAgIHVQOiB1cGRhdGVQb2x5ZmlsbCxcbiAgICBhQzogYWRkQ2xhc3MsXG4gICAgckM6IHJlbW92ZUNsYXNzLFxuICAgIGhDOiBoYXNDbGFzcyxcbiAgICBmaXJlOiB0cmlnZ2VyRXZlbnQsXG4gICAgZ1c6IGdldFdpZHRoLFxuICAgIHJBRjogckFGXG4gIH07XG4gIHJldHVybiBsYXp5c2l6ZXM7XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///64\n")},485:function(){"use strict";eval("// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg1LmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlc3Rhcm9ja2V0LWRldi10b29scy8uL2Nzcy90aGVtZS5zY3NzP2Q3YjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///485\n")},669:function(t){"use strict";t.exports=jQuery}},__webpack_module_cache__={};function __webpack_require__(t){var n=__webpack_module_cache__[t];if(void 0!==n)return n.exports;var e=__webpack_module_cache__[t]={id:t,loaded:!1,exports:{}};return __webpack_modules__[t](e,e.exports,__webpack_require__),e.loaded=!0,e.exports}__webpack_require__.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=function(t,n){for(var e in n)__webpack_require__.o(n,e)&&!__webpack_require__.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:n[e]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),__webpack_require__.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},__webpack_require__.nmd=function(t){return t.paths=[],t.children||(t.children=[]),t},__webpack_require__(741);var __webpack_exports__=__webpack_require__(485)})();